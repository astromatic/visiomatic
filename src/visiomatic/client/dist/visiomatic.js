(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.leaflet = {}));
      })(exports, function(exports2) {
        "use strict";
        var version = "1.9.3";
        function extend4(dest) {
          var i2, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i2 in src) {
              dest[i2] = src[i2];
            }
          }
          return dest;
        }
        var create$2 = Object.create || function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn, obj) {
          var slice = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x, range, includeMax) {
          var max = range[1], min = range[0], d2 = max - min;
          return x === max && includeMax ? x : ((x - min) % d2 + d2) % d2 + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow) / pow;
        }
        function trim(str2) {
          return str2.trim ? str2.trim() : str2.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str2) {
          return trim(str2).split(/\s+/);
        }
        function setOptions(obj, options2) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i2 in options2) {
            obj.options[i2] = options2[i2];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i2 in obj) {
            params.push(encodeURIComponent(uppercase ? i2.toUpperCase() : i2) + "=" + encodeURIComponent(obj[i2]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str2, data) {
          return str2.replace(templateRe, function(str3, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str3);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array, el) {
          for (var i2 = 0; i2 < array.length; i2++) {
            if (array[i2] === el) {
              return i2;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util23 = {
          __proto__: null,
          extend: extend4,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class4() {
        }
        Class4.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i2 in this) {
            if (Object.prototype.hasOwnProperty.call(this, i2) && i2 !== "prototype" && i2 !== "__super__") {
              NewClass[i2] = this[i2];
            }
          }
          if (props.statics) {
            extend4(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend4.apply(null, [proto].concat(props.includes));
          }
          extend4(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend4(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i3 = 0, len = proto._initHooks.length; i3 < len; i3++) {
              proto._initHooks[i3].call(this);
            }
          };
          return NewClass;
        };
        Class4.include = function(props) {
          var parentOptions = this.prototype.options;
          extend4(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class4.mergeOptions = function(options2) {
          extend4(this.prototype.options, options2);
          return this;
        };
        Class4.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray(includes) ? includes : [includes];
          for (var i2 = 0; i2 < includes.length; i2++) {
            if (includes[i2] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                this._on(types[i2], fn, context);
              }
            }
            return this;
          },
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                if (removeAll) {
                  this._off(types[i2]);
                } else {
                  this._off(types[i2], fn, context);
                }
              }
            }
            return this;
          },
          _on: function(type, fn, context, _once) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            if (this._listens(type, fn, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i2, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i2 = 0, len = listeners.length; i2 < len; i2++) {
                  listeners[i2].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            var index2 = this._listens(type, fn, context);
            if (index2 !== false) {
              var listener = listeners[index2];
              if (this._firingCount) {
                listener.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index2, 1);
            }
          },
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend4({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
                  var l = listeners[i2];
                  var fn = l.fn;
                  if (l.once) {
                    this.off(type, fn, l.ctx);
                  }
                  fn.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          listens: function(type, fn, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn;
            if (typeof fn !== "function") {
              propagate = !!fn;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, fn, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          _listens: function(type, fn, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
              if (listeners[i2].fn === fn && listeners[i2].ctx === context) {
                return i2;
              }
            }
            return false;
          },
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn, true);
              }
            } else {
              types = splitWords(types);
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                this._on(types[i2], fn, context, true);
              }
            }
            return this;
          },
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend4({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented4 = Class4.extend(Events);
        function Point2(x, y, round) {
          this.x = round ? Math.round(x) : x;
          this.y = round ? Math.round(y) : y;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point2.prototype = {
          clone: function() {
            return new Point2(this.x, this.y);
          },
          add: function(point7) {
            return this.clone()._add(toPoint(point7));
          },
          _add: function(point7) {
            this.x += point7.x;
            this.y += point7.y;
            return this;
          },
          subtract: function(point7) {
            return this.clone()._subtract(toPoint(point7));
          },
          _subtract: function(point7) {
            this.x -= point7.x;
            this.y -= point7.y;
            return this;
          },
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          scaleBy: function(point7) {
            return new Point2(this.x * point7.x, this.y * point7.y);
          },
          unscaleBy: function(point7) {
            return new Point2(this.x / point7.x, this.y / point7.y);
          },
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          distanceTo: function(point7) {
            point7 = toPoint(point7);
            var x = point7.x - this.x, y = point7.y - this.y;
            return Math.sqrt(x * x + y * y);
          },
          equals: function(point7) {
            point7 = toPoint(point7);
            return point7.x === this.x && point7.y === this.y;
          },
          contains: function(point7) {
            point7 = toPoint(point7);
            return Math.abs(point7.x) <= Math.abs(this.x) && Math.abs(point7.y) <= Math.abs(this.y);
          },
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x, y, round) {
          if (x instanceof Point2) {
            return x;
          }
          if (isArray(x)) {
            return new Point2(x[0], x[1]);
          }
          if (x === void 0 || x === null) {
            return x;
          }
          if (typeof x === "object" && "x" in x && "y" in x) {
            return new Point2(x.x, x.y);
          }
          return new Point2(x, y, round);
        }
        function Bounds2(a, b) {
          if (!a) {
            return;
          }
          var points = b ? [a, b] : a;
          for (var i2 = 0, len = points.length; i2 < len; i2++) {
            this.extend(points[i2]);
          }
        }
        Bounds2.prototype = {
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point2 || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          getCenter: function(round) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round
            );
          },
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          getTopLeft: function() {
            return this.min;
          },
          getBottomRight: function() {
            return this.max;
          },
          getSize: function() {
            return this.max.subtract(this.min);
          },
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point2) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds2) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          intersects: function(bounds3) {
            bounds3 = toBounds(bounds3);
            var min = this.min, max = this.max, min2 = bounds3.min, max2 = bounds3.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          overlaps: function(bounds3) {
            bounds3 = toBounds(bounds3);
            var min = this.min, max = this.max, min2 = bounds3.min, max2 = bounds3.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          isValid: function() {
            return !!(this.min && this.max);
          },
          pad: function(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(
              toPoint(min.x - heightBuffer, min.y - widthBuffer),
              toPoint(max.x + heightBuffer, max.y + widthBuffer)
            );
          },
          equals: function(bounds3) {
            if (!bounds3) {
              return false;
            }
            bounds3 = toBounds(bounds3);
            return this.min.equals(bounds3.getTopLeft()) && this.max.equals(bounds3.getBottomRight());
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds2) {
            return a;
          }
          return new Bounds2(a, b);
        }
        function LatLngBounds3(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
            this.extend(latlngs[i2]);
          }
        }
        LatLngBounds3.prototype = {
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng2) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds3) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng2(sw2.lat, sw2.lng);
              this._northEast = new LatLng2(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds3(
              new LatLng2(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng2(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          getCenter: function() {
            return new LatLng2(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          getSouthWest: function() {
            return this._southWest;
          },
          getNorthEast: function() {
            return this._northEast;
          },
          getNorthWest: function() {
            return new LatLng2(this.getNorth(), this.getWest());
          },
          getSouthEast: function() {
            return new LatLng2(this.getSouth(), this.getEast());
          },
          getWest: function() {
            return this._southWest.lng;
          },
          getSouth: function() {
            return this._southWest.lat;
          },
          getEast: function() {
            return this._northEast.lng;
          },
          getNorth: function() {
            return this._northEast.lat;
          },
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng2 || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds3) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          intersects: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds3.getSouthWest(), ne2 = bounds3.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          overlaps: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds3.getSouthWest(), ne2 = bounds3.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          equals: function(bounds3, maxMargin) {
            if (!bounds3) {
              return false;
            }
            bounds3 = toLatLngBounds(bounds3);
            return this._southWest.equals(bounds3.getSouthWest(), maxMargin) && this._northEast.equals(bounds3.getNorthEast(), maxMargin);
          },
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds3) {
            return a;
          }
          return new LatLngBounds3(a, b);
        }
        function LatLng2(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng2.prototype = {
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng2(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c2) {
          if (a instanceof LatLng2) {
            return a;
          }
          if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng2(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng2(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng2(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng2(a, b, c2);
        }
        var CRS2 = {
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale3 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale3);
          },
          pointToLatLng: function(point7, zoom2) {
            var scale3 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point7, scale3);
            return this.projection.unproject(untransformedPoint);
          },
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          unproject: function(point7) {
            return this.projection.unproject(point7);
          },
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          zoom: function(scale3) {
            return Math.log(scale3 / 256) / Math.LN2;
          },
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds2(min, max);
          },
          infinite: false,
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng2(lat, lng, alt);
          },
          wrapLatLngBounds: function(bounds3) {
            var center = bounds3.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds3;
            }
            var sw = bounds3.getSouthWest(), ne = bounds3.getNorthEast(), newSw = new LatLng2(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng2(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds3(newSw, newNe);
          }
        };
        var Earth = extend4({}, CRS2, {
          wrapLng: [-180, 180],
          R: 6371e3,
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c2 = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c2;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d2 = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d2);
            return new Point2(
              this.R * latlng.lng * d2,
              this.R * Math.log((1 + sin) / (1 - sin)) / 2
            );
          },
          unproject: function(point7) {
            var d2 = 180 / Math.PI;
            return new LatLng2(
              (2 * Math.atan(Math.exp(point7.y / this.R)) - Math.PI / 2) * d2,
              point7.x * d2 / this.R
            );
          },
          bounds: function() {
            var d2 = earthRadius * Math.PI;
            return new Bounds2([-d2, -d2], [d2, d2]);
          }()
        };
        function Transformation2(a, b, c2, d2) {
          if (isArray(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c2;
          this._d = d2;
        }
        Transformation2.prototype = {
          transform: function(point7, scale3) {
            return this._transform(point7.clone(), scale3);
          },
          _transform: function(point7, scale3) {
            scale3 = scale3 || 1;
            point7.x = scale3 * (this._a * point7.x + this._b);
            point7.y = scale3 * (this._c * point7.y + this._d);
            return point7;
          },
          untransform: function(point7, scale3) {
            scale3 = scale3 || 1;
            return new Point2(
              (point7.x / scale3 - this._b) / this._a,
              (point7.y / scale3 - this._d) / this._c
            );
          }
        };
        function toTransformation(a, b, c2, d2) {
          return new Transformation2(a, b, c2, d2);
        }
        var EPSG3857 = extend4({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale3 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale3, 0.5, -scale3, 0.5);
          }()
        });
        var EPSG900913 = extend4({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str2 = "", i2, j, len, len2, points, p;
          for (i2 = 0, len = rings.length; i2 < len; i2++) {
            points = rings[i2];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p = points[j];
              str2 += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str2 += closed ? Browser4.svg ? "z" : "x" : "";
          }
          return str2 || "M0 0";
        }
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str2) {
          return navigator.userAgent.toLowerCase().indexOf(str2) >= 0;
        }
        var Browser4 = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser4.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser4.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser4.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser4.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i2 in _pointers) {
            e.touches.push(_pointers[i2]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i2;
          for (i2 in event) {
            prop = event[i2];
            newEvent[i2] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e);
            if (path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now = Date.now();
            if (now - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i2 = 0, len = classes.length; i2 < len; i2++) {
              el.classList.add(classes[i2]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter2 = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter2 = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter2) {
            filter2.Enabled = value !== 100;
            filter2.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i2 = 0; i2 < props.length; i2++) {
            if (props[i2] in style2) {
              return props[i2];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale3) {
          var pos = offset || new Point2(0, 0);
          el.style[TRANSFORM] = (Browser4.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale3 ? " scale(" + scale3 + ")" : "");
        }
        function setPosition(el, point7) {
          el._leaflet_pos = point7;
          if (Browser4.any3d) {
            setTransform(el, point7);
          } else {
            el.style.left = point7.x + "px";
            el.style.top = point7.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point2(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outline;
          element.style.outline = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outline = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil16 = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              addOne(obj, types[i2], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                removeOne(obj, types[i2], fn, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser4.touchNative && Browser4.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser4.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser4.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn, context, id) {
          id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser4.touchNative && Browser4.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser4.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el = ev.target;
          while (el) {
            path.push(el);
            el = el.parentNode;
          }
          return path;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point2(e.clientX, e.clientY);
          }
          var scale3 = getScale(container), offset = scale3.boundingClientRect;
          return new Point2(
            (e.clientX - offset.left) / scale3.x - container.clientLeft,
            (e.clientY - offset.top) / scale3.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser4.linux && Browser4.chrome ? window.devicePixelRatio : Browser4.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser4.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent12 = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented4.extend({
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
          },
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round) {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map5 = Evented4.extend({
          options: {
            crs: EPSG3857,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: true,
            zoomAnimationThreshold: 4,
            fadeAnimation: true,
            markerZoomAnimation: true,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: true
          },
          initialize: function(id, options2) {
            options2 = setOptions(this, options2);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options2.maxBounds) {
              this.setMaxBounds(options2.maxBounds);
            }
            if (options2.zoom !== void 0) {
              this._zoom = this._limitZoom(options2.zoom);
            }
            if (options2.center && options2.zoom !== void 0) {
              this.setView(toLatLng(options2.center), options2.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser4.any3d && !Browser4.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          setView: function(center, zoom2, options2) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options2 = options2 || {};
            this._stop();
            if (this._loaded && !options2.reset && options2 !== true) {
              if (options2.animate !== void 0) {
                options2.zoom = extend4({ animate: options2.animate }, options2.zoom);
                options2.pan = extend4({ animate: options2.animate, duration: options2.duration }, options2.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options2.zoom) : this._tryAnimatedPan(center, options2.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2, options2.pan && options2.pan.noMoveStart);
            return this;
          },
          setZoom: function(zoom2, options2) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options2 });
          },
          zoomIn: function(delta, options2) {
            delta = delta || (Browser4.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options2);
          },
          zoomOut: function(delta, options2) {
            delta = delta || (Browser4.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options2);
          },
          setZoomAround: function(latlng, zoom2, options2) {
            var scale3 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point2 ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale3), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options2 });
          },
          _getBoundsCenterZoom: function(bounds3, options2) {
            options2 = options2 || {};
            bounds3 = bounds3.getBounds ? bounds3.getBounds() : toLatLngBounds(bounds3);
            var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds3, false, paddingTL.add(paddingBR));
            zoom2 = typeof options2.maxZoom === "number" ? Math.min(options2.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds3.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds3.getSouthWest(), zoom2), nePoint = this.project(bounds3.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          fitBounds: function(bounds3, options2) {
            bounds3 = toLatLngBounds(bounds3);
            if (!bounds3.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds3, options2);
            return this.setView(target.center, target.zoom, options2);
          },
          fitWorld: function(options2) {
            return this.fitBounds([[-90, -180], [90, 180]], options2);
          },
          panTo: function(center, options2) {
            return this.setView(center, this._zoom, { pan: options2 });
          },
          panBy: function(offset, options2) {
            offset = toPoint(offset).round();
            options2 = options2 || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options2.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options2.noMoveStart) {
              this.fire("movestart");
            }
            if (options2.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options2.duration || 0.25, options2.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          flyTo: function(targetCenter, targetZoom, options2) {
            options2 = options2 || {};
            if (options2.animate === false || !Browser4.any3d) {
              return this.setView(targetCenter, targetZoom, options2);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i2) {
              var s1 = i2 ? -1 : 1, s2 = i2 ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log = sq < 1e-9 ? -18 : Math.log(sq);
              return log;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options2.duration ? 1e3 * options2.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                  this.getScaleZoom(w0 / w(s), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options2.noMoveStart);
            frame.call(this);
            return this;
          },
          flyToBounds: function(bounds3, options2) {
            var target = this._getBoundsCenterZoom(bounds3, options2);
            return this.flyTo(target.center, target.zoom, options2);
          },
          setMaxBounds: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds3.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds3;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          panInsideBounds: function(bounds3, options2) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds3));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options2);
            }
            this._enforcingBounds = false;
            return this;
          },
          panInside: function(latlng, options2) {
            options2 = options2 || {};
            var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options2);
              this._enforcingBounds = false;
            }
            return this;
          },
          invalidateSize: function(options2) {
            if (!this._loaded) {
              return this;
            }
            options2 = extend4({
              animate: false,
              pan: true
            }, options2 === true ? { animate: true } : options2);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options2.animate && options2.pan) {
              this.panBy(offset);
            } else {
              if (options2.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options2.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          locate: function(options2) {
            options2 = this._locateOptions = extend4({
              timeout: 1e4,
              watch: false
            }, options2);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options2.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options2);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options2);
            }
            return this;
          },
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c2 = error.code, message = error.message || (c2 === 1 ? "permission denied" : c2 === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c2,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng2(lat, lng), bounds3 = latlng.toBounds(pos.coords.accuracy * 2), options2 = this._locateOptions;
            if (options2.setView) {
              var zoom2 = this.getBoundsZoom(bounds3);
              this.setView(latlng, options2.maxZoom ? Math.min(zoom2, options2.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds: bounds3,
              timestamp: pos.timestamp
            };
            for (var i2 in pos.coords) {
              if (typeof pos.coords[i2] === "number") {
                data[i2] = pos.coords[i2];
              }
            }
            this.fire("locationfound", data);
          },
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i2;
            for (i2 in this._layers) {
              this._layers[i2].remove();
            }
            for (i2 in this._panes) {
              remove(this._panes[i2]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          getZoom: function() {
            return this._zoom;
          },
          getBounds: function() {
            var bounds3 = this.getPixelBounds(), sw = this.unproject(bounds3.getBottomLeft()), ne = this.unproject(bounds3.getTopRight());
            return new LatLngBounds3(sw, ne);
          },
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          getBoundsZoom: function(bounds3, inside, padding) {
            bounds3 = toLatLngBounds(bounds3);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds3.getNorthWest(), se = bounds3.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser4.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale3 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale3, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point2(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds2(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          getPanes: function() {
            return this._panes;
          },
          getContainer: function() {
            return this._container;
          },
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          getScaleZoom: function(scale3, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale3 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          unproject: function(point7, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point7), zoom2);
          },
          layerPointToLatLng: function(point7) {
            var projectedPoint = toPoint(point7).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          containerPointToLayerPoint: function(point7) {
            return toPoint(point7).subtract(this._getMapPanePos());
          },
          layerPointToContainerPoint: function(point7) {
            return toPoint(point7).add(this._getMapPanePos());
          },
          containerPointToLatLng: function(point7) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point7));
            return this.layerPointToLatLng(layerPoint);
          },
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser4.any3d;
            addClass(container, "leaflet-container" + (Browser4.touch ? " leaflet-touch" : "") + (Browser4.retina ? " leaflet-retina" : "") + (Browser4.ielt9 ? " leaflet-oldie" : "") + (Browser4.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point2(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          _resetView: function(center, zoom2, noMoveStart) {
            setPosition(this._mapPane, new Point2(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser4.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el && el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend4({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i2 = 0; i2 < canvasTargets.length; i2++) {
                if (canvasTargets[i2].listens(type, true)) {
                  filtered.push(canvasTargets[i2]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i2 = 0; i2 < targets.length; i2++) {
              targets[i2].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i2].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i2 = 0, len = this._handlers.length; i2 < len; i2++) {
              this._handlers[i2].disable();
            }
          },
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point2(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds2, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds2.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds2.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds2.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds2.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          _limitCenter: function(center, zoom2, bounds3) {
            if (!bounds3) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds2(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds3, zoom2);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          _limitOffset: function(offset, bounds3) {
            if (!bounds3) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds2(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds3));
          },
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point2(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser4.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options2) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options2 && options2.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options2);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c2 = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c2, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options2) {
            if (this._animatingZoom) {
              return true;
            }
            options2 = options2 || {};
            if (!this._zoomAnimated || options2.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale3 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale3);
            if (options2.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options2) {
          return new Map5(id, options2);
        }
        var Control9 = Class4.extend({
          options: {
            position: "topright"
          },
          initialize: function(options2) {
            setOptions(this, options2);
          },
          getPosition: function() {
            return this.options.position;
          },
          setPosition: function(position) {
            var map2 = this._map;
            if (map2) {
              map2.removeControl(this);
            }
            this.options.position = position;
            if (map2) {
              map2.addControl(this);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          addTo: function(map2) {
            this.remove();
            this._map = map2;
            var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options2) {
          return new Control9(options2);
        };
        Map5.include({
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i2 in this._controlCorners) {
              remove(this._controlCorners[i2]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control9.extend({
          options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true,
            hideSingleBase: false,
            sortLayers: false,
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options2) {
            setOptions(this, options2);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var i2 in baseLayers) {
              this._addLayer(baseLayers[i2], i2);
            }
            for (i2 in overlays) {
              this._addLayer(overlays[i2], i2, true);
            }
          },
          onAdd: function(map2) {
            this._initLayout();
            this._update();
            this._map = map2;
            map2.on("zoomend", this._checkDisabledLayers, this);
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              this._layers[i2].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map2) {
            Control9.prototype.addTo.call(this, map2);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              this._layers[i2].layer.off("add remove", this._onLayerChange, this);
            }
          },
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, {
              keydown: function(e) {
                if (e.keyCode === 13) {
                  this._expandSafely();
                }
              },
              click: function(e) {
                preventDefault(e);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              if (this._layers[i2] && stamp(this._layers[i2].layer) === id) {
                return this._layers[i2];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i2, obj, baseLayersCount = 0;
            for (i2 = 0; i2 < this._layers.length; i2++) {
              obj = this._layers[i2];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
              input = inputs[i2];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i2 = 0; i2 < removedLayers.length; i2++) {
              if (this._map.hasLayer(removedLayers[i2])) {
                this._map.removeLayer(removedLayers[i2]);
              }
            }
            for (i2 = 0; i2 < addedLayers.length; i2++) {
              if (!this._map.hasLayer(addedLayers[i2])) {
                this._map.addLayer(addedLayers[i2]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
              input = inputs[i2];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            on(section, "click", preventDefault);
            this.expand();
            setTimeout(function() {
              off(section, "click", preventDefault);
            });
          }
        });
        var layers = function(baseLayers, overlays, options2) {
          return new Layers(baseLayers, overlays, options2);
        };
        var Zoom = Control9.extend({
          options: {
            position: "topleft",
            zoomInText: '<span aria-hidden="true">+</span>',
            zoomInTitle: "Zoom in",
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map2) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options2 = this.options;
            this._zoomInButton = this._createButton(
              options2.zoomInText,
              options2.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options2.zoomOutText,
              options2.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map2 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map2._zoom === map2.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map2._zoom === map2.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map5.mergeOptions({
          zoomControl: true
        });
        Map5.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options2) {
          return new Zoom(options2);
        };
        var Scale2 = Control9.extend({
          options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true
          },
          onAdd: function(map2) {
            var className = "leaflet-control-scale", container = create$1("div", className), options2 = this.options;
            this._addScales(options2, className + "-line", container);
            map2.on(options2.updateWhenIdle ? "moveend" : "move", this._update, this);
            map2.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options2, className, container) {
            if (options2.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options2.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map2 = this._map, y = map2.getSize().y / 2;
            var maxMeters = map2.distance(
              map2.containerPointToLatLng([0, y]),
              map2.containerPointToLatLng([this.options.maxWidth, y])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale3, text, ratio) {
            scale3.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale3.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d2 = num / pow10;
            d2 = d2 >= 10 ? 10 : d2 >= 5 ? 5 : d2 >= 3 ? 3 : d2 >= 2 ? 2 : 1;
            return pow10 * d2;
          }
        });
        var scale2 = function(options2) {
          return new Scale2(options2);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control9.extend({
          options: {
            position: "bottomright",
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser4.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options2) {
            setOptions(this, options2);
            this._attributions = {};
          },
          onAdd: function(map2) {
            map2.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i2 in map2._layers) {
              if (map2._layers[i2].getAttribution) {
                this.addAttribution(map2._layers[i2].getAttribution());
              }
            }
            this._update();
            map2.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map2) {
            map2.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i2 in this._attributions) {
              if (this._attributions[i2]) {
                attribs.push(i2);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map5.mergeOptions({
          attributionControl: true
        });
        Map5.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options2) {
          return new Attribution(options2);
        };
        Control9.Layers = Layers;
        Control9.Zoom = Zoom;
        Control9.Scale = Scale2;
        Control9.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale2;
        control.attribution = attribution;
        var Handler = Class4.extend({
          initialize: function(map2) {
            this._map = map2;
          },
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          enabled: function() {
            return !!this._enabled;
          }
        });
        Handler.addTo = function(map2, name) {
          map2.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser4.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented4.extend({
          options: {
            clickTolerance: 3
          },
          initialize: function(element, dragStartTarget, preventOutline2, options2) {
            setOptions(this, options2);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first2 = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point2(first2.clientX, first2.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first2 = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point2(first2.clientX, first2.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            if (this._moved && this._moving) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
            this._moving = false;
            Draggable._dragging = false;
          }
        });
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i2, newPoints = [];
          for (i2 = 0; i2 < len; i2++) {
            if (markers[i2]) {
              newPoints.push(points[i2]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first2, last) {
          var maxSqDist = 0, index2, i2, sqDist;
          for (i2 = first2 + 1; i2 <= last - 1; i2++) {
            sqDist = _sqClosestPointOnSegment(points[i2], points[first2], points[last], true);
            if (sqDist > maxSqDist) {
              index2 = i2;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index2] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first2, index2);
            _simplifyDPStep(points, markers, sqTolerance, index2, last);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i2 = 1, prev = 0, len = points.length; i2 < len; i2++) {
            if (_sqDist(points[i2], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i2]);
              prev = i2;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds3, useLastCode, round) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds3), codeB = _getBitCode(b, bounds3), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds3, round);
            newCode = _getBitCode(p, bounds3);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds3, round) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds3.min, max = bounds3.max, x, y;
          if (code & 8) {
            x = a.x + dx * (max.y - a.y) / dy;
            y = max.y;
          } else if (code & 4) {
            x = a.x + dx * (min.y - a.y) / dy;
            y = min.y;
          } else if (code & 2) {
            x = max.x;
            y = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x = min.x;
            y = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point2(x, y, round);
        }
        function _getBitCode(p, bounds3) {
          var code = 0;
          if (p.x < bounds3.min.x) {
            code |= 1;
          } else if (p.x > bounds3.max.x) {
            code |= 2;
          }
          if (p.y < bounds3.min.y) {
            code |= 4;
          } else if (p.y > bounds3.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
            if (t > 1) {
              x = p2.x;
              y = p2.y;
            } else if (t > 0) {
              x += dx * t;
              y += dy * t;
            }
          }
          dx = p.x - x;
          dy = p.y - y;
          return sqDist ? dx * dx + dy * dy : new Point2(x, y);
        }
        function isFlat(latlngs) {
          return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        function polylineCenter(latlngs, crs) {
          var i2, halfDist, segDist, dist, p1, p2, ratio, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var points = [];
          for (var j in latlngs) {
            points.push(crs.project(toLatLng(latlngs[j])));
          }
          var len = points.length;
          for (i2 = 0, halfDist = 0; i2 < len - 1; i2++) {
            halfDist += points[i2].distanceTo(points[i2 + 1]) / 2;
          }
          if (halfDist === 0) {
            center = points[0];
          } else {
            for (i2 = 0, dist = 0; i2 < len - 1; i2++) {
              p1 = points[i2];
              p2 = points[i2 + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ];
                break;
              }
            }
          }
          return crs.unproject(toPoint(center));
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        function clipPolygon(points, bounds3, round) {
          var clippedPoints, edges = [1, 4, 2, 8], i2, j, k, a, b, len, edge2, p;
          for (i2 = 0, len = points.length; i2 < len; i2++) {
            points[i2]._code = _getBitCode(points[i2], bounds3);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges[k];
            clippedPoints = [];
            for (i2 = 0, len = points.length, j = len - 1; i2 < len; j = i2++) {
              a = points[i2];
              b = points[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds3, round);
                  p._code = _getBitCode(p, bounds3);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds3, round);
                p._code = _getBitCode(p, bounds3);
                clippedPoints.push(p);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        function polygonCenter(latlngs, crs) {
          var i2, j, p1, p2, f, area, x, y, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var points = [];
          for (var k in latlngs) {
            points.push(crs.project(toLatLng(latlngs[k])));
          }
          var len = points.length;
          area = x = y = 0;
          for (i2 = 0, j = len - 1; i2 < len; j = i2++) {
            p1 = points[i2];
            p2 = points[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x += (p1.x + p2.x) * f;
            y += (p1.y + p2.y) * f;
            area += f * 3;
          }
          if (area === 0) {
            center = points[0];
          } else {
            center = [x / area, y / area];
          }
          return crs.unproject(toPoint(center));
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point2(latlng.lng, latlng.lat);
          },
          unproject: function(point7) {
            return new LatLng2(point7.y, point7.x);
          },
          bounds: new Bounds2([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds2([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d2 = Math.PI / 180, r = this.R, y = latlng.lat * d2, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1e-10));
            return new Point2(latlng.lng * d2 * r, y);
          },
          unproject: function(point7) {
            var d2 = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point7.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i2 = 0, dphi = 0.1, con; i2 < 15 && Math.abs(dphi) > 1e-7; i2++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng2(phi * d2, point7.x * d2 / r);
          }
        };
        var index = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend4({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale3 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale3, 0.5, -scale3, 0.5);
          }()
        });
        var EPSG4326 = extend4({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend4({}, CRS2, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale3) {
            return Math.log(scale3) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS2.Earth = Earth;
        CRS2.EPSG3395 = EPSG3395;
        CRS2.EPSG3857 = EPSG3857;
        CRS2.EPSG900913 = EPSG900913;
        CRS2.EPSG4326 = EPSG4326;
        CRS2.Simple = Simple;
        var Layer = Evented4.extend({
          options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: true
          },
          addTo: function(map2) {
            map2.addLayer(this);
            return this;
          },
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map2 = e.target;
            if (!map2.hasLayer(this)) {
              return;
            }
            this._map = map2;
            this._zoomAnimated = map2._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map2.on(events, this);
              this.once("remove", function() {
                map2.off(events, this);
              }, this);
            }
            this.onAdd(map2);
            this.fire("add");
            map2.fire("layeradd", { layer: this });
          }
        });
        Map5.include({
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          eachLayer: function(method, context) {
            for (var i2 in this._layers) {
              method.call(context, this._layers[i2]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
            for (var i2 = 0, len = layers2.length; i2 < len; i2++) {
              this.addLayer(layers2[i2]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i2 in this._zoomBoundLayers) {
              var options2 = this._zoomBoundLayers[i2].options;
              minZoom = options2.minZoom === void 0 ? minZoom : Math.min(minZoom, options2.minZoom);
              maxZoom = options2.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options2.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup3 = Layer.extend({
          initialize: function(layers2, options2) {
            setOptions(this, options2);
            this._layers = {};
            var i2, len;
            if (layers2) {
              for (i2 = 0, len = layers2.length; i2 < len; i2++) {
                this.addLayer(layers2[i2]);
              }
            }
          },
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i2, layer;
            for (i2 in this._layers) {
              layer = this._layers[i2];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map2) {
            this.eachLayer(map2.addLayer, map2);
          },
          onRemove: function(map2) {
            this.eachLayer(map2.removeLayer, map2);
          },
          eachLayer: function(method, context) {
            for (var i2 in this._layers) {
              method.call(context, this._layers[i2]);
            }
            return this;
          },
          getLayer: function(id) {
            return this._layers[id];
          },
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options2) {
          return new LayerGroup3(layers2, options2);
        };
        var FeatureGroup = LayerGroup3.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup3.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup3.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          getBounds: function() {
            var bounds3 = new LatLngBounds3();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds3.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds3;
          }
        });
        var featureGroup = function(layers2, options2) {
          return new FeatureGroup(layers2, options2);
        };
        var Icon = Class4.extend({
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            crossOrigin: false
          },
          initialize: function(options2) {
            setOptions(this, options2);
          },
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options2 = this.options;
            var sizeOption = options2[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options2.shadowAnchor || options2.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options2.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser4.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options2) {
          return new Icon(options2);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str2, re, idx) {
              var match = re.exec(str2);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker3) {
            this._marker = marker3;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker3 = this._marker, map2 = marker3._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker3._icon), bounds3 = map2.getPixelBounds(), origin = map2.getPixelOrigin();
            var panBounds = toBounds(
              bounds3.min._subtract(origin).add(padding),
              bounds3.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds3.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds3.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds3.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds3.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map2.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker3._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker3 = this._marker, shadow = marker3._shadow, iconPos = getPosition(marker3._icon), latlng = marker3._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker3._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker3.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          options: {
            icon: new IconDefault(),
            interactive: true,
            keyboard: true,
            title: "",
            alt: "Marker",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250,
            pane: "markerPane",
            shadowPane: "shadowPane",
            bubblingMouseEvents: false,
            autoPanOnFocus: true,
            draggable: false,
            autoPan: false,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
          },
          initialize: function(latlng, options2) {
            setOptions(this, options2);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map2) {
            this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map2.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map2) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map2.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          getIcon: function() {
            return this.options.icon;
          },
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options2 = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options2.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options2.title) {
                icon2.title = options2.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options2.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options2.keyboard) {
              icon2.tabIndex = "0";
              icon2.setAttribute("role", "button");
            }
            this._icon = icon2;
            if (options2.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon2, "focus", this._panOnFocus, this);
            }
            var newShadow = options2.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options2.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options2.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map2.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker2(latlng, options2) {
          return new Marker(latlng, options2);
        }
        var Path2 = Layer.extend({
          options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            fillRule: "evenodd",
            interactive: true,
            bubblingMouseEvents: true
          },
          beforeAdd: function(map2) {
            this._renderer = map2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path2.extend({
          options: {
            fill: true,
            radius: 10
          },
          initialize: function(latlng, options2) {
            setOptions(this, options2);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          getLatLng: function() {
            return this._latlng;
          },
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options2) {
            var radius = options2 && options2.radius || this._radius;
            Path2.prototype.setStyle.call(this, options2);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds2(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker3(latlng, options2) {
          return new CircleMarker(latlng, options2);
        }
        var Circle = CircleMarker.extend({
          initialize: function(latlng, options2, legacyOptions) {
            if (typeof options2 === "number") {
              options2 = extend4({}, legacyOptions, { radius: options2 });
            }
            setOptions(this, options2);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._mRadius;
          },
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds3(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path2.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
            if (crs.distance === Earth.distance) {
              var d2 = Math.PI / 180, latR = this._mRadius / Earth.R / d2, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map2.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d2) - Math.sin(lat * d2) * Math.sin(lat2 * d2)) / (Math.cos(lat * d2) * Math.cos(lat2 * d2))) / d2;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map2.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map2.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map2.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options2, legacyOptions) {
          return new Circle(latlng, options2, legacyOptions);
        }
        var Polyline = Path2.extend({
          options: {
            smoothFactor: 1,
            noClip: false
          },
          initialize: function(latlngs, options2) {
            setOptions(this, options2);
            this._setLatLngs(latlngs);
          },
          getLatLngs: function() {
            return this._latlngs;
          },
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          isEmpty: function() {
            return !this._latlngs.length;
          },
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i2 = 1, len = points.length; i2 < len; i2++) {
                p1 = points[i2 - 1];
                p2 = points[i2];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          getBounds: function() {
            return this._bounds;
          },
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds3();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
              if (flat) {
                result[i2] = toLatLng(latlngs[i2]);
                this._bounds.extend(result[i2]);
              } else {
                result[i2] = this._convertLatLngs(latlngs[i2]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds2();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point2(w, w);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds2([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng2, len = latlngs.length, i2, ring;
            if (flat) {
              ring = [];
              for (i2 = 0; i2 < len; i2++) {
                ring[i2] = this._map.latLngToLayerPoint(latlngs[i2]);
                projectedBounds.extend(ring[i2]);
              }
              result.push(ring);
            } else {
              for (i2 = 0; i2 < len; i2++) {
                this._projectLatlngs(latlngs[i2], result, projectedBounds);
              }
            }
          },
          _clipPoints: function() {
            var bounds3 = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds3)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i2, j, k, len, len2, segment, points;
            for (i2 = 0, k = 0, len = this._rings.length; i2 < len; i2++) {
              points = this._rings[i2];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds3, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i2 = 0, len = parts.length; i2 < len; i2++) {
              parts[i2] = simplify(parts[i2], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          _containsPoint: function(p, closed) {
            var i2, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
              part = this._parts[i2];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline2(latlngs, options2) {
          return new Polyline(latlngs, options2);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng2 && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds3 = this._renderer._bounds, w = this.options.weight, p = new Point2(w, w);
            bounds3 = new Bounds2(bounds3.min.subtract(p), bounds3.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds3)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i2 = 0, len = this._rings.length, clipped; i2 < len; i2++) {
              clipped = clipPolygon(this._rings[i2], bounds3, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i2, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
              part = this._parts[i2];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon(latlngs, options2) {
          return new Polygon(latlngs, options2);
        }
        var GeoJSON = FeatureGroup.extend({
          initialize: function(geojson, options2) {
            setOptions(this, options2);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          addData: function(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i2, len, feature;
            if (features) {
              for (i2 = 0, len = features.length; i2 < len; i2++) {
                feature = features[i2];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options2 = this.options;
            if (options2.filter && !options2.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options2);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options2.onEachFeature) {
              options2.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend4({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options2) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords2 = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options2 && options2.pointToLayer, _coordsToLatLng = options2 && options2.coordsToLatLng || coordsToLatLng, latlng, latlngs, i2, len;
          if (!coords2 && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords2);
              return _pointToLayer(pointToLayer, geojson, latlng, options2);
            case "MultiPoint":
              for (i2 = 0, len = coords2.length; i2 < len; i2++) {
                latlng = _coordsToLatLng(coords2[i2]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options2));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords2, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options2);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords2, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options2);
            case "GeometryCollection":
              for (i2 = 0, len = geometry.geometries.length; i2 < len; i2++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i2],
                  type: "Feature",
                  properties: geojson.properties
                }, options2);
                if (geoLayer) {
                  layers2.push(geoLayer);
                }
              }
              return new FeatureGroup(layers2);
            case "FeatureCollection":
              for (i2 = 0, len = geometry.features.length; i2 < len; i2++) {
                var featureLayer = geometryToLayer(geometry.features[i2], options2);
                if (featureLayer) {
                  layers2.push(featureLayer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options2) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options2 && options2.markersInheritOptions && options2);
        }
        function coordsToLatLng(coords2) {
          return new LatLng2(coords2[1], coords2[0], coords2[2]);
        }
        function coordsToLatLngs(coords2, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i2 = 0, len = coords2.length, latlng; i2 < len; i2++) {
            latlng = levelsDeep ? coordsToLatLngs(coords2[i2], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords2[i2]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords2 = [];
          for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
            coords2.push(levelsDeep ? latLngsToCoords(latlngs[i2], isFlat(latlngs[i2]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i2], precision));
          }
          if (!levelsDeep && closed) {
            coords2.push(coords2[0].slice());
          }
          return coords2;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend4({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords2 = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords2
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords2 = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords2 = [coords2];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords2
            });
          }
        });
        LayerGroup3.include({
          toMultiPoint: function(precision) {
            var coords2 = [];
            this.eachLayer(function(layer) {
              coords2.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords2
            });
          },
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options2) {
          return new GeoJSON(geojson, options2);
        }
        var geoJson3 = geoJSON;
        var ImageOverlay = Layer.extend({
          options: {
            opacity: 1,
            alt: "",
            interactive: false,
            crossOrigin: false,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
          },
          initialize: function(url, bounds3, options2) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds3);
            setOptions(this, options2);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          setBounds: function(bounds3) {
            this._bounds = toLatLngBounds(bounds3);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          getBounds: function() {
            return this._bounds;
          },
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale3 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale3);
          },
          _reset: function() {
            var image = this._image, bounds3 = new Bounds2(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds3.getSize();
            setPosition(image, bounds3.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds3, options2) {
          return new ImageOverlay(url, bounds3, options2);
        };
        var VideoOverlay = ImageOverlay.extend({
          options: {
            autoplay: true,
            loop: true,
            keepAspectRatio: true,
            muted: false,
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i2 = 0; i2 < this._url.length; i2++) {
              var source = create$1("source");
              source.src = this._url[i2];
              vid.appendChild(source);
            }
          }
        });
        function videoOverlay(video, bounds3, options2) {
          return new VideoOverlay(video, bounds3, options2);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
        });
        function svgOverlay(el, bounds3, options2) {
          return new SVGOverlay(el, bounds3, options2);
        }
        var DivOverlay = Layer.extend({
          options: {
            interactive: false,
            offset: [0, 0],
            className: "",
            pane: void 0,
            content: ""
          },
          initialize: function(options2, source) {
            if (options2 && (options2 instanceof LatLng2 || isArray(options2))) {
              this._latlng = toLatLng(options2);
              setOptions(this, source);
            } else {
              setOptions(this, options2);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this)) {
              map2.addLayer(this);
            }
            return this;
          },
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map2) {
            this._zoomAnimated = map2._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map2._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map2) {
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          getElement: function() {
            return this._container;
          },
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id in layers2) {
                if (layers2[id]._map) {
                  source = layers2[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map5.include({
          _initOverlay: function(OverlayClass, content, latlng, options2) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options2).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options2) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options2);
              overlay._source = this;
            } else {
              overlay = old && !options2 ? old : new OverlayClass(options2, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          options: {
            pane: "popupPane",
            offset: [0, 7],
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: true,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: false,
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            className: ""
          },
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
              map2.removeLayer(map2._popup);
            }
            map2._popup = this;
            return DivOverlay.prototype.openOn.call(this, map2);
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            map2.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point2(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map2.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options2, source) {
          return new Popup(options2, source);
        };
        Map5.mergeOptions({
          closePopupOnClick: true
        });
        Map5.include({
          openPopup: function(popup2, latlng, options2) {
            this._initOverlay(Popup, popup2, latlng, options2).openOn(this);
            return this;
          },
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          bindPopup: function(content, options2) {
            this._popup = this._initOverlay(Popup, this._popup, content, options2);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path2)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip = DivOverlay.extend({
          options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: false,
            sticky: false,
            opacity: 0.9
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            this.setOpacity(this.options.opacity);
            map2.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options2, source) {
          return new Tooltip(options2, source);
        };
        Map5.include({
          openTooltip: function(tooltip2, latlng, options2) {
            this._initOverlay(Tooltip, tooltip2, latlng, options2).openOn(this);
            return this;
          },
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          bindTooltip: function(content, options2) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options2);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el = layer.getElement();
            if (el) {
              on(el, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on(el, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el = layer.getElement();
            if (el) {
              el.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map || this._map.dragging && this._map.dragging.moving()) {
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            iconSize: [12, 12],
            html: false,
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options2 = this.options;
            if (options2.html instanceof Element) {
              empty(div);
              div.appendChild(options2.html);
            } else {
              div.innerHTML = options2.html !== false ? options2.html : "";
            }
            if (options2.bgPos) {
              var bgPos = toPoint(options2.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options2) {
          return new DivIcon(options2);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          options: {
            tileSize: 256,
            opacity: 1,
            updateWhenIdle: Browser4.mobile,
            updateWhenZooming: true,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: void 0,
            maxNativeZoom: void 0,
            minNativeZoom: void 0,
            noWrap: false,
            pane: "tilePane",
            className: "",
            keepBuffer: 2
          },
          initialize: function(options2) {
            setOptions(this, options2);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map2) {
            map2._addZoomLimit(this);
          },
          onRemove: function(map2) {
            this._removeAllTiles();
            remove(this._container);
            map2._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          isLoading: function() {
            return this._loading;
          },
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          createTile: function() {
            return document.createElement("div");
          },
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point2 ? s : new Point2(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i2 = 0, len = layers2.length, zIndex; i2 < len; i2++) {
              zIndex = layers2[i2].style.zIndex;
              if (layers2[i2] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser4.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile2 = this._tiles[key];
              if (!tile2.current || !tile2.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile2.loaded) / 200);
              setOpacity(tile2.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile2.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile2);
                }
                tile2.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom2) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom2], map2 = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map2.getCenter(), map2.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile2;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile2 = this._tiles[key];
              tile2.retain = tile2.current;
            }
            for (key in this._tiles) {
              tile2 = this._tiles[key];
              if (tile2.current && !tile2.active) {
                var coords2 = tile2.coords;
                if (!this._retainParent(coords2.x, coords2.y, coords2.z, coords2.z - 5)) {
                  this._retainChildren(coords2.x, coords2.y, coords2.z, coords2.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x, y, z, minZoom) {
            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point2(+x2, +y2);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile2 = this._tiles[key];
            if (tile2 && tile2.active) {
              tile2.retain = true;
              return true;
            } else if (tile2 && tile2.loaded) {
              tile2.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x2, y2, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x, y, z, maxZoom) {
            for (var i2 = 2 * x; i2 < 2 * x + 2; i2++) {
              for (var j = 2 * y; j < 2 * y + 2; j++) {
                var coords2 = new Point2(i2, j);
                coords2.z = z + 1;
                var key = this._tileCoordsToKey(coords2), tile2 = this._tiles[key];
                if (tile2 && tile2.active) {
                  tile2.retain = true;
                  continue;
                } else if (tile2 && tile2.loaded) {
                  tile2.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i2, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options2 = this.options;
            if (void 0 !== options2.minNativeZoom && zoom2 < options2.minNativeZoom) {
              return options2.minNativeZoom;
            }
            if (void 0 !== options2.maxNativeZoom && options2.maxNativeZoom < zoom2) {
              return options2.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i2 in this._levels) {
              this._setZoomTransform(this._levels[i2], center, zoom2);
            }
          },
          _setZoomTransform: function(level, center, zoom2) {
            var scale3 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale3).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (Browser4.any3d) {
              setTransform(level.el, translate, scale3);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds3 = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds3) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds3);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale3 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale3 * 2);
            return new Bounds2(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          _update: function(center) {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var zoom2 = this._clampZoom(map2.getZoom());
            if (center === void 0) {
              center = map2.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds2(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c2 = this._tiles[key].coords;
              if (c2.z !== this._tileZoom || !noPruneRange.contains(new Point2(c2.x, c2.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i2 = tileRange.min.x; i2 <= tileRange.max.x; i2++) {
                var coords2 = new Point2(i2, j);
                coords2.z = this._tileZoom;
                if (!this._isValidTile(coords2)) {
                  continue;
                }
                var tile2 = this._tiles[this._tileCoordsToKey(coords2)];
                if (tile2) {
                  tile2.current = true;
                } else {
                  queue.push(coords2);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i2 = 0; i2 < queue.length; i2++) {
                this._addTile(queue[i2], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords2) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds3 = this._globalTileRange;
              if (!crs.wrapLng && (coords2.x < bounds3.min.x || coords2.x > bounds3.max.x) || !crs.wrapLat && (coords2.y < bounds3.min.y || coords2.y > bounds3.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords2);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords2) {
            var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords2.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords2.z), se = map2.unproject(sePoint, coords2.z);
            return [nw, se];
          },
          _tileCoordsToBounds: function(coords2) {
            var bp = this._tileCoordsToNwSe(coords2), bounds3 = new LatLngBounds3(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds3 = this._map.wrapLatLngBounds(bounds3);
            }
            return bounds3;
          },
          _tileCoordsToKey: function(coords2) {
            return coords2.x + ":" + coords2.y + ":" + coords2.z;
          },
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords2 = new Point2(+k[0], +k[1]);
            coords2.z = +k[2];
            return coords2;
          },
          _removeTile: function(key) {
            var tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            remove(tile2.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile2.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile2) {
            addClass(tile2, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile2.style.width = tileSize.x + "px";
            tile2.style.height = tileSize.y + "px";
            tile2.onselectstart = falseFn;
            tile2.onmousemove = falseFn;
            if (Browser4.ielt9 && this.options.opacity < 1) {
              setOpacity(tile2, this.options.opacity);
            }
          },
          _addTile: function(coords2, container) {
            var tilePos = this._getTilePos(coords2), key = this._tileCoordsToKey(coords2);
            var tile2 = this.createTile(this._wrapCoords(coords2), bind(this._tileReady, this, coords2));
            this._initTile(tile2);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords2, null, tile2));
            }
            setPosition(tile2, tilePos);
            this._tiles[key] = {
              el: tile2,
              coords: coords2,
              current: true
            };
            container.appendChild(tile2);
            this.fire("tileloadstart", {
              tile: tile2,
              coords: coords2
            });
          },
          _tileReady: function(coords2, err, tile2) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile: tile2,
                coords: coords2
              });
            }
            var key = this._tileCoordsToKey(coords2);
            tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            tile2.loaded = +new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile2.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile2.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile2.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile2.el,
                coords: coords2
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser4.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords2) {
            return coords2.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords2) {
            var newCoords = new Point2(
              this._wrapX ? wrapNum(coords2.x, this._wrapX) : coords2.x,
              this._wrapY ? wrapNum(coords2.y, this._wrapY) : coords2.y
            );
            newCoords.z = coords2.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds3) {
            var tileSize = this.getTileSize();
            return new Bounds2(
              bounds3.min.unscaleBy(tileSize).floor(),
              bounds3.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options2) {
          return new GridLayer(options2);
        }
        var TileLayer2 = GridLayer.extend({
          options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: false,
            zoomReverse: false,
            detectRetina: false,
            crossOrigin: false,
            referrerPolicy: false
          },
          initialize: function(url, options2) {
            this._url = url;
            options2 = setOptions(this, options2);
            if (options2.detectRetina && Browser4.retina && options2.maxZoom > 0) {
              options2.tileSize = Math.floor(options2.tileSize / 2);
              if (!options2.zoomReverse) {
                options2.zoomOffset++;
                options2.maxZoom = Math.max(options2.minZoom, options2.maxZoom - 1);
              } else {
                options2.zoomOffset--;
                options2.minZoom = Math.min(options2.maxZoom, options2.minZoom + 1);
              }
              options2.minZoom = Math.max(0, options2.minZoom);
            } else if (!options2.zoomReverse) {
              options2.maxZoom = Math.max(options2.minZoom, options2.maxZoom);
            } else {
              options2.minZoom = Math.min(options2.maxZoom, options2.minZoom);
            }
            if (typeof options2.subdomains === "string") {
              options2.subdomains = options2.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          createTile: function(coords2, done) {
            var tile2 = document.createElement("img");
            on(tile2, "load", bind(this._tileOnLoad, this, done, tile2));
            on(tile2, "error", bind(this._tileOnError, this, done, tile2));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile2.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile2.referrerPolicy = this.options.referrerPolicy;
            }
            tile2.alt = "";
            tile2.src = this.getTileUrl(coords2);
            return tile2;
          },
          getTileUrl: function(coords2) {
            var data = {
              r: Browser4.retina ? "@2x" : "",
              s: this._getSubdomain(coords2),
              x: coords2.x,
              y: coords2.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords2.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend4(data, this.options));
          },
          _tileOnLoad: function(done, tile2) {
            if (Browser4.ielt9) {
              setTimeout(bind(done, this, null, tile2), 0);
            } else {
              done(null, tile2);
            }
          },
          _tileOnError: function(done, tile2, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile2.getAttribute("src") !== errorUrl) {
              tile2.src = errorUrl;
            }
            done(e, tile2);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          _abortLoading: function() {
            var i2, tile2;
            for (i2 in this._tiles) {
              if (this._tiles[i2].coords.z !== this._tileZoom) {
                tile2 = this._tiles[i2].el;
                tile2.onload = falseFn;
                tile2.onerror = falseFn;
                if (!tile2.complete) {
                  tile2.src = emptyImageUrl;
                  var coords2 = this._tiles[i2].coords;
                  remove(tile2);
                  delete this._tiles[i2];
                  this.fire("tileabort", {
                    tile: tile2,
                    coords: coords2
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            tile2.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords2, err, tile2) {
            if (!this._map || tile2 && tile2.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords2, err, tile2);
          }
        });
        function tileLayer(url, options2) {
          return new TileLayer2(url, options2);
        }
        var TileLayerWMS = TileLayer2.extend({
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false,
            version: "1.1.1"
          },
          options: {
            crs: null,
            uppercase: false
          },
          initialize: function(url, options2) {
            this._url = url;
            var wmsParams = extend4({}, this.defaultWmsParams);
            for (var i2 in options2) {
              if (!(i2 in this.options)) {
                wmsParams[i2] = options2[i2];
              }
            }
            options2 = setOptions(this, options2);
            var realRetina = options2.detectRetina && Browser4.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map2) {
            this._crs = this.options.crs || map2.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer2.prototype.onAdd.call(this, map2);
          },
          getTileUrl: function(coords2) {
            var tileBounds = this._tileCoordsToNwSe(coords2), crs = this._crs, bounds3 = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds3.min, max = bounds3.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords2);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          setParams: function(params, noRedraw) {
            extend4(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options2) {
          return new TileLayerWMS(url, options2);
        }
        TileLayer2.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          options: {
            padding: 0.1
          },
          initialize: function(options2) {
            setOptions(this, options2);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              if (this._zoomAnimated) {
                addClass(this._container, "leaflet-zoom-animated");
              }
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale3 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale3).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
            if (Browser4.any3d) {
              setTransform(this._container, topLeftOffset, scale3);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds2(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas2 = Renderer.extend({
          options: {
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser4.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser4.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i2;
              for (i2 = 0; i2 < parts.length; i2++) {
                dashValue = Number(parts[i2]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds2();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds3 = this._redrawBounds;
            if (bounds3) {
              var size = bounds3.getSize();
              this._ctx.clearRect(bounds3.min.x, bounds3.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds3 = this._redrawBounds;
            this._ctx.save();
            if (bounds3) {
              var size = bounds3.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds3.min.x, bounds3.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds3 || layer._pxBounds && layer._pxBounds.intersects(bounds3)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i2, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i2 = 0; i2 < len; i2++) {
              for (j = 0, len2 = parts[i2].length; j < len2; j++) {
                p = parts[i2][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options2 = layer.options;
            if (options2.fill) {
              ctx.globalAlpha = options2.fillOpacity;
              ctx.fillStyle = options2.fillColor || options2.color;
              ctx.fill(options2.fillRule || "evenodd");
            }
            if (options2.stroke && options2.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options2.opacity;
              ctx.lineWidth = options2.weight;
              ctx.strokeStyle = options2.color;
              ctx.lineCap = options2.lineCap;
              ctx.lineJoin = options2.lineJoin;
              ctx.stroke();
            }
          },
          _onClick: function(e) {
            var point7 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point7)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point7 = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point7);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point7) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point7)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options2) {
          return Browser4.canvas ? new Canvas2(options2) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options2 = layer.options, container = layer._container;
            container.stroked = !!options2.stroke;
            container.filled = !!options2.fill;
            if (options2.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options2.weight + "px";
              stroke.color = options2.color;
              stroke.opacity = options2.opacity;
              if (options2.dashArray) {
                stroke.dashStyle = isArray(options2.dashArray) ? options2.dashArray.join(" ") : options2.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options2.lineCap.replace("butt", "flat");
              stroke.joinstyle = options2.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options2.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options2.fillColor || options2.color;
              fill.opacity = options2.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser4.vml ? vmlCreate : svgCreate;
        var SVG2 = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options2 = layer.options;
            if (!path) {
              return;
            }
            if (options2.stroke) {
              path.setAttribute("stroke", options2.color);
              path.setAttribute("stroke-opacity", options2.opacity);
              path.setAttribute("stroke-width", options2.weight);
              path.setAttribute("stroke-linecap", options2.lineCap);
              path.setAttribute("stroke-linejoin", options2.lineJoin);
              if (options2.dashArray) {
                path.setAttribute("stroke-dasharray", options2.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options2.dashOffset) {
                path.setAttribute("stroke-dashoffset", options2.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options2.fill) {
              path.setAttribute("fill", options2.fillColor || options2.color);
              path.setAttribute("fill-opacity", options2.fillOpacity);
              path.setAttribute("fill-rule", options2.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d2 = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d2);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser4.vml) {
          SVG2.include(vmlMixin);
        }
        function svg(options2) {
          return Browser4.svg || Browser4.vml ? new SVG2(options2) : null;
        }
        Map5.include({
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options2) {
            return this.options.preferCanvas && canvas(options2) || svg(options2);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds2, options2) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds2), options2);
          },
          setBounds: function(latLngBounds2) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds2));
          },
          _boundsToLatLngs: function(latLngBounds2) {
            latLngBounds2 = toLatLngBounds(latLngBounds2);
            return [
              latLngBounds2.getSouthWest(),
              latLngBounds2.getNorthWest(),
              latLngBounds2.getNorthEast(),
              latLngBounds2.getSouthEast()
            ];
          }
        });
        function rectangle2(latLngBounds2, options2) {
          return new Rectangle(latLngBounds2, options2);
        }
        SVG2.create = create;
        SVG2.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map5.mergeOptions({
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map2) {
            this._map = map2;
            this._container = map2._container;
            this._pane = map2._panes.overlayPane;
            this._resetStateTimeout = 0;
            map2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds3 = new Bounds2(this._point, this._startPoint), size = bounds3.getSize();
            setPosition(this._box, bounds3.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds3 = new LatLngBounds3(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds3).fire("boxzoomend", { boxZoomBounds: bounds3 });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map5.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map5.mergeOptions({
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map2.options.doubleClickZoom === "center") {
              map2.setZoom(zoom2);
            } else {
              map2.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map5.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map5.mergeOptions({
          dragging: true,
          inertia: true,
          inertiaDeceleration: 3400,
          inertiaMaxSpeed: Infinity,
          easeLinearity: 0.2,
          worldCopyJump: false,
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map2 = this._map;
              this._draggable = new Draggable(map2._mapPane, map2._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map2.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map2.on("zoomend", this._onZoomEnd, this);
                map2.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map2 = this._map;
            map2._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds3 = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds3.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds3.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map2.fire("movestart").fire("dragstart");
            if (map2.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map2 = this._map, options2 = map2.options, noInertia = !options2.inertia || e.noInertia || this._times.length < 2;
            map2.fire("dragend", e);
            if (noInertia) {
              map2.fire("moveend");
            } else {
              this._prunePositions(+new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options2.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options2.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options2.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map2.fire("moveend");
              } else {
                offset = map2._limitOffset(offset, map2.options.maxBounds);
                requestAnimFrame(function() {
                  map2.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map5.addInitHook("addHandler", "dragging", Drag);
        Map5.mergeOptions({
          keyboard: true,
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map2) {
            this._map = map2;
            this._setPanDelta(map2.options.keyboardPanDelta);
            this._setZoomDelta(map2.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i2, len;
            for (i2 = 0, len = codes.left.length; i2 < len; i2++) {
              keys[codes.left[i2]] = [-1 * panDelta, 0];
            }
            for (i2 = 0, len = codes.right.length; i2 < len; i2++) {
              keys[codes.right[i2]] = [panDelta, 0];
            }
            for (i2 = 0, len = codes.down.length; i2 < len; i2++) {
              keys[codes.down[i2]] = [0, panDelta];
            }
            for (i2 = 0, len = codes.up.length; i2 < len; i2++) {
              keys[codes.up[i2]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i2, len;
            for (i2 = 0, len = codes.zoomIn.length; i2 < len; i2++) {
              keys[codes.zoomIn[i2]] = zoomDelta;
            }
            for (i2 = 0, len = codes.zoomOut.length; i2 < len; i2++) {
              keys[codes.zoomOut[i2]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map2 = this._map, offset;
            if (key in this._panKeys) {
              if (!map2._panAnim || !map2._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map2.options.maxBounds) {
                  offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
                }
                if (map2.options.worldCopyJump) {
                  var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                  map2.panTo(newLatLng);
                } else {
                  map2.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map2.setZoom(map2.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
              map2.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map5.addInitHook("addHandler", "keyboard", Keyboard);
        Map5.mergeOptions({
          scrollWheelZoom: true,
          wheelDebounceTime: 40,
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +new Date();
            }
            var left = Math.max(debounce - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
            map2._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map2.options.scrollWheelZoom === "center") {
              map2.setZoom(zoom2 + delta);
            } else {
              map2.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map5.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map5.mergeOptions({
          tapHold: Browser4.touchNative && Browser4.safari && Browser4.mobile,
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first2 = e.touches[0];
            this._startPos = this._newPos = new Point2(first2.clientX, first2.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first2);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first2 = e.touches[0];
            this._newPos = new Point2(first2.clientX, first2.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map5.addInitHook("addHandler", "tapHold", TapHold);
        Map5.mergeOptions({
          touchZoom: Browser4.touch,
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map2 = this._map;
            if (!e.touches || e.touches.length !== 2 || map2._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map2.getSize()._divideBy(2);
            this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
            if (map2.options.touchZoom !== "center") {
              this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map2.getZoom();
            this._moved = false;
            this._zooming = true;
            map2._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e.touches[0]), p2 = map2.mouseEventToContainerPoint(e.touches[1]), scale3 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map2.getScaleZoom(scale3, this._startZoom);
            if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale3 < 1 || this._zoom > map2.getMaxZoom() && scale3 > 1)) {
              this._zoom = map2._limitZoom(this._zoom);
            }
            if (map2.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale3 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale3 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map2._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map5.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map5.BoxZoom = BoxZoom;
        Map5.DoubleClickZoom = DoubleClickZoom;
        Map5.Drag = Drag;
        Map5.Keyboard = Keyboard;
        Map5.ScrollWheelZoom = ScrollWheelZoom;
        Map5.TapHold = TapHold;
        Map5.TouchZoom = TouchZoom;
        exports2.Bounds = Bounds2;
        exports2.Browser = Browser4;
        exports2.CRS = CRS2;
        exports2.Canvas = Canvas2;
        exports2.Circle = Circle;
        exports2.CircleMarker = CircleMarker;
        exports2.Class = Class4;
        exports2.Control = Control9;
        exports2.DivIcon = DivIcon;
        exports2.DivOverlay = DivOverlay;
        exports2.DomEvent = DomEvent12;
        exports2.DomUtil = DomUtil16;
        exports2.Draggable = Draggable;
        exports2.Evented = Evented4;
        exports2.FeatureGroup = FeatureGroup;
        exports2.GeoJSON = GeoJSON;
        exports2.GridLayer = GridLayer;
        exports2.Handler = Handler;
        exports2.Icon = Icon;
        exports2.ImageOverlay = ImageOverlay;
        exports2.LatLng = LatLng2;
        exports2.LatLngBounds = LatLngBounds3;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup3;
        exports2.LineUtil = LineUtil;
        exports2.Map = Map5;
        exports2.Marker = Marker;
        exports2.Mixin = Mixin;
        exports2.Path = Path2;
        exports2.Point = Point2;
        exports2.PolyUtil = PolyUtil;
        exports2.Polygon = Polygon;
        exports2.Polyline = Polyline;
        exports2.Popup = Popup;
        exports2.PosAnimation = PosAnimation;
        exports2.Projection = index;
        exports2.Rectangle = Rectangle;
        exports2.Renderer = Renderer;
        exports2.SVG = SVG2;
        exports2.SVGOverlay = SVGOverlay;
        exports2.TileLayer = TileLayer2;
        exports2.Tooltip = Tooltip;
        exports2.Transformation = Transformation2;
        exports2.Util = Util23;
        exports2.VideoOverlay = VideoOverlay;
        exports2.bind = bind;
        exports2.bounds = toBounds;
        exports2.canvas = canvas;
        exports2.circle = circle;
        exports2.circleMarker = circleMarker3;
        exports2.control = control;
        exports2.divIcon = divIcon;
        exports2.extend = extend4;
        exports2.featureGroup = featureGroup;
        exports2.geoJSON = geoJSON;
        exports2.geoJson = geoJson3;
        exports2.gridLayer = gridLayer;
        exports2.icon = icon;
        exports2.imageOverlay = imageOverlay;
        exports2.latLng = toLatLng;
        exports2.latLngBounds = toLatLngBounds;
        exports2.layerGroup = layerGroup;
        exports2.map = createMap;
        exports2.marker = marker2;
        exports2.point = toPoint;
        exports2.polygon = polygon;
        exports2.polyline = polyline2;
        exports2.popup = popup;
        exports2.rectangle = rectangle2;
        exports2.setOptions = setOptions;
        exports2.stamp = stamp;
        exports2.svg = svg;
        exports2.svgOverlay = svgOverlay;
        exports2.tileLayer = tileLayer;
        exports2.tooltip = tooltip;
        exports2.transformation = toTransformation;
        exports2.version = version;
        exports2.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        var arr = [];
        var slice = arr.slice;
        var concat = arr.concat;
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString2 = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var support = {};
        var document2 = window2.document, version = "2.1.4", jQuery5 = function(selector, context) {
          return new jQuery5.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
          return letter.toUpperCase();
        };
        jQuery5.fn = jQuery5.prototype = {
          jquery: version,
          constructor: jQuery5,
          selector: "",
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
          },
          pushStack: function(elems) {
            var ret = jQuery5.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
          },
          each: function(callback, args) {
            return jQuery5.each(this, callback, args);
          },
          map: function(callback) {
            return this.pushStack(jQuery5.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          eq: function(i2) {
            var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor(null);
          },
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery5.extend = jQuery5.fn.extend = function() {
          var options2, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !jQuery5.isFunction(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options2 = arguments[i2]) != null) {
              for (name in options2) {
                src = target[name];
                copy = options2[name];
                if (target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery5.isPlainObject(copy) || (copyIsArray = jQuery5.isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && jQuery5.isArray(src) ? src : [];
                  } else {
                    clone = src && jQuery5.isPlainObject(src) ? src : {};
                  }
                  target[name] = jQuery5.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery5.extend({
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isFunction: function(obj) {
            return jQuery5.type(obj) === "function";
          },
          isArray: Array.isArray,
          isWindow: function(obj) {
            return obj != null && obj === obj.window;
          },
          isNumeric: function(obj) {
            return !jQuery5.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
          },
          isPlainObject: function(obj) {
            if (jQuery5.type(obj) !== "object" || obj.nodeType || jQuery5.isWindow(obj)) {
              return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
              return false;
            }
            return true;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          type: function(obj) {
            if (obj == null) {
              return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
          },
          globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery5.trim(code);
            if (code) {
              if (code.indexOf("use strict") === 1) {
                script = document2.createElement("script");
                script.text = code;
                document2.head.appendChild(script).parentNode.removeChild(script);
              } else {
                indirect(code);
              }
            }
          },
          camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
          },
          nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
          },
          each: function(obj, callback, args) {
            var value, i2 = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
              if (isArray) {
                for (; i2 < length; i2++) {
                  value = callback.apply(obj[i2], args);
                  if (value === false) {
                    break;
                  }
                }
              } else {
                for (i2 in obj) {
                  value = callback.apply(obj[i2], args);
                  if (value === false) {
                    break;
                  }
                }
              }
            } else {
              if (isArray) {
                for (; i2 < length; i2++) {
                  value = callback.call(obj[i2], i2, obj[i2]);
                  if (value === false) {
                    break;
                  }
                }
              } else {
                for (i2 in obj) {
                  value = callback.call(obj[i2], i2, obj[i2]);
                  if (value === false) {
                    break;
                  }
                }
              }
            }
            return obj;
          },
          trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
          },
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArraylike(Object(arr2))) {
                jQuery5.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
          },
          merge: function(first2, second) {
            var len = +second.length, j = 0, i2 = first2.length;
            for (; j < len; j++) {
              first2[i2++] = second[j];
            }
            first2.length = i2;
            return first2;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i2]);
              }
            }
            return matches;
          },
          map: function(elems, callback, arg) {
            var value, i2 = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return concat.apply([], ret);
          },
          guid: 1,
          proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
              tmp = fn[context];
              context = fn;
              fn = tmp;
            }
            if (!jQuery5.isFunction(fn)) {
              return void 0;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
              return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery5.guid++;
            return proxy;
          },
          now: Date.now,
          support
        });
        jQuery5.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i2, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        });
        function isArraylike(obj) {
          var length = "length" in obj && obj.length, type = jQuery5.type(obj);
          if (type === "function" || jQuery5.isWindow(obj)) {
            return false;
          }
          if (obj.nodeType === 1 && length) {
            return true;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = function(window3) {
          var i2, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem2, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
              hasDuplicate = true;
            }
            return 0;
          }, MAX_NEGATIVE = 1 << 31, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, push_native = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
            var i3 = 0, len = list.length;
            for (; i3 < len; i3++) {
              if (list[i3] === elem) {
                return i3;
              }
            }
            return -1;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + characterEncoding + ")"),
            "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
            "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          };
          try {
            push2.apply(
              arr2 = slice2.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr2[preferredDoc.childNodes.length].nodeType;
          } catch (e) {
            push2 = {
              apply: arr2.length ? function(target, els) {
                push_native.apply(target, slice2.call(els));
              } : function(target, els) {
                var j = target.length, i3 = 0;
                while (target[j++] = els[i3++]) {
                }
                target.length = j - 1;
              }
            };
          }
          function Sizzle2(selector, context, results, seed) {
            var match, elem, m, nodeType, i3, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document3) {
              setDocument(context);
            }
            context = context || document3;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed && documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    elem = context.getElementById(m);
                    if (elem && elem.parentNode) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                nid = old = expando;
                newContext = context;
                newSelector = nodeType !== 1 && selector;
                if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                  groups = tokenize(selector);
                  if (old = context.getAttribute("id")) {
                    nid = old.replace(rescape, "\\$&");
                  } else {
                    context.setAttribute("id", nid);
                  }
                  nid = "[id='" + nid + "'] ";
                  i3 = groups.length;
                  while (i3--) {
                    groups[i3] = nid + toSelector(groups[i3]);
                  }
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  newSelector = groups.join(",");
                }
                if (newSelector) {
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                  } finally {
                    if (!old) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrim2, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache[keys.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn) {
            fn[expando] = true;
            return fn;
          }
          function assert(fn) {
            var div = document3.createElement("div");
            try {
              return !!fn(div);
            } catch (e) {
              return false;
            } finally {
              if (div.parentNode) {
                div.parentNode.removeChild(div);
              }
              div = null;
            }
          }
          function addHandle(attrs, handler) {
            var arr3 = attrs.split("|"), i3 = attrs.length;
            while (i3--) {
              Expr.attrHandle[arr3[i3]] = handler;
            }
          }
          function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
              return diff;
            }
            if (cur) {
              while (cur = cur.nextSibling) {
                if (cur === b) {
                  return -1;
                }
              }
            }
            return a ? 1 : -1;
          }
          function createInputPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return (name === "input" || name === "button") && elem.type === type;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j, matchIndexes = fn([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j = matchIndexes[i3]]) {
                    seed[j] = !(matches2[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          support2 = Sizzle2.support = {};
          isXML = Sizzle2.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
          };
          setDocument = Sizzle2.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            docElem2 = doc.documentElement;
            parent = doc.defaultView;
            if (parent && parent !== parent.top) {
              if (parent.addEventListener) {
                parent.addEventListener("unload", unloadHandler, false);
              } else if (parent.attachEvent) {
                parent.attachEvent("onunload", unloadHandler);
              }
            }
            documentIsHTML = !isXML(doc);
            support2.attributes = assert(function(div) {
              div.className = "i";
              return !div.getAttribute("className");
            });
            support2.getElementsByTagName = assert(function(div) {
              div.appendChild(doc.createComment(""));
              return !div.getElementsByTagName("*").length;
            });
            support2.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            support2.getById = assert(function(div) {
              docElem2.appendChild(div).id = expando;
              return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support2.getById) {
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var m = context.getElementById(id);
                  return m && m.parentNode ? [m] : [];
                }
              };
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
            } else {
              delete Expr.find["ID"];
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
            }
            Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else if (support2.qsa) {
                return context.querySelectorAll(tag);
              }
            } : function(tag, context) {
              var elem, tmp = [], i3 = 0, results = context.getElementsByTagName(tag);
              if (tag === "*") {
                while (elem = results[i3++]) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }
                return tmp;
              }
              return results;
            };
            Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
              if (documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support2.qsa = rnative.test(doc.querySelectorAll)) {
              assert(function(div) {
                docElem2.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\f]' msallowcapture=''><option selected=''></option></select>";
                if (div.querySelectorAll("[msallowcapture^='']").length) {
                  rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
                }
                if (!div.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                }
                if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                if (!div.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                if (!div.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
              });
              assert(function(div) {
                var input = doc.createElement("input");
                input.setAttribute("type", "hidden");
                div.appendChild(input).setAttribute("name", "D");
                if (div.querySelectorAll("[name=d]").length) {
                  rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                }
                if (!div.querySelectorAll(":enabled").length) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                div.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
              });
            }
            if (support2.matchesSelector = rnative.test(matches = docElem2.matches || docElem2.webkitMatchesSelector || docElem2.mozMatchesSelector || docElem2.oMatchesSelector || docElem2.msMatchesSelector)) {
              assert(function(div) {
                support2.disconnectedMatch = matches.call(div, "div");
                matches.call(div, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
              });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem2.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem2.contains) ? function(a, b) {
              var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
              return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
              if (b) {
                while (b = b.parentNode) {
                  if (b === a) {
                    return true;
                  }
                }
              }
              return false;
            };
            sortOrder = hasCompare ? function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
              if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
                if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                  return -1;
                }
                if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                  return 1;
                }
                return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              }
              return compare & 4 ? -1 : 1;
            } : function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var cur, i3 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
              if (!aup || !bup) {
                return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              } else if (aup === bup) {
                return siblingCheck(a, b);
              }
              cur = a;
              while (cur = cur.parentNode) {
                ap.unshift(cur);
              }
              cur = b;
              while (cur = cur.parentNode) {
                bp.unshift(cur);
              }
              while (ap[i3] === bp[i3]) {
                i3++;
              }
              return i3 ? siblingCheck(ap[i3], bp[i3]) : ap[i3] === preferredDoc ? -1 : bp[i3] === preferredDoc ? 1 : 0;
            };
            return doc;
          };
          Sizzle2.matches = function(expr, elements) {
            return Sizzle2(expr, null, null, elements);
          };
          Sizzle2.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document3) {
              setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support2.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {
              }
            }
            return Sizzle2(expr, document3, null, [elem]).length > 0;
          };
          Sizzle2.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document3) {
              setDocument(context);
            }
            return contains(context, elem);
          };
          Sizzle2.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          };
          Sizzle2.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          Sizzle2.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i3 = 0;
            hasDuplicate = !support2.detectDuplicates;
            sortInput = !support2.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j = duplicates.push(i3);
                }
              }
              while (j--) {
                results.splice(duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          getText = Sizzle2.getText = function(elem) {
            var node, ret = "", i3 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i3++]) {
                ret += getText(node);
              }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
              if (typeof elem.textContent === "string") {
                return elem.textContent;
              } else {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  ret += getText(elem);
                }
              }
            } else if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          };
          Expr = Sizzle2.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              "ATTR": function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              "CHILD": function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    Sizzle2.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  Sizzle2.error(match[0]);
                }
                return match;
              },
              "PSEUDO": function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr["CHILD"].test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              "TAG": function(nodeNameSelector) {
                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                };
              },
              "CLASS": function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                });
              },
              "ATTR": function(name, operator, check) {
                return function(elem) {
                  var result = Sizzle2.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                };
              },
              "CHILD": function(type, what, argument, first2, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first2 === 1 && last === 0 ? function(elem) {
                  return !!elem.parentNode;
                } : function(elem, context, xml) {
                  var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                  if (parent) {
                    if (simple) {
                      while (dir) {
                        node = elem;
                        while (node = node[dir]) {
                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start = dir = type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }
                    start = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = cache[0] === dirruns && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                      diff = cache[1];
                    } else {
                      while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                  }
                };
              },
              "PSEUDO": function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf2(seed, matched[i3]);
                      seed[idx] = !(matches2[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              "not": markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches2[i3] = elem);
                    }
                  }
                }) : function(elem, context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              "has": markFunction(function(selector) {
                return function(elem) {
                  return Sizzle2(selector, elem).length > 0;
                };
              }),
              "contains": markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                };
              }),
              "lang": markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  Sizzle2.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              "target": function(elem) {
                var hash = window3.location && window3.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              "root": function(elem) {
                return elem === docElem2;
              },
              "focus": function(elem) {
                return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              "enabled": function(elem) {
                return elem.disabled === false;
              },
              "disabled": function(elem) {
                return elem.disabled === true;
              },
              "checked": function(elem) {
                var nodeName = elem.nodeName.toLowerCase();
                return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
              },
              "selected": function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              "empty": function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              "parent": function(elem) {
                return !Expr.pseudos["empty"](elem);
              },
              "header": function(elem) {
                return rheader.test(elem.nodeName);
              },
              "input": function(elem) {
                return rinputs.test(elem.nodeName);
              },
              "button": function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
              },
              "text": function(elem) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              "first": createPositionalPseudo(function() {
                return [0];
              }),
              "last": createPositionalPseudo(function(matchIndexes, length) {
                return [length - 1];
              }),
              "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              "even": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "odd": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos["nth"] = Expr.pseudos["eq"];
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rcombinators.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: match[0].replace(rtrim2, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
          };
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
              while (elem = elem[dir]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
            } : function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[dir] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
            };
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i3 = matchers.length;
              while (i3--) {
                if (!matchers[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              Sizzle2(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map2, filter2, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map2 != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter2 || filter2(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map2.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
              if (matcher) {
                matcher(matcherIn, matcherOut, context, xml);
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando]) {
                  j = ++i3;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i3 > 1 && elementMatcher(matchers),
                    i3 > 1 && toSelector(
                      tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                    ).replace(rtrim2, "$1"),
                    matcher,
                    i3 < j && matcherFromTokens(tokens.slice(i3, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context !== document3 && context;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j = 0;
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context, xml)) {
                      results.push(elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  Sizzle2.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          compile = Sizzle2.compile = function(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
              cached.selector = selector;
            }
            return cached;
          };
          select = Sizzle2.select = function(selector, context, results, seed) {
            var i3, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support2.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find = Expr.find[type]) {
                  if (seed = find(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          };
          support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          support2.detectDuplicates = !!hasDuplicate;
          setDocument();
          support2.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document3.createElement("div")) & 1;
          });
          if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
          })) {
            addHandle("type|href|height|width", function(elem, name, isXML2) {
              if (!isXML2) {
                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
              }
            });
          }
          if (!support2.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
          })) {
            addHandle("value", function(elem, name, isXML2) {
              if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                return elem.defaultValue;
              }
            });
          }
          if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
          })) {
            addHandle(booleans, function(elem, name, isXML2) {
              var val;
              if (!isXML2) {
                return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
              }
            });
          }
          return Sizzle2;
        }(window2);
        jQuery5.find = Sizzle;
        jQuery5.expr = Sizzle.selectors;
        jQuery5.expr[":"] = jQuery5.expr.pseudos;
        jQuery5.unique = Sizzle.uniqueSort;
        jQuery5.text = Sizzle.getText;
        jQuery5.isXMLDoc = Sizzle.isXML;
        jQuery5.contains = Sizzle.contains;
        var rneedsContext = jQuery5.expr.match.needsContext;
        var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
        var risSimple = /^.[^:#\[\.,]*$/;
        function winnow(elements, qualifier, not) {
          if (jQuery5.isFunction(qualifier)) {
            return jQuery5.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery5.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
              return jQuery5.filter(qualifier, elements, not);
            }
            qualifier = jQuery5.filter(qualifier, elements);
          }
          return jQuery5.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
          });
        }
        jQuery5.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          return elems.length === 1 && elem.nodeType === 1 ? jQuery5.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery5.find.matches(expr, jQuery5.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery5.fn.extend({
          find: function(selector) {
            var i2, len = this.length, ret = [], self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery5(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery5.contains(self2[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            for (i2 = 0; i2 < len; i2++) {
              jQuery5.find(selector, self2[i2], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery5.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery5(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery5.fn.init = function(selector, context) {
          var match, elem;
          if (!selector) {
            return this;
          }
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery5 ? context[0] : context;
                jQuery5.merge(this, jQuery5.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery5.isPlainObject(context)) {
                  for (match in context) {
                    if (jQuery5.isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem && elem.parentNode) {
                  this.length = 1;
                  this[0] = elem;
                }
                this.context = document2;
                this.selector = selector;
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || rootjQuery).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
          } else if (jQuery5.isFunction(selector)) {
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery5);
          }
          if (selector.selector !== void 0) {
            this.selector = selector.selector;
            this.context = selector.context;
          }
          return jQuery5.makeArray(selector, this);
        };
        init.prototype = jQuery5.fn;
        rootjQuery = jQuery5(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery5.extend({
          dir: function(elem, dir, until) {
            var matched = [], truncate = until !== void 0;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
              if (elem.nodeType === 1) {
                if (truncate && jQuery5(elem).is(until)) {
                  break;
                }
                matched.push(elem);
              }
            }
            return matched;
          },
          sibling: function(n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
              if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
              }
            }
            return matched;
          }
        });
        jQuery5.fn.extend({
          has: function(target) {
            var targets = jQuery5(target, this), l = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l; i2++) {
                if (jQuery5.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery5(selectors, context || this.context) : 0;
            for (; i2 < l; i2++) {
              for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery5.find.matchesSelector(cur, selectors))) {
                  matched.push(cur);
                  break;
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery5.unique(matched) : matched);
          },
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery5(elem), this[0]);
            }
            return indexOf.call(
              this,
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery5.unique(
                jQuery5.merge(this.get(), jQuery5(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir) {
          while ((cur = cur[dir]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery5.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return jQuery5.dir(elem, "parentNode");
          },
          parentsUntil: function(elem, i2, until) {
            return jQuery5.dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return jQuery5.dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return jQuery5.dir(elem, "previousSibling");
          },
          nextUntil: function(elem, i2, until) {
            return jQuery5.dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, i2, until) {
            return jQuery5.dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return jQuery5.sibling((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return jQuery5.sibling(elem.firstChild);
          },
          contents: function(elem) {
            return elem.contentDocument || jQuery5.merge([], elem.childNodes);
          }
        }, function(name, fn) {
          jQuery5.fn[name] = function(until, selector) {
            var matched = jQuery5.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery5.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery5.unique(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnotwhite = /\S+/g;
        var optionsCache = {};
        function createOptions(options2) {
          var object = optionsCache[options2] = {};
          jQuery5.each(options2.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery5.Callbacks = function(options2) {
          options2 = typeof options2 === "string" ? optionsCache[options2] || createOptions(options2) : jQuery5.extend({}, options2);
          var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options2.once && [], fire = function(data) {
            memory = options2.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (; list && firingIndex < firingLength; firingIndex++) {
              if (list[firingIndex].apply(data[0], data[1]) === false && options2.stopOnFalse) {
                memory = false;
                break;
              }
            }
            firing = false;
            if (list) {
              if (stack) {
                if (stack.length) {
                  fire(stack.shift());
                }
              } else if (memory) {
                list = [];
              } else {
                self2.disable();
              }
            }
          }, self2 = {
            add: function() {
              if (list) {
                var start = list.length;
                (function add(args) {
                  jQuery5.each(args, function(_, arg) {
                    var type = jQuery5.type(arg);
                    if (type === "function") {
                      if (!options2.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && type !== "string") {
                      add(arg);
                    }
                  });
                })(arguments);
                if (firing) {
                  firingLength = list.length;
                } else if (memory) {
                  firingStart = start;
                  fire(memory);
                }
              }
              return this;
            },
            remove: function() {
              if (list) {
                jQuery5.each(arguments, function(_, arg) {
                  var index;
                  while ((index = jQuery5.inArray(arg, list, index)) > -1) {
                    list.splice(index, 1);
                    if (firing) {
                      if (index <= firingLength) {
                        firingLength--;
                      }
                      if (index <= firingIndex) {
                        firingIndex--;
                      }
                    }
                  }
                });
              }
              return this;
            },
            has: function(fn) {
              return fn ? jQuery5.inArray(fn, list) > -1 : !!(list && list.length);
            },
            empty: function() {
              list = [];
              firingLength = 0;
              return this;
            },
            disable: function() {
              list = stack = memory = void 0;
              return this;
            },
            disabled: function() {
              return !list;
            },
            lock: function() {
              stack = void 0;
              if (!memory) {
                self2.disable();
              }
              return this;
            },
            locked: function() {
              return !stack;
            },
            fireWith: function(context, args) {
              if (list && (!fired || stack)) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                if (firing) {
                  stack.push(args);
                } else {
                  fire(args);
                }
              }
              return this;
            },
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        jQuery5.extend({
          Deferred: function(func) {
            var tuples = [
              ["resolve", "done", jQuery5.Callbacks("once memory"), "resolved"],
              ["reject", "fail", jQuery5.Callbacks("once memory"), "rejected"],
              ["notify", "progress", jQuery5.Callbacks("memory")]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              then: function() {
                var fns = arguments;
                return jQuery5.Deferred(function(newDefer) {
                  jQuery5.each(tuples, function(i2, tuple) {
                    var fn = jQuery5.isFunction(fns[i2]) && fns[i2];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && jQuery5.isFunction(returned.promise)) {
                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                      } else {
                        newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              promise: function(obj) {
                return obj != null ? jQuery5.extend(obj, promise) : promise;
              }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery5.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[3];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(function() {
                  state = stateString;
                }, tuples[i2 ^ 1][2].disable, tuples[2][2].lock);
              }
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          when: function(subordinate) {
            var i2 = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery5.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery5.Deferred(), updateFunc = function(i3, contexts, values) {
              return function(value) {
                contexts[i3] = this;
                values[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (values === progressValues) {
                  deferred.notifyWith(contexts, values);
                } else if (!--remaining) {
                  deferred.resolveWith(contexts, values);
                }
              };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
              progressValues = new Array(length);
              progressContexts = new Array(length);
              resolveContexts = new Array(length);
              for (; i2 < length; i2++) {
                if (resolveValues[i2] && jQuery5.isFunction(resolveValues[i2].promise)) {
                  resolveValues[i2].promise().done(updateFunc(i2, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i2, progressContexts, progressValues));
                } else {
                  --remaining;
                }
              }
            }
            if (!remaining) {
              deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
          }
        });
        var readyList;
        jQuery5.fn.ready = function(fn) {
          jQuery5.ready.promise().done(fn);
          return this;
        };
        jQuery5.extend({
          isReady: false,
          readyWait: 1,
          holdReady: function(hold) {
            if (hold) {
              jQuery5.readyWait++;
            } else {
              jQuery5.ready(true);
            }
          },
          ready: function(wait) {
            if (wait === true ? --jQuery5.readyWait : jQuery5.isReady) {
              return;
            }
            jQuery5.isReady = true;
            if (wait !== true && --jQuery5.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery5]);
            if (jQuery5.fn.triggerHandler) {
              jQuery5(document2).triggerHandler("ready");
              jQuery5(document2).off("ready");
            }
          }
        });
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed, false);
          window2.removeEventListener("load", completed, false);
          jQuery5.ready();
        }
        jQuery5.ready.promise = function(obj) {
          if (!readyList) {
            readyList = jQuery5.Deferred();
            if (document2.readyState === "complete") {
              setTimeout(jQuery5.ready);
            } else {
              document2.addEventListener("DOMContentLoaded", completed, false);
              window2.addEventListener("load", completed, false);
            }
          }
          return readyList.promise(obj);
        };
        jQuery5.ready.promise();
        var access = jQuery5.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (jQuery5.type(key) === "object") {
            chainable = true;
            for (i2 in key) {
              jQuery5.access(elems, fn, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!jQuery5.isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, key2, value2) {
                  return bulk.call(jQuery5(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i2 < len; i2++) {
                fn(elems[i2], key, raw ? value : value.call(elems[i2], i2, fn(elems[i2], key)));
              }
            }
          }
          return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
        };
        jQuery5.acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          Object.defineProperty(this.cache = {}, 0, {
            get: function() {
              return {};
            }
          });
          this.expando = jQuery5.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.accepts = jQuery5.acceptData;
        Data.prototype = {
          key: function(owner) {
            if (!Data.accepts(owner)) {
              return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
              unlock = Data.uid++;
              try {
                descriptor[this.expando] = { value: unlock };
                Object.defineProperties(owner, descriptor);
              } catch (e) {
                descriptor[this.expando] = unlock;
                jQuery5.extend(owner, descriptor);
              }
            }
            if (!this.cache[unlock]) {
              this.cache[unlock] = {};
            }
            return unlock;
          },
          set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
              cache[data] = value;
            } else {
              if (jQuery5.isEmptyObject(cache)) {
                jQuery5.extend(this.cache[unlock], data);
              } else {
                for (prop in data) {
                  cache[prop] = data[prop];
                }
              }
            }
            return cache;
          },
          get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === void 0 ? cache : cache[key];
          },
          access: function(owner, key, value) {
            var stored;
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              stored = this.get(owner, key);
              return stored !== void 0 ? stored : this.get(owner, jQuery5.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === void 0) {
              this.cache[unlock] = {};
            } else {
              if (jQuery5.isArray(key)) {
                name = key.concat(key.map(jQuery5.camelCase));
              } else {
                camel = jQuery5.camelCase(key);
                if (key in cache) {
                  name = [key, camel];
                } else {
                  name = camel;
                  name = name in cache ? [name] : name.match(rnotwhite) || [];
                }
              }
              i2 = name.length;
              while (i2--) {
                delete cache[name[i2]];
              }
            }
          },
          hasData: function(owner) {
            return !jQuery5.isEmptyObject(
              this.cache[owner[this.expando]] || {}
            );
          },
          discard: function(owner) {
            if (owner[this.expando]) {
              delete this.cache[owner[this.expando]];
            }
          }
        };
        var data_priv = new Data();
        var data_user = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery5.parseJSON(data) : data;
              } catch (e) {
              }
              data_user.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery5.extend({
          hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
          },
          data: function(elem, name, data) {
            return data_user.access(elem, name, data);
          },
          removeData: function(elem, name) {
            data_user.remove(elem, name);
          },
          _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            data_priv.remove(elem, name);
          }
        });
        jQuery5.fn.extend({
          data: function(key, value) {
            var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = data_user.get(elem);
                if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name = attrs[i2].name;
                      if (name.indexOf("data-") === 0) {
                        name = jQuery5.camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  data_priv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                data_user.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2, camelKey = jQuery5.camelCase(key);
              if (elem && value2 === void 0) {
                data2 = data_user.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = data_user.get(elem, camelKey);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, camelKey, void 0);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                var data3 = data_user.get(this, camelKey);
                data_user.set(this, camelKey, value2);
                if (key.indexOf("-") !== -1 && data3 !== void 0) {
                  data_user.set(this, key, value2);
                }
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              data_user.remove(this, key);
            });
          }
        });
        jQuery5.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = data_priv.get(elem, type);
              if (data) {
                if (!queue || jQuery5.isArray(data)) {
                  queue = data_priv.access(elem, type, jQuery5.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery5.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery5._queueHooks(elem, type), next = function() {
              jQuery5.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
              empty: jQuery5.Callbacks("once memory").add(function() {
                data_priv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery5.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery5.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery5.queue(this, type, data);
              jQuery5._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery5.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery5.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery5.Deferred(), elements = this, i2 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = data_priv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var isHidden = function(elem, el) {
          elem = el || elem;
          return jQuery5.css(elem, "display") === "none" || !jQuery5.contains(elem.ownerDocument, elem);
        };
        var rcheckableType = /^(?:checkbox|radio)$/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        })();
        var strundefined = "undefined";
        support.focusinBubbles = "onfocusin" in window2;
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        jQuery5.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (!handler.guid) {
              handler.guid = jQuery5.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery5 !== strundefined && jQuery5.event.triggered !== e.type ? jQuery5.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery5.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery5.event.special[type] || {};
              handleObj = jQuery5.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery5.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle, false);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery5.event.global[type] = true;
            }
          },
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery5.event.remove(elem, type + types[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery5.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery5.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery5.isEmptyObject(events)) {
              delete elemData.handle;
              data_priv.remove(elem, "events");
            }
          },
          trigger: function(event, data, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery5.event.triggered)) {
              return;
            }
            if (type.indexOf(".") >= 0) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery5.expando] ? event : new jQuery5.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery5.makeArray(data, [event]);
            special = jQuery5.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery5.isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && jQuery5.acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery5.acceptData(elem)) {
                if (ontype && jQuery5.isFunction(elem[type]) && !jQuery5.isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery5.event.triggered = type;
                  elem[type]();
                  jQuery5.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          dispatch: function(event) {
            event = jQuery5.event.fix(event);
            var i2, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery5.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery5.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery5.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.disabled !== true || event.type !== "click") {
                  matches = [];
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matches[sel] === void 0) {
                      matches[sel] = handleObj.needsContext ? jQuery5(sel, this).index(cur) >= 0 : jQuery5.find(sel, this, null, [cur]).length;
                    }
                    if (matches[sel]) {
                      matches.push(handleObj);
                    }
                  }
                  if (matches.length) {
                    handlerQueue.push({ elem: cur, handlers: matches });
                  }
                }
              }
            }
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
          fixHooks: {},
          keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
              if (event.which == null) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
              }
              return event;
            }
          },
          mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
              var eventDoc, doc, body, button = original.button;
              if (event.pageX == null && original.clientX != null) {
                eventDoc = event.target.ownerDocument || document2;
                doc = eventDoc.documentElement;
                body = eventDoc.body;
                event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
              }
              if (!event.which && button !== void 0) {
                event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
              }
              return event;
            }
          },
          fix: function(event) {
            if (event[jQuery5.expando]) {
              return event;
            }
            var i2, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
              this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery5.Event(originalEvent);
            i2 = copy.length;
            while (i2--) {
              prop = copy[i2];
              event[prop] = originalEvent[prop];
            }
            if (!event.target) {
              event.target = document2;
            }
            if (event.target.nodeType === 3) {
              event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
          },
          special: {
            load: {
              noBubble: true
            },
            focus: {
              trigger: function() {
                if (this !== safeActiveElement() && this.focus) {
                  this.focus();
                  return false;
                }
              },
              delegateType: "focusin"
            },
            blur: {
              trigger: function() {
                if (this === safeActiveElement() && this.blur) {
                  this.blur();
                  return false;
                }
              },
              delegateType: "focusout"
            },
            click: {
              trigger: function() {
                if (this.type === "checkbox" && this.click && jQuery5.nodeName(this, "input")) {
                  this.click();
                  return false;
                }
              },
              _default: function(event) {
                return jQuery5.nodeName(event.target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          },
          simulate: function(type, elem, event, bubble) {
            var e = jQuery5.extend(
              new jQuery5.Event(),
              event,
              {
                type,
                isSimulated: true,
                originalEvent: {}
              }
            );
            if (bubble) {
              jQuery5.event.trigger(e, null, elem);
            } else {
              jQuery5.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
              event.preventDefault();
            }
          }
        };
        jQuery5.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
          }
        };
        jQuery5.Event = function(src, props) {
          if (!(this instanceof jQuery5.Event)) {
            return new jQuery5.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery5.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || jQuery5.now();
          this[jQuery5.expando] = true;
        };
        jQuery5.Event.prototype = {
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery5.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery5.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery5.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        if (!support.focusinBubbles) {
          jQuery5.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event) {
              jQuery5.event.simulate(fix, event.target, jQuery5.event.fix(event), true);
            };
            jQuery5.event.special[fix] = {
              setup: function() {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                if (!attaches) {
                  doc.addEventListener(orig, handler, true);
                }
                data_priv.access(doc, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                if (!attaches) {
                  doc.removeEventListener(orig, handler, true);
                  data_priv.remove(doc, fix);
                } else {
                  data_priv.access(doc, fix, attaches);
                }
              }
            };
          });
        }
        jQuery5.fn.extend({
          on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
              if (typeof selector !== "string") {
                data = data || selector;
                selector = void 0;
              }
              for (type in types) {
                this.on(type, selector, data, types[type], one);
              }
              return this;
            }
            if (data == null && fn == null) {
              fn = selector;
              data = selector = void 0;
            } else if (fn == null) {
              if (typeof selector === "string") {
                fn = data;
                data = void 0;
              } else {
                fn = data;
                data = selector;
                selector = void 0;
              }
            }
            if (fn === false) {
              fn = returnFalse;
            } else if (!fn) {
              return this;
            }
            if (one === 1) {
              origFn = fn;
              fn = function(event) {
                jQuery5().off(event);
                return origFn.apply(this, arguments);
              };
              fn.guid = origFn.guid || (origFn.guid = jQuery5.guid++);
            }
            return this.each(function() {
              jQuery5.event.add(this, types, fn, data, selector);
            });
          },
          one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
          },
          off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery5(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery5.event.remove(this, types, fn, selector);
            });
          },
          trigger: function(type, data) {
            return this.each(function() {
              jQuery5.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery5.event.trigger(type, data, elem, true);
            }
          }
        });
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
          option: [1, "<select multiple='multiple'>", "</select>"],
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        function manipulationTarget(elem, content) {
          return jQuery5.nodeName(elem, "table") && jQuery5.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          var match = rscriptTypeMasked.exec(elem.type);
          if (match) {
            elem.type = match[1];
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l = elems.length;
          for (; i2 < l; i2++) {
            data_priv.set(
              elems[i2],
              "globalEval",
              !refElements || data_priv.get(refElements[i2], "globalEval")
            );
          }
        }
        function cloneCopyEvent(src, dest) {
          var i2, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
              delete pdataCur.handle;
              pdataCur.events = {};
              for (type in events) {
                for (i2 = 0, l = events[type].length; i2 < l; i2++) {
                  jQuery5.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery5.extend({}, udataOld);
            data_user.set(dest, udataCur);
          }
        }
        function getAll(context, tag) {
          var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
          return tag === void 0 || tag && jQuery5.nodeName(context, tag) ? jQuery5.merge([context], ret) : ret;
        }
        function fixInput(src, dest) {
          var nodeName = dest.nodeName.toLowerCase();
          if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        jQuery5.extend({
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery5.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery5.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l = elems.length;
            for (; i2 < l; i2++) {
              elem = elems[i2];
              if (elem || elem === 0) {
                if (jQuery5.type(elem) === "object") {
                  jQuery5.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                  nodes.push(context.createTextNode(elem));
                } else {
                  tmp = tmp || fragment.appendChild(context.createElement("div"));
                  tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                  wrap = wrapMap[tag] || wrapMap._default;
                  tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                  j = wrap[0];
                  while (j--) {
                    tmp = tmp.lastChild;
                  }
                  jQuery5.merge(nodes, tmp.childNodes);
                  tmp = fragment.firstChild;
                  tmp.textContent = "";
                }
              }
            }
            fragment.textContent = "";
            i2 = 0;
            while (elem = nodes[i2++]) {
              if (selection && jQuery5.inArray(elem, selection) !== -1) {
                continue;
              }
              contains = jQuery5.contains(elem.ownerDocument, elem);
              tmp = getAll(fragment.appendChild(elem), "script");
              if (contains) {
                setGlobalEval(tmp);
              }
              if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                  if (rscriptType.test(elem.type || "")) {
                    scripts.push(elem);
                  }
                }
              }
            }
            return fragment;
          },
          cleanData: function(elems) {
            var data, elem, type, key, special = jQuery5.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (jQuery5.acceptData(elem)) {
                key = elem[data_priv.expando];
                if (key && (data = data_priv.cache[key])) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery5.event.remove(elem, type);
                      } else {
                        jQuery5.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  if (data_priv.cache[key]) {
                    delete data_priv.cache[key];
                  }
                }
              }
              delete data_user.cache[elem[data_user.expando]];
            }
          }
        });
        jQuery5.fn.extend({
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery5.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return this.domManip(arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return this.domManip(arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return this.domManip(arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return this.domManip(arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery5.filter(selector, this) : this, i2 = 0;
            for (; (elem = elems[i2]) != null; i2++) {
              if (!keepData && elem.nodeType === 1) {
                jQuery5.cleanData(getAll(elem));
              }
              if (elem.parentNode) {
                if (keepData && jQuery5.contains(elem.ownerDocument, elem)) {
                  setGlobalEval(getAll(elem, "script"));
                }
                elem.parentNode.removeChild(elem);
              }
            }
            return this;
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery5.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery5.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = value2.replace(rxhtmlTag, "<$1></$2>");
                try {
                  for (; i2 < l; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery5.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
              arg = this.parentNode;
              jQuery5.cleanData(getAll(this));
              if (arg) {
                arg.replaceChild(elem, this);
              }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
          },
          detach: function(selector) {
            return this.remove(selector, true);
          },
          domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first2, scripts, hasScripts, node, doc, i2 = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery5.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
              return this.each(function(index) {
                var self2 = set.eq(index);
                if (isFunction) {
                  args[0] = value.call(this, index, self2.html());
                }
                self2.domManip(args, callback);
              });
            }
            if (l) {
              fragment = jQuery5.buildFragment(args, this[0].ownerDocument, false, this);
              first2 = fragment.firstChild;
              if (fragment.childNodes.length === 1) {
                fragment = first2;
              }
              if (first2) {
                scripts = jQuery5.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (; i2 < l; i2++) {
                  node = fragment;
                  if (i2 !== iNoClone) {
                    node = jQuery5.clone(node, true, true);
                    if (hasScripts) {
                      jQuery5.merge(scripts, getAll(node, "script"));
                    }
                  }
                  callback.call(this[i2], node, i2);
                }
                if (hasScripts) {
                  doc = scripts[scripts.length - 1].ownerDocument;
                  jQuery5.map(scripts, restoreScript);
                  for (i2 = 0; i2 < hasScripts; i2++) {
                    node = scripts[i2];
                    if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery5.contains(doc, node)) {
                      if (node.src) {
                        if (jQuery5._evalUrl) {
                          jQuery5._evalUrl(node.src);
                        }
                      } else {
                        jQuery5.globalEval(node.textContent.replace(rcleanScript, ""));
                      }
                    }
                  }
                }
              }
            }
            return this;
          }
        });
        jQuery5.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery5.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery5(selector), last = insert.length - 1, i2 = 0;
            for (; i2 <= last; i2++) {
              elems = i2 === last ? this : this.clone(true);
              jQuery5(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var iframe, elemdisplay = {};
        function actualDisplay(name, doc) {
          var style, elem = jQuery5(doc.createElement(name)).appendTo(doc.body), display = window2.getDefaultComputedStyle && (style = window2.getDefaultComputedStyle(elem[0])) ? style.display : jQuery5.css(elem[0], "display");
          elem.detach();
          return display;
        }
        function defaultDisplay(nodeName) {
          var doc = document2, display = elemdisplay[nodeName];
          if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
              iframe = (iframe || jQuery5("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
              doc = iframe[0].contentDocument;
              doc.write();
              doc.close();
              display = actualDisplay(nodeName, doc);
              iframe.detach();
            }
            elemdisplay[nodeName] = display;
          }
          return display;
        }
        var rmargin = /^margin/;
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var getStyles = function(elem) {
          if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
          }
          return window2.getComputedStyle(elem, null);
        };
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
          }
          if (computed) {
            if (ret === "" && !jQuery5.contains(elem.ownerDocument, elem)) {
              ret = jQuery5.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? ret + "" : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        (function() {
          var pixelPositionVal, boxSizingReliableVal, docElem2 = document2.documentElement, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute";
          container.appendChild(div);
          function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem2.appendChild(container);
            var divStyle = window2.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem2.removeChild(container);
          }
          if (window2.getComputedStyle) {
            jQuery5.extend(support, {
              pixelPosition: function() {
                computePixelPositionAndBoxSizingReliable();
                return pixelPositionVal;
              },
              boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                  computePixelPositionAndBoxSizingReliable();
                }
                return boxSizingReliableVal;
              },
              reliableMarginRight: function() {
                var ret, marginDiv = div.appendChild(document2.createElement("div"));
                marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                docElem2.appendChild(container);
                ret = !parseFloat(window2.getComputedStyle(marginDiv, null).marginRight);
                docElem2.removeChild(container);
                div.removeChild(marginDiv);
                return ret;
              }
            });
          }
        })();
        jQuery5.swap = function(elem, options2, callback, args) {
          var ret, name, old = {};
          for (name in options2) {
            old[name] = elem.style[name];
            elem.style[name] = options2[name];
          }
          ret = callback.apply(elem, args || []);
          for (name in options2) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        }, cssPrefixes = ["Webkit", "O", "Moz", "ms"];
        function vendorPropName(style, name) {
          if (name in style) {
            return name;
          }
          var capName = name[0].toUpperCase() + name.slice(1), origName = name, i2 = cssPrefixes.length;
          while (i2--) {
            name = cssPrefixes[i2] + capName;
            if (name in style) {
              return name;
            }
          }
          return origName;
        }
        function setPositiveNumber(elem, value, subtract) {
          var matches = rnumsplit.exec(value);
          return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
        }
        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
          var i2 = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
          for (; i2 < 4; i2 += 2) {
            if (extra === "margin") {
              val += jQuery5.css(elem, extra + cssExpand[i2], true, styles);
            }
            if (isBorderBox) {
              if (extra === "content") {
                val -= jQuery5.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (extra !== "margin") {
                val -= jQuery5.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              val += jQuery5.css(elem, "padding" + cssExpand[i2], true, styles);
              if (extra !== "padding") {
                val += jQuery5.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          return val;
        }
        function getWidthOrHeight(elem, name, extra) {
          var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery5.css(elem, "boxSizing", false, styles) === "border-box";
          if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
              val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
              return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
          }
          return val + augmentWidthOrHeight(
            elem,
            name,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles
          ) + "px";
        }
        function showHide(elements, show) {
          var display, elem, hidden, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
              if (!values[index] && display === "none") {
                elem.style.display = "";
              }
              if (elem.style.display === "" && isHidden(elem)) {
                values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
              }
            } else {
              hidden = isHidden(elem);
              if (display !== "none" || !hidden) {
                data_priv.set(elem, "olddisplay", hidden ? display : jQuery5.css(elem, "display"));
              }
            }
          }
          for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
              elem.style.display = show ? values[index] || "" : "none";
            }
          }
          return elements;
        }
        jQuery5.extend({
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          cssProps: {
            "float": "cssFloat"
          },
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = jQuery5.camelCase(name), style = elem.style;
            name = jQuery5.cssProps[origName] || (jQuery5.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery5.cssHooks[name] || jQuery5.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rrelNum.exec(value))) {
                value = (ret[1] + 1) * ret[2] + parseFloat(jQuery5.css(elem, name));
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !jQuery5.cssNumber[origName]) {
                value += "px";
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                style[name] = value;
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery5.camelCase(name);
            name = jQuery5.cssProps[origName] || (jQuery5.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery5.cssHooks[name] || jQuery5.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || jQuery5.isNumeric(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery5.each(["height", "width"], function(i2, name) {
          jQuery5.cssHooks[name] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery5.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery5.swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, name, extra);
                }) : getWidthOrHeight(elem, name, extra);
              }
            },
            set: function(elem, value, extra) {
              var styles = extra && getStyles(elem);
              return setPositiveNumber(
                elem,
                value,
                extra ? augmentWidthOrHeight(
                  elem,
                  name,
                  extra,
                  jQuery5.css(elem, "boxSizing", false, styles) === "border-box",
                  styles
                ) : 0
              );
            }
          };
        });
        jQuery5.cssHooks.marginRight = addGetHookIf(
          support.reliableMarginRight,
          function(elem, computed) {
            if (computed) {
              return jQuery5.swap(
                elem,
                { "display": "inline-block" },
                curCSS,
                [elem, "marginRight"]
              );
            }
          }
        );
        jQuery5.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery5.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (!rmargin.test(prefix)) {
            jQuery5.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery5.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map2 = {}, i2 = 0;
              if (jQuery5.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i2 < len; i2++) {
                  map2[name2[i2]] = jQuery5.css(elem, name2[i2], false, styles);
                }
                return map2;
              }
              return value2 !== void 0 ? jQuery5.style(elem, name2, value2) : jQuery5.css(elem, name2);
            }, name, value, arguments.length > 1);
          },
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHidden(this)) {
                jQuery5(this).show();
              } else {
                jQuery5(this).hide();
              }
            });
          }
        });
        function Tween(elem, options2, prop, end, easing) {
          return new Tween.prototype.init(elem, options2, prop, end, easing);
        }
        jQuery5.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options2, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options2;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery5.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery5.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                return tween.elem[tween.prop];
              }
              result = jQuery5.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery5.fx.step[tween.prop]) {
                jQuery5.fx.step[tween.prop](tween);
              } else if (tween.elem.style && (tween.elem.style[jQuery5.cssProps[tween.prop]] != null || jQuery5.cssHooks[tween.prop])) {
                jQuery5.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery5.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          }
        };
        jQuery5.fx = Tween.prototype.init;
        jQuery5.fx.step = {};
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery5.cssNumber[prop] ? "" : "px"), start = (jQuery5.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery5.css(tween.elem, prop)), scale2 = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
              unit = unit || start[3];
              parts = parts || [];
              start = +target || 1;
              do {
                scale2 = scale2 || ".5";
                start = start / scale2;
                jQuery5.style(tween.elem, prop, start + unit);
              } while (scale2 !== (scale2 = tween.cur() / target) && scale2 !== 1 && --maxIterations);
            }
            if (parts) {
              start = tween.start = +start || +target || 0;
              tween.unit = unit;
              tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
          }]
        };
        function createFxNow() {
          setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = jQuery5.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery5._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery5.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            display = jQuery5.css(elem, "display");
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery5.css(elem, "float") === "none") {
              style.display = "inline-block";
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery5.style(elem, prop);
            } else {
              display = void 0;
            }
          }
          if (!jQuery5.isEmptyObject(orig)) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = data_priv.access(elem, "fxshow", {});
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              jQuery5(elem).show();
            } else {
              anim.done(function() {
                jQuery5(elem).hide();
              });
            }
            anim.done(function() {
              var prop2;
              data_priv.remove(elem, "fxshow");
              for (prop2 in orig) {
                jQuery5.style(elem, prop2, orig[prop2]);
              }
            });
            for (prop in orig) {
              tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
              if (!(prop in dataShow)) {
                dataShow[prop] = tween.start;
                if (hidden) {
                  tween.end = tween.start;
                  tween.start = prop === "width" || prop === "height" ? 1 : 0;
                }
              }
            }
          } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = jQuery5.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery5.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery5.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options2) {
          var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery5.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            } else {
              deferred.resolveWith(elem, [animation]);
              return false;
            }
          }, animation = deferred.promise({
            elem,
            props: jQuery5.extend({}, properties),
            opts: jQuery5.extend(true, { specialEasing: {} }, options2),
            originalProperties: properties,
            originalOptions: options2,
            startTime: fxNow || createFxNow(),
            duration: options2.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery5.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              return result;
            }
          }
          jQuery5.map(props, createTween, animation);
          if (jQuery5.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          jQuery5.fx.timer(
            jQuery5.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        }
        jQuery5.Animation = jQuery5.extend(Animation, {
          tweener: function(props, callback) {
            if (jQuery5.isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              tweeners[prop] = tweeners[prop] || [];
              tweeners[prop].unshift(callback);
            }
          },
          prefilter: function(callback, prepend) {
            if (prepend) {
              animationPrefilters.unshift(callback);
            } else {
              animationPrefilters.push(callback);
            }
          }
        });
        jQuery5.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery5.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery5.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery5.isFunction(easing) && easing
          };
          opt.duration = jQuery5.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery5.fx.speeds ? jQuery5.fx.speeds[opt.duration] : jQuery5.fx.speeds._default;
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (jQuery5.isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery5.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery5.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery5.isEmptyObject(prop), optall = jQuery5.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery5.extend({}, prop), optall);
              if (empty || data_priv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue && type !== false) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery5.timers, data = data_priv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery5.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery5.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery5.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery5.each(["toggle", "show", "hide"], function(i2, name) {
          var cssFn = jQuery5.fn[name];
          jQuery5.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery5.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery5.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery5.timers = [];
        jQuery5.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery5.timers;
          fxNow = jQuery5.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery5.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery5.fx.timer = function(timer) {
          jQuery5.timers.push(timer);
          if (timer()) {
            jQuery5.fx.start();
          } else {
            jQuery5.timers.pop();
          }
        };
        jQuery5.fx.interval = 13;
        jQuery5.fx.start = function() {
          if (!timerId) {
            timerId = setInterval(jQuery5.fx.tick, jQuery5.fx.interval);
          }
        };
        jQuery5.fx.stop = function() {
          clearInterval(timerId);
          timerId = null;
        };
        jQuery5.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        };
        jQuery5.fn.delay = function(time, type) {
          time = jQuery5.fx ? jQuery5.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
              clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          select.disabled = true;
          support.optDisabled = !opt.disabled;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var nodeHook, boolHook, attrHandle = jQuery5.expr.attrHandle;
        jQuery5.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery5.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery5.removeAttr(this, name);
            });
          }
        });
        jQuery5.extend({
          attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === strundefined) {
              return jQuery5.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery5.isXMLDoc(elem)) {
              name = name.toLowerCase();
              hooks = jQuery5.attrHooks[name] || (jQuery5.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery5.removeAttr(elem, name);
              } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              } else {
                elem.setAttribute(name, value + "");
                return value;
              }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            } else {
              ret = jQuery5.find.attr(elem, name);
              return ret == null ? void 0 : ret;
            }
          },
          removeAttr: function(elem, value) {
            var name, propName, i2 = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i2++]) {
                propName = jQuery5.propFix[name] || name;
                if (jQuery5.expr.match.bool.test(name)) {
                  elem[propName] = false;
                }
                elem.removeAttribute(name);
              }
            }
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && jQuery5.nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery5.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery5.each(jQuery5.expr.match.bool.source.match(/\w+/g), function(i2, name) {
          var getter = attrHandle[name] || jQuery5.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle;
            if (!isXML) {
              handle = attrHandle[name2];
              attrHandle[name2] = ret;
              ret = getter(elem, name2, isXML) != null ? name2.toLowerCase() : null;
              attrHandle[name2] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i;
        jQuery5.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery5.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery5.propFix[name] || name];
            });
          }
        });
        jQuery5.extend({
          propFix: {
            "for": "htmlFor",
            "class": "className"
          },
          prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            notxml = nType !== 1 || !jQuery5.isXMLDoc(elem);
            if (notxml) {
              name = jQuery5.propFix[name] || name;
              hooks = jQuery5.propHooks[name];
            }
            if (value !== void 0) {
              return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0 ? ret : elem[name] = value;
            } else {
              return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
              }
            }
          }
        });
        if (!support.optSelected) {
          jQuery5.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            }
          };
        }
        jQuery5.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery5.propFix[this.toLowerCase()] = this;
        });
        var rclass = /[\t\r\n\f]/g;
        jQuery5.fn.extend({
          addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i2 = 0, len = this.length;
            if (jQuery5.isFunction(value)) {
              return this.each(function(j2) {
                jQuery5(this).addClass(value.call(this, j2, this.className));
              });
            }
            if (proceed) {
              classes = (value || "").match(rnotwhite) || [];
              for (; i2 < len; i2++) {
                elem = this[i2];
                cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                if (cur) {
                  j = 0;
                  while (clazz = classes[j++]) {
                    if (cur.indexOf(" " + clazz + " ") < 0) {
                      cur += clazz + " ";
                    }
                  }
                  finalValue = jQuery5.trim(cur);
                  if (elem.className !== finalValue) {
                    elem.className = finalValue;
                  }
                }
              }
            }
            return this;
          },
          removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i2 = 0, len = this.length;
            if (jQuery5.isFunction(value)) {
              return this.each(function(j2) {
                jQuery5(this).removeClass(value.call(this, j2, this.className));
              });
            }
            if (proceed) {
              classes = (value || "").match(rnotwhite) || [];
              for (; i2 < len; i2++) {
                elem = this[i2];
                cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                if (cur) {
                  j = 0;
                  while (clazz = classes[j++]) {
                    while (cur.indexOf(" " + clazz + " ") >= 0) {
                      cur = cur.replace(" " + clazz + " ", " ");
                    }
                  }
                  finalValue = value ? jQuery5.trim(cur) : "";
                  if (elem.className !== finalValue) {
                    elem.className = finalValue;
                  }
                }
              }
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery5.isFunction(value)) {
              return this.each(function(i2) {
                jQuery5(this).toggleClass(value.call(this, i2, this.className, stateVal), stateVal);
              });
            }
            return this.each(function() {
              if (type === "string") {
                var className, i2 = 0, self2 = jQuery5(this), classNames = value.match(rnotwhite) || [];
                while (className = classNames[i2++]) {
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (type === strundefined || type === "boolean") {
                if (this.className) {
                  data_priv.set(this, "__className__", this.className);
                }
                this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
              }
            });
          },
          hasClass: function(selector) {
            var className = " " + selector + " ", i2 = 0, l = this.length;
            for (; i2 < l; i2++) {
              if (this[i2].nodeType === 1 && (" " + this[i2].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery5.fn.extend({
          val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery5.valHooks[elem.type] || jQuery5.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
              }
              return;
            }
            isFunction = jQuery5.isFunction(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (isFunction) {
                val = value.call(this, i2, jQuery5(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (jQuery5.isArray(val)) {
                val = jQuery5.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery5.valHooks[this.type] || jQuery5.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery5.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery5.find.attr(elem, "value");
                return val != null ? val : jQuery5.trim(jQuery5.text(elem));
              }
            },
            select: {
              get: function(elem) {
                var value, option, options2 = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options2.length, i2 = index < 0 ? max : one ? index : 0;
                for (; i2 < max; i2++) {
                  option = options2[i2];
                  if ((option.selected || i2 === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery5.nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery5(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options2 = elem.options, values = jQuery5.makeArray(value), i2 = options2.length;
                while (i2--) {
                  option = options2[i2];
                  if (option.selected = jQuery5.inArray(option.value, values) >= 0) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery5.each(["radio", "checkbox"], function() {
          jQuery5.valHooks[this] = {
            set: function(elem, value) {
              if (jQuery5.isArray(value)) {
                return elem.checked = jQuery5.inArray(jQuery5(elem).val(), value) >= 0;
              }
            }
          };
          if (!support.checkOn) {
            jQuery5.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        jQuery5.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i2, name) {
          jQuery5.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
          };
        });
        jQuery5.fn.extend({
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          },
          bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
          },
          unbind: function(types, fn) {
            return this.off(types, null, fn);
          },
          delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
          },
          undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
          }
        });
        var nonce = jQuery5.now();
        var rquery = /\?/;
        jQuery5.parseJSON = function(data) {
          return JSON.parse(data + "");
        };
        jQuery5.parseXML = function(data) {
          var xml, tmp;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
          } catch (e) {
            xml = void 0;
          }
          if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery5.error("Invalid XML: " + data);
          }
          return xml;
        };
        var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window2.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery5.isFunction(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options2, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery5.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options2, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options2.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options2.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery5.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery5.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s["throws"]) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery5.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /xml/,
              html: /html/,
              json: /json/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            converters: {
              "* text": String,
              "text html": true,
              "text json": jQuery5.parseJSON,
              "text xml": jQuery5.parseXML
            },
            flatOptions: {
              url: true,
              context: true
            }
          },
          ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery5.ajaxSettings), settings) : ajaxExtend(jQuery5.ajaxSettings, target);
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          ajax: function(url, options2) {
            if (typeof url === "object") {
              options2 = url;
              url = void 0;
            }
            options2 = options2 || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i2, s = jQuery5.ajaxSetup({}, options2), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery5(callbackContext) : jQuery5.event, deferred = jQuery5.Deferred(), completeDeferred = jQuery5.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
              readyState: 0,
              getResponseHeader: function(key) {
                var match;
                if (state === 2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase()] = match[2];
                    }
                  }
                  match = responseHeaders[key.toLowerCase()];
                }
                return match == null ? null : match;
              },
              getAllResponseHeaders: function() {
                return state === 2 ? responseHeadersString : null;
              },
              setRequestHeader: function(name, value) {
                var lname = name.toLowerCase();
                if (!state) {
                  name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              overrideMimeType: function(type) {
                if (!state) {
                  s.mimeType = type;
                }
                return this;
              },
              statusCode: function(map2) {
                var code;
                if (map2) {
                  if (state < 2) {
                    for (code in map2) {
                      statusCode[code] = [statusCode[code], map2[code]];
                    }
                  } else {
                    jqXHR.always(map2[jqXHR.status]);
                  }
                }
                return this;
              },
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options2.method || options2.type || s.method || s.type;
            s.dataTypes = jQuery5.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
            if (s.crossDomain == null) {
              parts = rurl.exec(s.url.toLowerCase());
              s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery5.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options2, jqXHR);
            if (state === 2) {
              return jqXHR;
            }
            fireGlobals = jQuery5.event && s.global;
            if (fireGlobals && jQuery5.active++ === 0) {
              jQuery5.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
              if (s.data) {
                cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
              }
            }
            if (s.ifModified) {
              if (jQuery5.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery5.lastModified[cacheURL]);
              }
              if (jQuery5.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery5.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options2.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i2 in s.headers) {
              jqXHR.setRequestHeader(i2, s.headers[i2]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            for (i2 in { success: 1, error: 1, complete: 1 }) {
              jqXHR[i2](s[i2]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options2, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                state = 1;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (state < 2) {
                  done(-1, e);
                } else {
                  throw e;
                }
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error, response, modified, statusText = nativeStatusText;
              if (state === 2) {
                return;
              }
              state = 2;
              if (timeoutTimer) {
                clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery5.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery5.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error = response.error;
                  isSuccess = !error;
                }
              } else {
                error = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery5.active) {
                  jQuery5.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery5.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery5.get(url, void 0, callback, "script");
          }
        });
        jQuery5.each(["get", "post"], function(i2, method) {
          jQuery5[method] = function(url, data, callback, type) {
            if (jQuery5.isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery5.ajax({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            });
          };
        });
        jQuery5._evalUrl = function(url) {
          return jQuery5.ajax({
            url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
          });
        };
        jQuery5.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (jQuery5.isFunction(html)) {
              return this.each(function(i2) {
                jQuery5(this).wrapAll(html.call(this, i2));
              });
            }
            if (this[0]) {
              wrap = jQuery5(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (jQuery5.isFunction(html)) {
              return this.each(function(i2) {
                jQuery5(this).wrapInner(html.call(this, i2));
              });
            }
            return this.each(function() {
              var self2 = jQuery5(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var isFunction = jQuery5.isFunction(html);
            return this.each(function(i2) {
              jQuery5(this).wrapAll(isFunction ? html.call(this, i2) : html);
            });
          },
          unwrap: function() {
            return this.parent().each(function() {
              if (!jQuery5.nodeName(this, "body")) {
                jQuery5(this).replaceWith(this.childNodes);
              }
            }).end();
          }
        });
        jQuery5.expr.filters.hidden = function(elem) {
          return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
        };
        jQuery5.expr.filters.visible = function(elem) {
          return !jQuery5.expr.filters.hidden(elem);
        };
        var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add) {
          var name;
          if (jQuery5.isArray(obj)) {
            jQuery5.each(obj, function(i2, v) {
              if (traditional || rbracket.test(prefix)) {
                add(prefix, v);
              } else {
                buildParams(prefix + "[" + (typeof v === "object" ? i2 : "") + "]", v, traditional, add);
              }
            });
          } else if (!traditional && jQuery5.type(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
          } else {
            add(prefix, obj);
          }
        }
        jQuery5.param = function(a, traditional) {
          var prefix, s = [], add = function(key, value) {
            value = jQuery5.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
          };
          if (traditional === void 0) {
            traditional = jQuery5.ajaxSettings && jQuery5.ajaxSettings.traditional;
          }
          if (jQuery5.isArray(a) || a.jquery && !jQuery5.isPlainObject(a)) {
            jQuery5.each(a, function() {
              add(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add);
            }
          }
          return s.join("&").replace(r20, "+");
        };
        jQuery5.fn.extend({
          serialize: function() {
            return jQuery5.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery5.prop(this, "elements");
              return elements ? jQuery5.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery5(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i2, elem) {
              var val = jQuery5(this).val();
              return val == null ? null : jQuery5.isArray(val) ? jQuery5.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              }) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        jQuery5.ajaxSettings.xhr = function() {
          try {
            return new XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
          0: 200,
          1223: 204
        }, xhrSupported = jQuery5.ajaxSettings.xhr();
        if (window2.attachEvent) {
          window2.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) {
              xhrCallbacks[key]();
            }
          });
        }
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery5.ajaxTransport(function(options2) {
          var callback;
          if (support.cors || xhrSupported && !options2.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options2.xhr(), id = ++xhrId;
                xhr.open(options2.type, options2.url, options2.async, options2.username, options2.password);
                if (options2.xhrFields) {
                  for (i2 in options2.xhrFields) {
                    xhr[i2] = options2.xhrFields[i2];
                  }
                }
                if (options2.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options2.mimeType);
                }
                if (!options2.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      delete xhrCallbacks[id];
                      callback = xhr.onload = xhr.onerror = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        complete(
                          xhr.status,
                          xhr.statusText
                        );
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          typeof xhr.responseText === "string" ? {
                            text: xhr.responseText
                          } : void 0,
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                xhr.onerror = callback("error");
                callback = xhrCallbacks[id] = callback("abort");
                try {
                  xhr.send(options2.hasContent && options2.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery5.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /(?:java|ecma)script/
          },
          converters: {
            "text script": function(text) {
              jQuery5.globalEval(text);
              return text;
            }
          }
        });
        jQuery5.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery5.ajaxTransport("script", function(s) {
          if (s.crossDomain) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery5("<script>").prop({
                  async: true,
                  charset: s.scriptCharset,
                  src: s.url
                }).on(
                  "load error",
                  callback = function(evt) {
                    script.remove();
                    callback = null;
                    if (evt) {
                      complete(evt.type === "error" ? 404 : 200, evt.type);
                    }
                  }
                );
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery5.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery5.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery5.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery5.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery5.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              window2[callbackName] = overwritten;
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && jQuery5.isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        jQuery5.parseHTML = function(data, context, keepScripts) {
          if (!data || typeof data !== "string") {
            return null;
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          context = context || document2;
          var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = jQuery5.buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery5(scripts).remove();
          }
          return jQuery5.merge([], parsed.childNodes);
        };
        var _load = jQuery5.fn.load;
        jQuery5.fn.load = function(url, params, callback) {
          if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
          }
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off >= 0) {
            selector = jQuery5.trim(url.slice(off));
            url = url.slice(0, off);
          }
          if (jQuery5.isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery5.ajax({
              url,
              type,
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? jQuery5("<div>").append(jQuery5.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function(jqXHR, status) {
              self2.each(callback, response || [jqXHR.responseText, status, jqXHR]);
            });
          }
          return this;
        };
        jQuery5.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i2, type) {
          jQuery5.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery5.expr.filters.animated = function(elem) {
          return jQuery5.grep(jQuery5.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        var docElem = window2.document.documentElement;
        function getWindow(elem) {
          return jQuery5.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
        }
        jQuery5.offset = {
          setOffset: function(elem, options2, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery5.css(elem, "position"), curElem = jQuery5(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery5.css(elem, "top");
            curCSSLeft = jQuery5.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery5.isFunction(options2)) {
              options2 = options2.call(elem, i2, curOffset);
            }
            if (options2.top != null) {
              props.top = options2.top - curOffset.top + curTop;
            }
            if (options2.left != null) {
              props.left = options2.left - curOffset.left + curLeft;
            }
            if ("using" in options2) {
              options2.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery5.fn.extend({
          offset: function(options2) {
            if (arguments.length) {
              return options2 === void 0 ? this : this.each(function(i2) {
                jQuery5.offset.setOffset(this, options2, i2);
              });
            }
            var docElem2, win, elem = this[0], box = { top: 0, left: 0 }, doc = elem && elem.ownerDocument;
            if (!doc) {
              return;
            }
            docElem2 = doc.documentElement;
            if (!jQuery5.contains(docElem2, elem)) {
              return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
              box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
              top: box.top + win.pageYOffset - docElem2.clientTop,
              left: box.left + win.pageXOffset - docElem2.clientLeft
            };
          },
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery5.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offsetParent = this.offsetParent();
              offset = this.offset();
              if (!jQuery5.nodeName(offsetParent[0], "html")) {
                parentOffset = offsetParent.offset();
              }
              parentOffset.top += jQuery5.css(offsetParent[0], "borderTopWidth", true);
              parentOffset.left += jQuery5.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
              top: offset.top - parentOffset.top - jQuery5.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery5.css(elem, "marginLeft", true)
            };
          },
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent || docElem;
              while (offsetParent && (!jQuery5.nodeName(offsetParent, "html") && jQuery5.css(offsetParent, "position") === "static")) {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || docElem;
            });
          }
        });
        jQuery5.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery5.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win = getWindow(elem);
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : window2.pageXOffset,
                  top ? val2 : window2.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length, null);
          };
        });
        jQuery5.each(["top", "left"], function(i2, prop) {
          jQuery5.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery5(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery5.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery5.each({ padding: "inner" + name, content: type, "": "outer" + name }, function(defaultExtra, funcName) {
            jQuery5.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (jQuery5.isWindow(elem)) {
                  return elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? jQuery5.css(elem, type2, extra) : jQuery5.style(elem, type2, value2, extra);
              }, type, chainable ? margin : void 0, chainable, null);
            };
          });
        });
        jQuery5.fn.size = function() {
          return this.length;
        };
        jQuery5.fn.andSelf = jQuery5.fn.addBack;
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery5;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery5.noConflict = function(deep) {
          if (window2.$ === jQuery5) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery5) {
            window2.jQuery = _jQuery;
          }
          return jQuery5;
        };
        if (typeof noGlobal === strundefined) {
          window2.jQuery = window2.$ = jQuery5;
        }
        return jQuery5;
      });
    }
  });

  // node_modules/spectrum-colorpicker/spectrum.js
  var require_spectrum = __commonJS({
    "node_modules/spectrum-colorpicker/spectrum.js"(exports, module) {
      (function(factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(["jquery"], factory);
        } else if (typeof exports == "object" && typeof module == "object") {
          module.exports = factory(require_jquery());
        } else {
          factory(jQuery);
        }
      })(function($2, undefined2) {
        "use strict";
        var defaultOpts = {
          beforeShow: noop,
          move: noop,
          change: noop,
          show: noop,
          hide: noop,
          color: false,
          flat: false,
          showInput: false,
          allowEmpty: false,
          showButtons: true,
          clickoutFiresChange: true,
          showInitial: false,
          showPalette: false,
          showPaletteOnly: false,
          hideAfterPaletteSelect: false,
          togglePaletteOnly: false,
          showSelectionPalette: true,
          localStorageKey: false,
          appendTo: "body",
          maxSelectionSize: 7,
          cancelText: "cancel",
          chooseText: "choose",
          togglePaletteMoreText: "more",
          togglePaletteLessText: "less",
          clearText: "Clear Color Selection",
          noColorSelectedText: "No Color Selected",
          preferredFormat: false,
          className: "",
          containerClassName: "",
          replacerClassName: "",
          showAlpha: false,
          theme: "sp-light",
          palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
          selectionPalette: [],
          disabled: false,
          offset: null
        }, spectrums = [], IE = !!/msie/i.exec(window.navigator.userAgent), rgbaSupport = function() {
          function contains(str2, substr) {
            return !!~("" + str2).indexOf(substr);
          }
          var elem = document.createElement("div");
          var style = elem.style;
          style.cssText = "background-color:rgba(0,0,0,.5)";
          return contains(style.backgroundColor, "rgba") || contains(style.backgroundColor, "hsla");
        }(), replaceInput = [
          "<div class='sp-replacer'>",
          "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
          "<div class='sp-dd'>&#9660;</div>",
          "</div>"
        ].join(""), markup = function() {
          var gradientFix = "";
          if (IE) {
            for (var i2 = 1; i2 <= 6; i2++) {
              gradientFix += "<div class='sp-" + i2 + "'></div>";
            }
          }
          return [
            "<div class='sp-container sp-hidden'>",
            "<div class='sp-palette-container'>",
            "<div class='sp-palette sp-thumb sp-cf'></div>",
            "<div class='sp-palette-button-container sp-cf'>",
            "<button type='button' class='sp-palette-toggle'></button>",
            "</div>",
            "</div>",
            "<div class='sp-picker-container'>",
            "<div class='sp-top sp-cf'>",
            "<div class='sp-fill'></div>",
            "<div class='sp-top-inner'>",
            "<div class='sp-color'>",
            "<div class='sp-sat'>",
            "<div class='sp-val'>",
            "<div class='sp-dragger'></div>",
            "</div>",
            "</div>",
            "</div>",
            "<div class='sp-clear sp-clear-display'>",
            "</div>",
            "<div class='sp-hue'>",
            "<div class='sp-slider'></div>",
            gradientFix,
            "</div>",
            "</div>",
            "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
            "</div>",
            "<div class='sp-input-container sp-cf'>",
            "<input class='sp-input' type='text' spellcheck='false'  />",
            "</div>",
            "<div class='sp-initial sp-thumb sp-cf'></div>",
            "<div class='sp-button-container sp-cf'>",
            "<a class='sp-cancel' href='#'></a>",
            "<button type='button' class='sp-choose'></button>",
            "</div>",
            "</div>",
            "</div>"
          ].join("");
        }();
        function paletteTemplate(p, color, className, opts) {
          var html = [];
          for (var i2 = 0; i2 < p.length; i2++) {
            var current = p[i2];
            if (current) {
              var tiny = tinycolor(current);
              var c2 = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
              c2 += tinycolor.equals(color, current) ? " sp-thumb-active" : "";
              var formattedString = tiny.toString(opts.preferredFormat || "rgb");
              var swatchStyle = rgbaSupport ? "background-color:" + tiny.toRgbString() : "filter:" + tiny.toFilter();
              html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c2 + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';"></span></span>');
            } else {
              var cls = "sp-clear-display";
              html.push(
                $2("<div />").append(
                  $2('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>').attr("title", opts.noColorSelectedText)
                ).html()
              );
            }
          }
          return "<div class='sp-cf " + className + "'>" + html.join("") + "</div>";
        }
        function hideAll() {
          for (var i2 = 0; i2 < spectrums.length; i2++) {
            if (spectrums[i2]) {
              spectrums[i2].hide();
            }
          }
        }
        function instanceOptions(o, callbackContext) {
          var opts = $2.extend({}, defaultOpts, o);
          opts.callbacks = {
            "move": bind(opts.move, callbackContext),
            "change": bind(opts.change, callbackContext),
            "show": bind(opts.show, callbackContext),
            "hide": bind(opts.hide, callbackContext),
            "beforeShow": bind(opts.beforeShow, callbackContext)
          };
          return opts;
        }
        function spectrum(element, o) {
          var opts = instanceOptions(o, element), flat = opts.flat, showSelectionPalette = opts.showSelectionPalette, localStorageKey = opts.localStorageKey, theme = opts.theme, callbacks = opts.callbacks, resize = throttle(reflow, 10), visible = false, isDragging = false, dragWidth = 0, dragHeight = 0, dragHelperHeight = 0, slideHeight = 0, slideWidth = 0, alphaWidth = 0, alphaSlideHelperWidth = 0, slideHelperHeight = 0, currentHue = 0, currentSaturation = 0, currentValue = 0, currentAlpha = 1, palette = [], paletteArray = [], paletteLookup = {}, selectionPalette = opts.selectionPalette.slice(0), maxSelectionSize = opts.maxSelectionSize, draggingClass = "sp-dragging", shiftMovementDirection = null;
          var doc = element.ownerDocument, body = doc.body, boundElement = $2(element), disabled = false, container = $2(markup, doc).addClass(theme), pickerContainer = container.find(".sp-picker-container"), dragger = container.find(".sp-color"), dragHelper = container.find(".sp-dragger"), slider = container.find(".sp-hue"), slideHelper = container.find(".sp-slider"), alphaSliderInner = container.find(".sp-alpha-inner"), alphaSlider = container.find(".sp-alpha"), alphaSlideHelper = container.find(".sp-alpha-handle"), textInput = container.find(".sp-input"), paletteContainer = container.find(".sp-palette"), initialColorContainer = container.find(".sp-initial"), cancelButton = container.find(".sp-cancel"), clearButton = container.find(".sp-clear"), chooseButton = container.find(".sp-choose"), toggleButton = container.find(".sp-palette-toggle"), isInput = boundElement.is("input"), isInputTypeColor = isInput && boundElement.attr("type") === "color" && inputTypeColorSupport(), shouldReplace = isInput && !flat, replacer = shouldReplace ? $2(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $2([]), offsetElement = shouldReplace ? replacer : boundElement, previewElement = replacer.find(".sp-preview-inner"), initialColor = opts.color || isInput && boundElement.val(), colorOnShow = false, currentPreferredFormat = opts.preferredFormat, clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange, isEmpty = !initialColor, allowEmpty = opts.allowEmpty && !isInputTypeColor;
          function applyOptions() {
            if (opts.showPaletteOnly) {
              opts.showPalette = true;
            }
            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            if (opts.palette) {
              palette = opts.palette.slice(0);
              paletteArray = $2.isArray(palette[0]) ? palette : [palette];
              paletteLookup = {};
              for (var i2 = 0; i2 < paletteArray.length; i2++) {
                for (var j = 0; j < paletteArray[i2].length; j++) {
                  var rgb2 = tinycolor(paletteArray[i2][j]).toRgbString();
                  paletteLookup[rgb2] = true;
                }
              }
            }
            container.toggleClass("sp-flat", flat);
            container.toggleClass("sp-input-disabled", !opts.showInput);
            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
            container.toggleClass("sp-clear-enabled", allowEmpty);
            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
            container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
            container.toggleClass("sp-palette-disabled", !opts.showPalette);
            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
            container.toggleClass("sp-initial-disabled", !opts.showInitial);
            container.addClass(opts.className).addClass(opts.containerClassName);
            reflow();
          }
          function initialize() {
            if (IE) {
              container.find("*:not(input)").attr("unselectable", "on");
            }
            applyOptions();
            if (shouldReplace) {
              boundElement.after(replacer).hide();
            }
            if (!allowEmpty) {
              clearButton.hide();
            }
            if (flat) {
              boundElement.after(container).hide();
            } else {
              var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $2(opts.appendTo);
              if (appendTo.length !== 1) {
                appendTo = $2("body");
              }
              appendTo.append(container);
            }
            updateSelectionPaletteFromStorage();
            offsetElement.on("click.spectrum touchstart.spectrum", function(e) {
              if (!disabled) {
                toggle();
              }
              e.stopPropagation();
              if (!$2(e.target).is("input")) {
                e.preventDefault();
              }
            });
            if (boundElement.is(":disabled") || opts.disabled === true) {
              disable();
            }
            container.click(stopPropagation);
            textInput.change(setFromTextInput);
            textInput.on("paste", function() {
              setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function(e) {
              if (e.keyCode == 13) {
                setFromTextInput();
              }
            });
            cancelButton.text(opts.cancelText);
            cancelButton.on("click.spectrum", function(e) {
              e.stopPropagation();
              e.preventDefault();
              revert();
              hide();
            });
            clearButton.attr("title", opts.clearText);
            clearButton.on("click.spectrum", function(e) {
              e.stopPropagation();
              e.preventDefault();
              isEmpty = true;
              move();
              if (flat) {
                updateOriginalInput(true);
              }
            });
            chooseButton.text(opts.chooseText);
            chooseButton.on("click.spectrum", function(e) {
              e.stopPropagation();
              e.preventDefault();
              if (IE && textInput.is(":focus")) {
                textInput.trigger("change");
              }
              if (isValid()) {
                updateOriginalInput(true);
                hide();
              }
            });
            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            toggleButton.on("click.spectrum", function(e) {
              e.stopPropagation();
              e.preventDefault();
              opts.showPaletteOnly = !opts.showPaletteOnly;
              if (!opts.showPaletteOnly && !flat) {
                container.css("left", "-=" + (pickerContainer.outerWidth(true) + 5));
              }
              applyOptions();
            });
            draggable(alphaSlider, function(dragX, dragY, e) {
              currentAlpha = dragX / alphaWidth;
              isEmpty = false;
              if (e.shiftKey) {
                currentAlpha = Math.round(currentAlpha * 10) / 10;
              }
              move();
            }, dragStart, dragStop);
            draggable(slider, function(dragX, dragY) {
              currentHue = parseFloat(dragY / slideHeight);
              isEmpty = false;
              if (!opts.showAlpha) {
                currentAlpha = 1;
              }
              move();
            }, dragStart, dragStop);
            draggable(dragger, function(dragX, dragY, e) {
              if (!e.shiftKey) {
                shiftMovementDirection = null;
              } else if (!shiftMovementDirection) {
                var oldDragX = currentSaturation * dragWidth;
                var oldDragY = dragHeight - currentValue * dragHeight;
                var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                shiftMovementDirection = furtherFromX ? "x" : "y";
              }
              var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
              var setValue = !shiftMovementDirection || shiftMovementDirection === "y";
              if (setSaturation) {
                currentSaturation = parseFloat(dragX / dragWidth);
              }
              if (setValue) {
                currentValue = parseFloat((dragHeight - dragY) / dragHeight);
              }
              isEmpty = false;
              if (!opts.showAlpha) {
                currentAlpha = 1;
              }
              move();
            }, dragStart, dragStop);
            if (!!initialColor) {
              set(initialColor);
              updateUI();
              currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).format;
              addColorToSelectionPalette(initialColor);
            } else {
              updateUI();
            }
            if (flat) {
              show();
            }
            function paletteElementClick(e) {
              if (e.data && e.data.ignore) {
                set($2(e.target).closest(".sp-thumb-el").data("color"));
                move();
              } else {
                set($2(e.target).closest(".sp-thumb-el").data("color"));
                move();
                if (opts.hideAfterPaletteSelect) {
                  updateOriginalInput(true);
                  hide();
                } else {
                  updateOriginalInput();
                }
              }
              return false;
            }
            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
            paletteContainer.on(paletteEvent, ".sp-thumb-el", paletteElementClick);
            initialColorContainer.on(paletteEvent, ".sp-thumb-el:nth-child(1)", { ignore: true }, paletteElementClick);
          }
          function updateSelectionPaletteFromStorage() {
            if (localStorageKey && window.localStorage) {
              try {
                var oldPalette = window.localStorage[localStorageKey].split(",#");
                if (oldPalette.length > 1) {
                  delete window.localStorage[localStorageKey];
                  $2.each(oldPalette, function(i2, c2) {
                    addColorToSelectionPalette(c2);
                  });
                }
              } catch (e) {
              }
              try {
                selectionPalette = window.localStorage[localStorageKey].split(";");
              } catch (e) {
              }
            }
          }
          function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
              var rgb2 = tinycolor(color).toRgbString();
              if (!paletteLookup[rgb2] && $2.inArray(rgb2, selectionPalette) === -1) {
                selectionPalette.push(rgb2);
                while (selectionPalette.length > maxSelectionSize) {
                  selectionPalette.shift();
                }
              }
              if (localStorageKey && window.localStorage) {
                try {
                  window.localStorage[localStorageKey] = selectionPalette.join(";");
                } catch (e) {
                }
              }
            }
          }
          function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
              for (var i2 = 0; i2 < selectionPalette.length; i2++) {
                var rgb2 = tinycolor(selectionPalette[i2]).toRgbString();
                if (!paletteLookup[rgb2]) {
                  unique.push(selectionPalette[i2]);
                }
              }
            }
            return unique.reverse().slice(0, opts.maxSelectionSize);
          }
          function drawPalette() {
            var currentColor = get();
            var html = $2.map(paletteArray, function(palette2, i2) {
              return paletteTemplate(palette2, currentColor, "sp-palette-row sp-palette-row-" + i2, opts);
            });
            updateSelectionPaletteFromStorage();
            if (selectionPalette) {
              html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }
            paletteContainer.html(html.join(""));
          }
          function drawInitial() {
            if (opts.showInitial) {
              var initial = colorOnShow;
              var current = get();
              initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
            }
          }
          function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
              reflow();
            }
            isDragging = true;
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger("dragstart.spectrum", [get()]);
          }
          function dragStop() {
            isDragging = false;
            container.removeClass(draggingClass);
            boundElement.trigger("dragstop.spectrum", [get()]);
          }
          function setFromTextInput() {
            var value = textInput.val();
            if ((value === null || value === "") && allowEmpty) {
              set(null);
              move();
              updateOriginalInput();
            } else {
              var tiny = tinycolor(value);
              if (tiny.isValid()) {
                set(tiny);
                move();
                updateOriginalInput();
              } else {
                textInput.addClass("sp-validation-error");
              }
            }
          }
          function toggle() {
            if (visible) {
              hide();
            } else {
              show();
            }
          }
          function show() {
            var event = $2.Event("beforeShow.spectrum");
            if (visible) {
              reflow();
              return;
            }
            boundElement.trigger(event, [get()]);
            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
              return;
            }
            hideAll();
            visible = true;
            $2(doc).on("keydown.spectrum", onkeydown);
            $2(doc).on("click.spectrum", clickout);
            $2(window).on("resize.spectrum", resize);
            replacer.addClass("sp-active");
            container.removeClass("sp-hidden");
            reflow();
            updateUI();
            colorOnShow = get();
            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger("show.spectrum", [colorOnShow]);
          }
          function onkeydown(e) {
            if (e.keyCode === 27) {
              hide();
            }
          }
          function clickout(e) {
            if (e.button == 2) {
              return;
            }
            if (isDragging) {
              return;
            }
            if (clickoutFiresChange) {
              updateOriginalInput(true);
            } else {
              revert();
            }
            hide();
          }
          function hide() {
            if (!visible || flat) {
              return;
            }
            visible = false;
            $2(doc).off("keydown.spectrum", onkeydown);
            $2(doc).off("click.spectrum", clickout);
            $2(window).off("resize.spectrum", resize);
            replacer.removeClass("sp-active");
            container.addClass("sp-hidden");
            callbacks.hide(get());
            boundElement.trigger("hide.spectrum", [get()]);
          }
          function revert() {
            set(colorOnShow, true);
            updateOriginalInput(true);
          }
          function set(color, ignoreFormatChange) {
            if (tinycolor.equals(color, get())) {
              updateUI();
              return;
            }
            var newColor, newHsv;
            if (!color && allowEmpty) {
              isEmpty = true;
            } else {
              isEmpty = false;
              newColor = tinycolor(color);
              newHsv = newColor.toHsv();
              currentHue = newHsv.h % 360 / 360;
              currentSaturation = newHsv.s;
              currentValue = newHsv.v;
              currentAlpha = newHsv.a;
            }
            updateUI();
            if (newColor && newColor.isValid() && !ignoreFormatChange) {
              currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
            }
          }
          function get(opts2) {
            opts2 = opts2 || {};
            if (allowEmpty && isEmpty) {
              return null;
            }
            return tinycolor.fromRatio({
              h: currentHue,
              s: currentSaturation,
              v: currentValue,
              a: Math.round(currentAlpha * 1e3) / 1e3
            }, { format: opts2.format || currentPreferredFormat });
          }
          function isValid() {
            return !textInput.hasClass("sp-validation-error");
          }
          function move() {
            updateUI();
            callbacks.move(get());
            boundElement.trigger("move.spectrum", [get()]);
          }
          function updateUI() {
            textInput.removeClass("sp-validation-error");
            updateHelperLocations();
            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css("background-color", flatColor.toHexString());
            var format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
              if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                format = "rgb";
              }
            }
            var realColor = get({ format }), displayColor = "";
            previewElement.removeClass("sp-clear-display");
            previewElement.css("background-color", "transparent");
            if (!realColor && allowEmpty) {
              previewElement.addClass("sp-clear-display");
            } else {
              var realHex = realColor.toHexString(), realRgb = realColor.toRgbString();
              if (rgbaSupport || realColor.alpha === 1) {
                previewElement.css("background-color", realRgb);
              } else {
                previewElement.css("background-color", "transparent");
                previewElement.css("filter", realColor.toFilter());
              }
              if (opts.showAlpha) {
                var rgb2 = realColor.toRgb();
                rgb2.a = 0;
                var realAlpha = tinycolor(rgb2).toRgbString();
                var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";
                if (IE) {
                  alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                } else {
                  alphaSliderInner.css("background", "-webkit-" + gradient);
                  alphaSliderInner.css("background", "-moz-" + gradient);
                  alphaSliderInner.css("background", "-ms-" + gradient);
                  alphaSliderInner.css(
                    "background",
                    "linear-gradient(to right, " + realAlpha + ", " + realHex + ")"
                  );
                }
              }
              displayColor = realColor.toString(format);
            }
            if (opts.showInput) {
              textInput.val(displayColor);
            }
            if (opts.showPalette) {
              drawPalette();
            }
            drawInitial();
          }
          function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;
            if (allowEmpty && isEmpty) {
              alphaSlideHelper.hide();
              slideHelper.hide();
              dragHelper.hide();
            } else {
              alphaSlideHelper.show();
              slideHelper.show();
              dragHelper.show();
              var dragX = s * dragWidth;
              var dragY = dragHeight - v * dragHeight;
              dragX = Math.max(
                -dragHelperHeight,
                Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
              );
              dragY = Math.max(
                -dragHelperHeight,
                Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
              );
              dragHelper.css({
                "top": dragY + "px",
                "left": dragX + "px"
              });
              var alphaX = currentAlpha * alphaWidth;
              alphaSlideHelper.css({
                "left": alphaX - alphaSlideHelperWidth / 2 + "px"
              });
              var slideY = currentHue * slideHeight;
              slideHelper.css({
                "top": slideY - slideHelperHeight + "px"
              });
            }
          }
          function updateOriginalInput(fireCallback) {
            var color = get(), displayColor = "", hasChanged = !tinycolor.equals(color, colorOnShow);
            if (color) {
              displayColor = color.toString(currentPreferredFormat);
              addColorToSelectionPalette(color);
            }
            if (isInput) {
              boundElement.val(displayColor);
            }
            if (fireCallback && hasChanged) {
              callbacks.change(color);
              boundElement.trigger("change", [color]);
            }
          }
          function reflow() {
            if (!visible) {
              return;
            }
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();
            if (!flat) {
              container.css("position", "absolute");
              if (opts.offset) {
                container.offset(opts.offset);
              } else {
                container.offset(getOffset(container, offsetElement));
              }
            }
            updateHelperLocations();
            if (opts.showPalette) {
              drawPalette();
            }
            boundElement.trigger("reflow.spectrum");
          }
          function destroy() {
            boundElement.show();
            offsetElement.off("click.spectrum touchstart.spectrum");
            container.remove();
            replacer.remove();
            spectrums[spect.id] = null;
          }
          function option(optionName, optionValue) {
            if (optionName === undefined2) {
              return $2.extend({}, opts);
            }
            if (optionValue === undefined2) {
              return opts[optionName];
            }
            opts[optionName] = optionValue;
            if (optionName === "preferredFormat") {
              currentPreferredFormat = opts.preferredFormat;
            }
            applyOptions();
          }
          function enable() {
            disabled = false;
            boundElement.attr("disabled", false);
            offsetElement.removeClass("sp-disabled");
          }
          function disable() {
            hide();
            disabled = true;
            boundElement.attr("disabled", true);
            offsetElement.addClass("sp-disabled");
          }
          function setOffset(coord) {
            opts.offset = coord;
            reflow();
          }
          initialize();
          var spect = {
            show,
            hide,
            toggle,
            reflow,
            option,
            enable,
            disable,
            offset: setOffset,
            set: function(c2) {
              set(c2);
              updateOriginalInput();
            },
            get,
            destroy,
            container
          };
          spect.id = spectrums.push(spect) - 1;
          return spect;
        }
        function getOffset(picker, input) {
          var extraY = 0;
          var dpWidth = picker.outerWidth();
          var dpHeight = picker.outerHeight();
          var inputHeight = input.outerHeight();
          var doc = picker[0].ownerDocument;
          var docElem = doc.documentElement;
          var viewWidth = docElem.clientWidth + $2(doc).scrollLeft();
          var viewHeight = docElem.clientHeight + $2(doc).scrollTop();
          var offset = input.offset();
          var offsetLeft = offset.left;
          var offsetTop = offset.top;
          offsetTop += inputHeight;
          offsetLeft -= Math.min(offsetLeft, offsetLeft + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offsetLeft + dpWidth - viewWidth) : 0);
          offsetTop -= Math.min(offsetTop, offsetTop + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);
          return {
            top: offsetTop,
            bottom: offset.bottom,
            left: offsetLeft,
            right: offset.right,
            width: offset.width,
            height: offset.height
          };
        }
        function noop() {
        }
        function stopPropagation(e) {
          e.stopPropagation();
        }
        function bind(func, obj) {
          var slice = Array.prototype.slice;
          var args = slice.call(arguments, 2);
          return function() {
            return func.apply(obj, args.concat(slice.call(arguments)));
          };
        }
        function draggable(element, onmove, onstart, onstop) {
          onmove = onmove || function() {
          };
          onstart = onstart || function() {
          };
          onstop = onstop || function() {
          };
          var doc = document;
          var dragging = false;
          var offset = {};
          var maxHeight = 0;
          var maxWidth = 0;
          var hasTouch = "ontouchstart" in window;
          var duringDragEvents = {};
          duringDragEvents["selectstart"] = prevent;
          duringDragEvents["dragstart"] = prevent;
          duringDragEvents["touchmove mousemove"] = move;
          duringDragEvents["touchend mouseup"] = stop;
          function prevent(e) {
            if (e.stopPropagation) {
              e.stopPropagation();
            }
            if (e.preventDefault) {
              e.preventDefault();
            }
            e.returnValue = false;
          }
          function move(e) {
            if (dragging) {
              if (IE && doc.documentMode < 9 && !e.button) {
                return stop();
              }
              var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
              var pageX = t0 && t0.pageX || e.pageX;
              var pageY = t0 && t0.pageY || e.pageY;
              var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
              var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
              if (hasTouch) {
                prevent(e);
              }
              onmove.apply(element, [dragX, dragY, e]);
            }
          }
          function start(e) {
            var rightclick = e.which ? e.which == 3 : e.button == 2;
            if (!rightclick && !dragging) {
              if (onstart.apply(element, arguments) !== false) {
                dragging = true;
                maxHeight = $2(element).height();
                maxWidth = $2(element).width();
                offset = $2(element).offset();
                $2(doc).on(duringDragEvents);
                $2(doc.body).addClass("sp-dragging");
                move(e);
                prevent(e);
              }
            }
          }
          function stop() {
            if (dragging) {
              $2(doc).off(duringDragEvents);
              $2(doc.body).removeClass("sp-dragging");
              setTimeout(function() {
                onstop.apply(element, arguments);
              }, 0);
            }
            dragging = false;
          }
          $2(element).on("touchstart mousedown", start);
        }
        function throttle(func, wait, debounce) {
          var timeout;
          return function() {
            var context = this, args = arguments;
            var throttler = function() {
              timeout = null;
              func.apply(context, args);
            };
            if (debounce)
              clearTimeout(timeout);
            if (debounce || !timeout)
              timeout = setTimeout(throttler, wait);
          };
        }
        function inputTypeColorSupport() {
          return $2.fn.spectrum.inputTypeColorSupport();
        }
        var dataID = "spectrum.id";
        $2.fn.spectrum = function(opts, extra) {
          if (typeof opts == "string") {
            var returnValue = this;
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
              var spect = spectrums[$2(this).data(dataID)];
              if (spect) {
                var method = spect[opts];
                if (!method) {
                  throw new Error("Spectrum: no such method: '" + opts + "'");
                }
                if (opts == "get") {
                  returnValue = spect.get();
                } else if (opts == "container") {
                  returnValue = spect.container;
                } else if (opts == "option") {
                  returnValue = spect.option.apply(spect, args);
                } else if (opts == "destroy") {
                  spect.destroy();
                  $2(this).removeData(dataID);
                } else {
                  method.apply(spect, args);
                }
              }
            });
            return returnValue;
          }
          return this.spectrum("destroy").each(function() {
            var options2 = $2.extend({}, $2(this).data(), opts);
            var spect = spectrum(this, options2);
            $2(this).data(dataID, spect.id);
          });
        };
        $2.fn.spectrum.load = true;
        $2.fn.spectrum.loadOpts = {};
        $2.fn.spectrum.draggable = draggable;
        $2.fn.spectrum.defaults = defaultOpts;
        $2.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport2() {
          if (typeof inputTypeColorSupport2._cachedResult === "undefined") {
            var colorInput = $2("<input type='color'/>")[0];
            inputTypeColorSupport2._cachedResult = colorInput.type === "color" && colorInput.value !== "";
          }
          return inputTypeColorSupport2._cachedResult;
        };
        $2.spectrum = {};
        $2.spectrum.localization = {};
        $2.spectrum.palettes = {};
        $2.fn.spectrum.processNativeColorInputs = function() {
          var colorInputs = $2("input[type=color]");
          if (colorInputs.length && !inputTypeColorSupport()) {
            colorInputs.spectrum({
              preferredFormat: "hex6"
            });
          }
        };
        (function() {
          var trimLeft = /^[\s,#]+/, trimRight = /\s+$/, tinyCounter = 0, math = Math, mathRound = math.round, mathMin = math.min, mathMax = math.max, mathRandom = math.random;
          var tinycolor2 = function(color, opts) {
            color = color ? color : "";
            opts = opts || {};
            if (color instanceof tinycolor2) {
              return color;
            }
            if (!(this instanceof tinycolor2)) {
              return new tinycolor2(color, opts);
            }
            var rgb2 = inputToRGB(color);
            this._originalInput = color;
            this._r = rgb2.r;
            this._g = rgb2.g;
            this._b = rgb2.b;
            this._a = rgb2.a;
            this._roundA = mathRound(1e3 * this._a) / 1e3;
            this._format = opts.format || rgb2.format;
            this._gradientType = opts.gradientType;
            if (this._r < 1) {
              this._r = mathRound(this._r);
            }
            if (this._g < 1) {
              this._g = mathRound(this._g);
            }
            if (this._b < 1) {
              this._b = mathRound(this._b);
            }
            this._ok = rgb2.ok;
            this._tc_id = tinyCounter++;
          };
          tinycolor2.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var rgb2 = this.toRgb();
              return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
            },
            setAlpha: function(value) {
              this._a = boundAlpha(value);
              this._roundA = mathRound(1e3 * this._a) / 1e3;
              return this;
            },
            toHsv: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
            },
            toHsvString: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
              return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
            },
            toHslString: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
              return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
            },
            toHex: function(allow3Char) {
              return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function(allow3Char) {
              return "#" + this.toHex(allow3Char);
            },
            toHex8: function() {
              return rgbaToHex(this._r, this._g, this._b, this._a);
            },
            toHex8String: function() {
              return "#" + this.toHex8();
            },
            toRgb: function() {
              return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              if (this._a === 0) {
                return "transparent";
              }
              if (this._a < 1) {
                return false;
              }
              return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
            },
            toFilter: function(secondColor) {
              var hex8String = "#" + rgbaToHex(this._r, this._g, this._b, this._a);
              var secondHex8String = hex8String;
              var gradientType = this._gradientType ? "GradientType = 1, " : "";
              if (secondColor) {
                var s = tinycolor2(secondColor);
                secondHex8String = s.toHex8String();
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
            },
            toString: function(format) {
              var formatSet = !!format;
              format = format || this._format;
              var formattedString = false;
              var hasAlpha = this._a < 1 && this._a >= 0;
              var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
              if (needsAlphaFormat) {
                if (format === "name" && this._a === 0) {
                  return this.toName();
                }
                return this.toRgbString();
              }
              if (format === "rgb") {
                formattedString = this.toRgbString();
              }
              if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
              }
              if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
              }
              if (format === "hex3") {
                formattedString = this.toHexString(true);
              }
              if (format === "hex8") {
                formattedString = this.toHex8String();
              }
              if (format === "name") {
                formattedString = this.toName();
              }
              if (format === "hsl") {
                formattedString = this.toHslString();
              }
              if (format === "hsv") {
                formattedString = this.toHsvString();
              }
              return formattedString || this.toHexString();
            },
            _applyModification: function(fn, args) {
              var color = fn.apply(null, [this].concat([].slice.call(args)));
              this._r = color._r;
              this._g = color._g;
              this._b = color._b;
              this.setAlpha(color._a);
              return this;
            },
            lighten: function() {
              return this._applyModification(lighten, arguments);
            },
            brighten: function() {
              return this._applyModification(brighten, arguments);
            },
            darken: function() {
              return this._applyModification(darken, arguments);
            },
            desaturate: function() {
              return this._applyModification(desaturate, arguments);
            },
            saturate: function() {
              return this._applyModification(saturate, arguments);
            },
            greyscale: function() {
              return this._applyModification(greyscale, arguments);
            },
            spin: function() {
              return this._applyModification(spin, arguments);
            },
            _applyCombination: function(fn, args) {
              return fn.apply(null, [this].concat([].slice.call(args)));
            },
            analogous: function() {
              return this._applyCombination(analogous, arguments);
            },
            complement: function() {
              return this._applyCombination(complement, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(splitcomplement, arguments);
            },
            triad: function() {
              return this._applyCombination(triad, arguments);
            },
            tetrad: function() {
              return this._applyCombination(tetrad, arguments);
            }
          };
          tinycolor2.fromRatio = function(color, opts) {
            if (typeof color == "object") {
              var newColor = {};
              for (var i2 in color) {
                if (color.hasOwnProperty(i2)) {
                  if (i2 === "a") {
                    newColor[i2] = color[i2];
                  } else {
                    newColor[i2] = convertToPercentage(color[i2]);
                  }
                }
              }
              color = newColor;
            }
            return tinycolor2(color, opts);
          };
          function inputToRGB(color) {
            var rgb2 = { r: 0, g: 0, b: 0 };
            var a = 1;
            var ok = false;
            var format = false;
            if (typeof color == "string") {
              color = stringInputToObject(color);
            }
            if (typeof color == "object") {
              if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb2 = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
              } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb2 = hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = "hsv";
              } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb2 = hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = "hsl";
              }
              if (color.hasOwnProperty("a")) {
                a = color.a;
              }
            }
            a = boundAlpha(a);
            return {
              ok,
              format: color.format || format,
              r: mathMin(255, mathMax(rgb2.r, 0)),
              g: mathMin(255, mathMax(rgb2.g, 0)),
              b: mathMin(255, mathMax(rgb2.b, 0)),
              a
            };
          }
          function rgbToRgb(r, g, b) {
            return {
              r: bound01(r, 255) * 255,
              g: bound01(g, 255) * 255,
              b: bound01(b, 255) * 255
            };
          }
          function rgbToHsl(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max == min) {
              h = s = 0;
            } else {
              var d2 = max - min;
              s = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
              switch (max) {
                case r:
                  h = (g - b) / d2 + (g < b ? 6 : 0);
                  break;
                case g:
                  h = (b - r) / d2 + 2;
                  break;
                case b:
                  h = (r - g) / d2 + 4;
                  break;
              }
              h /= 6;
            }
            return { h, s, l };
          }
          function hslToRgb(h, s, l) {
            var r, g, b;
            h = bound01(h, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);
            function hue2rgb(p2, q2, t) {
              if (t < 0)
                t += 1;
              if (t > 1)
                t -= 1;
              if (t < 1 / 6)
                return p2 + (q2 - p2) * 6 * t;
              if (t < 1 / 2)
                return q2;
              if (t < 2 / 3)
                return p2 + (q2 - p2) * (2 / 3 - t) * 6;
              return p2;
            }
            if (s === 0) {
              r = g = b = l;
            } else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r = hue2rgb(p, q, h + 1 / 3);
              g = hue2rgb(p, q, h);
              b = hue2rgb(p, q, h - 1 / 3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHsv(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, v = max;
            var d2 = max - min;
            s = max === 0 ? 0 : d2 / max;
            if (max == min) {
              h = 0;
            } else {
              switch (max) {
                case r:
                  h = (g - b) / d2 + (g < b ? 6 : 0);
                  break;
                case g:
                  h = (b - r) / d2 + 2;
                  break;
                case b:
                  h = (r - g) / d2 + 4;
                  break;
              }
              h /= 6;
            }
            return { h, s, v };
          }
          function hsvToRgb(h, s, v) {
            h = bound01(h, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);
            var i2 = math.floor(h), f = h - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i2 % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHex(r, g, b, allow3Char) {
            var hex = [
              pad2(mathRound(r).toString(16)),
              pad2(mathRound(g).toString(16)),
              pad2(mathRound(b).toString(16))
            ];
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToHex(r, g, b, a) {
            var hex = [
              pad2(convertDecimalToHex(a)),
              pad2(mathRound(r).toString(16)),
              pad2(mathRound(g).toString(16)),
              pad2(mathRound(b).toString(16))
            ];
            return hex.join("");
          }
          tinycolor2.equals = function(color1, color2) {
            if (!color1 || !color2) {
              return false;
            }
            return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
          };
          tinycolor2.random = function() {
            return tinycolor2.fromRatio({
              r: mathRandom(),
              g: mathRandom(),
              b: mathRandom()
            });
          };
          function desaturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor2(hsl);
          }
          function saturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor2(hsl);
          }
          function greyscale(color) {
            return tinycolor2(color).desaturate(100);
          }
          function lighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor2(hsl);
          }
          function brighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var rgb2 = tinycolor2(color).toRgb();
            rgb2.r = mathMax(0, mathMin(255, rgb2.r - mathRound(255 * -(amount / 100))));
            rgb2.g = mathMax(0, mathMin(255, rgb2.g - mathRound(255 * -(amount / 100))));
            rgb2.b = mathMax(0, mathMin(255, rgb2.b - mathRound(255 * -(amount / 100))));
            return tinycolor2(rgb2);
          }
          function darken(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor2(hsl);
          }
          function spin(color, amount) {
            var hsl = tinycolor2(color).toHsl();
            var hue = (mathRound(hsl.h) + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return tinycolor2(hsl);
          }
          function complement(color) {
            var hsl = tinycolor2(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor2(hsl);
          }
          function triad(color) {
            var hsl = tinycolor2(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function tetrad(color) {
            var hsl = tinycolor2(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function splitcomplement(color) {
            var hsl = tinycolor2(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function analogous(color, results, slices) {
            results = results || 6;
            slices = slices || 30;
            var hsl = tinycolor2(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor2(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(tinycolor2(hsl));
            }
            return ret;
          }
          function monochromatic(color, results) {
            results = results || 6;
            var hsv = tinycolor2(color).toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;
            while (results--) {
              ret.push(tinycolor2({ h, s, v }));
              v = (v + modification) % 1;
            }
            return ret;
          }
          tinycolor2.mix = function(color1, color2, amount) {
            amount = amount === 0 ? 0 : amount || 50;
            var rgb1 = tinycolor2(color1).toRgb();
            var rgb2 = tinycolor2(color2).toRgb();
            var p = amount / 100;
            var w = p * 2 - 1;
            var a = rgb2.a - rgb1.a;
            var w1;
            if (w * a == -1) {
              w1 = w;
            } else {
              w1 = (w + a) / (1 + w * a);
            }
            w1 = (w1 + 1) / 2;
            var w2 = 1 - w1;
            var rgba = {
              r: rgb2.r * w1 + rgb1.r * w2,
              g: rgb2.g * w1 + rgb1.g * w2,
              b: rgb2.b * w1 + rgb1.b * w2,
              a: rgb2.a * p + rgb1.a * (1 - p)
            };
            return tinycolor2(rgba);
          };
          tinycolor2.readability = function(color1, color2) {
            var c1 = tinycolor2(color1);
            var c2 = tinycolor2(color2);
            var rgb1 = c1.toRgb();
            var rgb2 = c2.toRgb();
            var brightnessA = c1.getBrightness();
            var brightnessB = c2.getBrightness();
            var colorDiff = Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) + Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) + Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b);
            return {
              brightness: Math.abs(brightnessA - brightnessB),
              color: colorDiff
            };
          };
          tinycolor2.isReadable = function(color1, color2) {
            var readability = tinycolor2.readability(color1, color2);
            return readability.brightness > 125 && readability.color > 500;
          };
          tinycolor2.mostReadable = function(baseColor, colorList) {
            var bestColor = null;
            var bestScore = 0;
            var bestIsReadable = false;
            for (var i2 = 0; i2 < colorList.length; i2++) {
              var readability = tinycolor2.readability(baseColor, colorList[i2]);
              var readable = readability.brightness > 125 && readability.color > 500;
              var score = 3 * (readability.brightness / 125) + readability.color / 500;
              if (readable && !bestIsReadable || readable && bestIsReadable && score > bestScore || !readable && !bestIsReadable && score > bestScore) {
                bestIsReadable = readable;
                bestScore = score;
                bestColor = tinycolor2(colorList[i2]);
              }
            }
            return bestColor;
          };
          var names = tinycolor2.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          };
          var hexNames = tinycolor2.hexNames = flip(names);
          function flip(o) {
            var flipped = {};
            for (var i2 in o) {
              if (o.hasOwnProperty(i2)) {
                flipped[o[i2]] = i2;
              }
            }
            return flipped;
          }
          function boundAlpha(a) {
            a = parseFloat(a);
            if (isNaN(a) || a < 0 || a > 1) {
              a = 1;
            }
            return a;
          }
          function bound01(n, max) {
            if (isOnePointZero(n)) {
              n = "100%";
            }
            var processPercent = isPercentage(n);
            n = mathMin(max, mathMax(0, parseFloat(n)));
            if (processPercent) {
              n = parseInt(n * max, 10) / 100;
            }
            if (math.abs(n - max) < 1e-6) {
              return 1;
            }
            return n % max / parseFloat(max);
          }
          function clamp01(val) {
            return mathMin(1, mathMax(0, val));
          }
          function parseIntFromHex(val) {
            return parseInt(val, 16);
          }
          function isOnePointZero(n) {
            return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
          }
          function isPercentage(n) {
            return typeof n === "string" && n.indexOf("%") != -1;
          }
          function pad2(c2) {
            return c2.length == 1 ? "0" + c2 : "" + c2;
          }
          function convertToPercentage(n) {
            if (n <= 1) {
              n = n * 100 + "%";
            }
            return n;
          }
          function convertDecimalToHex(d2) {
            return Math.round(parseFloat(d2) * 255).toString(16);
          }
          function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255;
          }
          var matchers = function() {
            var CSS_INTEGER = "[-\\+]?\\d+%?";
            var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
            var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
            var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            return {
              rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
              rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
              hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
              hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
              hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
              hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
              hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function stringInputToObject(color) {
            color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
            var named = false;
            if (names[color]) {
              color = names[color];
              named = true;
            } else if (color == "transparent") {
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            }
            var match;
            if (match = matchers.rgb.exec(color)) {
              return { r: match[1], g: match[2], b: match[3] };
            }
            if (match = matchers.rgba.exec(color)) {
              return { r: match[1], g: match[2], b: match[3], a: match[4] };
            }
            if (match = matchers.hsl.exec(color)) {
              return { h: match[1], s: match[2], l: match[3] };
            }
            if (match = matchers.hsla.exec(color)) {
              return { h: match[1], s: match[2], l: match[3], a: match[4] };
            }
            if (match = matchers.hsv.exec(color)) {
              return { h: match[1], s: match[2], v: match[3] };
            }
            if (match = matchers.hsva.exec(color)) {
              return { h: match[1], s: match[2], v: match[3], a: match[4] };
            }
            if (match = matchers.hex8.exec(color)) {
              return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
              };
            }
            if (match = matchers.hex6.exec(color)) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
              };
            }
            if (match = matchers.hex3.exec(color)) {
              return {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                format: named ? "name" : "hex"
              };
            }
            return false;
          }
          window.tinycolor = tinycolor2;
        })();
        $2(function() {
          if ($2.fn.spectrum.load) {
            $2.fn.spectrum.processNativeColorInputs();
          }
        });
      });
    }
  });

  // node_modules/jqplot-exported/node_modules/jquery/dist/jquery.js
  var require_jquery2 = __commonJS({
    "node_modules/jqplot-exported/node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString2 = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i2, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i2 in preservedScriptAttributes) {
              val = node[i2] || node.getAttribute && node.getAttribute(i2);
              if (val) {
                script.setAttribute(i2, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
        }
        var version = "3.6.1", jQuery5 = function(selector, context) {
          return new jQuery5.fn.init(selector, context);
        };
        jQuery5.fn = jQuery5.prototype = {
          jquery: version,
          constructor: jQuery5,
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          pushStack: function(elems) {
            var ret = jQuery5.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          each: function(callback) {
            return jQuery5.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery5.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery5.grep(this, function(_elem, i2) {
              return (i2 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery5.grep(this, function(_elem, i2) {
              return i2 % 2;
            }));
          },
          eq: function(i2) {
            var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery5.extend = jQuery5.fn.extend = function() {
          var options2, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options2 = arguments[i2]) != null) {
              for (name in options2) {
                copy = options2[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery5.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery5.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery5.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery5.extend({
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString2.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          globalEval: function(code, options2, doc) {
            DOMEval(code, { nonce: options2 && options2.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i2 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i2 < length; i2++) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            } else {
              for (i2 in obj) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery5.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
          },
          merge: function(first2, second) {
            var len = +second.length, j = 0, i2 = first2.length;
            for (; j < len; j++) {
              first2[i2++] = second[j];
            }
            first2.length = i2;
            return first2;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i2]);
              }
            }
            return matches;
          },
          map: function(elems, callback, arg) {
            var length, value, i2 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          guid: 1,
          support
        });
        if (typeof Symbol === "function") {
          jQuery5.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery5.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = function(window3) {
          var i2, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
              hasDuplicate = true;
            }
            return 0;
          }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
            var i3 = 0, len = list.length;
            for (; i3 < len; i3++) {
              if (list[i3] === elem) {
                return i3;
              }
            }
            return -1;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + "*([*^$|!~]?=)" + whitespace2 + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rcombinators = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
          }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 65536;
            return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
              if (ch === "\0") {
                return "\uFFFD";
              }
              return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            return "\\" + ch;
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
            },
            { dir: "parentNode", next: "legend" }
          );
          try {
            push2.apply(
              arr2 = slice2.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr2[preferredDoc.childNodes.length].nodeType;
          } catch (e) {
            push2 = {
              apply: arr2.length ? function(target, els) {
                pushNative.apply(target, slice2.call(els));
              } : function(target, els) {
                var j = target.length, i3 = 0;
                while (target[j++] = els[i3++]) {
                }
                target.length = j - 1;
              }
            };
          }
          function Sizzle2(selector, context, results, seed) {
            var m, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m)) {
                        if (elem.id === m) {
                          results.push(elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m));
                    return results;
                  }
                }
                if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext !== context || !support2.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = nid.replace(rcssescape, fcssescape);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize(selector);
                    i3 = groups.length;
                    while (i3--) {
                      groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrim2, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache[keys.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn) {
            fn[expando] = true;
            return fn;
          }
          function assert(fn) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn(el);
            } catch (e) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function addHandle(attrs, handler) {
            var arr3 = attrs.split("|"), i3 = arr3.length;
            while (i3--) {
              Expr.attrHandle[arr3[i3]] = handler;
            }
          }
          function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
              return diff;
            }
            if (cur) {
              while (cur = cur.nextSibling) {
                if (cur === b) {
                  return -1;
                }
              }
            }
            return a ? 1 : -1;
          }
          function createInputPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return (name === "input" || name === "button") && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j, matchIndexes = fn([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j = matchIndexes[i3]]) {
                    seed[j] = !(matches2[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          support2 = Sizzle2.support = {};
          isXML = Sizzle2.isXML = function(elem) {
            var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
          };
          setDocument = Sizzle2.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            docElem = document3.documentElement;
            documentIsHTML = !isXML(document3);
            if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              if (subWindow.addEventListener) {
                subWindow.addEventListener("unload", unloadHandler, false);
              } else if (subWindow.attachEvent) {
                subWindow.attachEvent("onunload", unloadHandler);
              }
            }
            support2.scope = assert(function(el) {
              docElem.appendChild(el).appendChild(document3.createElement("div"));
              return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            support2.attributes = assert(function(el) {
              el.className = "i";
              return !el.getAttribute("className");
            });
            support2.getElementsByTagName = assert(function(el) {
              el.appendChild(document3.createComment(""));
              return !el.getElementsByTagName("*").length;
            });
            support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
            support2.getById = assert(function(el) {
              docElem.appendChild(el).id = expando;
              return !document3.getElementsByName || !document3.getElementsByName(expando).length;
            });
            if (support2.getById) {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i3, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i3 = 0;
                    while (elem = elems[i3++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else if (support2.qsa) {
                return context.querySelectorAll(tag);
              }
            } : function(tag, context) {
              var elem, tmp = [], i3 = 0, results = context.getElementsByTagName(tag);
              if (tag === "*") {
                while (elem = results[i3++]) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }
                return tmp;
              }
              return results;
            };
            Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support2.qsa = rnative.test(document3.querySelectorAll)) {
              assert(function(el) {
                var input;
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
                if (el.querySelectorAll("[msallowcapture^='']").length) {
                  rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
                }
                if (!el.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
                }
                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                input = document3.createElement("input");
                input.setAttribute("name", "");
                el.appendChild(input);
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
                }
                if (!el.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
                el.querySelectorAll("\\\f");
                rbuggyQSA.push("[\\r\\n\\f]");
              });
              assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document3.createElement("input");
                input.setAttribute("type", "hidden");
                el.appendChild(input).setAttribute("name", "D");
                if (el.querySelectorAll("[name=d]").length) {
                  rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
                }
                if (el.querySelectorAll(":enabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                docElem.appendChild(el).disabled = true;
                if (el.querySelectorAll(":disabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                el.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
              });
            }
            if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
              assert(function(el) {
                support2.disconnectedMatch = matches.call(el, "*");
                matches.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
              });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
              var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
              return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
              if (b) {
                while (b = b.parentNode) {
                  if (b === a) {
                    return true;
                  }
                }
              }
              return false;
            };
            sortOrder = hasCompare ? function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
              if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
                if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
                  return -1;
                }
                if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
                  return 1;
                }
                return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              }
              return compare & 4 ? -1 : 1;
            } : function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var cur, i3 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
              if (!aup || !bup) {
                return a == document3 ? -1 : b == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              } else if (aup === bup) {
                return siblingCheck(a, b);
              }
              cur = a;
              while (cur = cur.parentNode) {
                ap.unshift(cur);
              }
              cur = b;
              while (cur = cur.parentNode) {
                bp.unshift(cur);
              }
              while (ap[i3] === bp[i3]) {
                i3++;
              }
              return i3 ? siblingCheck(ap[i3], bp[i3]) : ap[i3] == preferredDoc ? -1 : bp[i3] == preferredDoc ? 1 : 0;
            };
            return document3;
          };
          Sizzle2.matches = function(expr, elements) {
            return Sizzle2(expr, null, null, elements);
          };
          Sizzle2.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return Sizzle2(expr, document3, null, [elem]).length > 0;
          };
          Sizzle2.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return contains(context, elem);
          };
          Sizzle2.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          };
          Sizzle2.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
          };
          Sizzle2.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          Sizzle2.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i3 = 0;
            hasDuplicate = !support2.detectDuplicates;
            sortInput = !support2.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j = duplicates.push(i3);
                }
              }
              while (j--) {
                results.splice(duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          getText = Sizzle2.getText = function(elem) {
            var node, ret = "", i3 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i3++]) {
                ret += getText(node);
              }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
              if (typeof elem.textContent === "string") {
                return elem.textContent;
              } else {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  ret += getText(elem);
                }
              }
            } else if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          };
          Expr = Sizzle2.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              "ATTR": function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              "CHILD": function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    Sizzle2.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  Sizzle2.error(match[0]);
                }
                return match;
              },
              "PSEUDO": function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr["CHILD"].test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              "TAG": function(nodeNameSelector) {
                var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
                };
              },
              "CLASS": function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(
                  className,
                  function(elem) {
                    return pattern.test(
                      typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                    );
                  }
                );
              },
              "ATTR": function(name, operator, check) {
                return function(elem) {
                  var result = Sizzle2.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                };
              },
              "CHILD": function(type, what, _argument, first2, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first2 === 1 && last === 0 ? function(elem) {
                  return !!elem.parentNode;
                } : function(elem, _context, xml) {
                  var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start = dir2 = type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }
                    start = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      node = parent;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        node = elem;
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        cache = uniqueCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                          if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                              uniqueCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                  }
                };
              },
              "PSEUDO": function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf2(seed, matched[i3]);
                      seed[idx] = !(matches2[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              "not": markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches2[i3] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              "has": markFunction(function(selector) {
                return function(elem) {
                  return Sizzle2(selector, elem).length > 0;
                };
              }),
              "contains": markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || getText(elem)).indexOf(text) > -1;
                };
              }),
              "lang": markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  Sizzle2.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              "target": function(elem) {
                var hash = window3.location && window3.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              "root": function(elem) {
                return elem === docElem;
              },
              "focus": function(elem) {
                return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              "enabled": createDisabledPseudo(false),
              "disabled": createDisabledPseudo(true),
              "checked": function(elem) {
                var nodeName2 = elem.nodeName.toLowerCase();
                return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
              },
              "selected": function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              "empty": function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              "parent": function(elem) {
                return !Expr.pseudos["empty"](elem);
              },
              "header": function(elem) {
                return rheader.test(elem.nodeName);
              },
              "input": function(elem) {
                return rinputs.test(elem.nodeName);
              },
              "button": function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
              },
              "text": function(elem) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              "first": createPositionalPseudo(function() {
                return [0];
              }),
              "last": createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              "even": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "odd": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument > length ? length : argument;
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos["nth"] = Expr.pseudos["eq"];
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rcombinators.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: match[0].replace(rtrim2, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
          };
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            } : function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            };
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i3 = matchers.length;
              while (i3--) {
                if (!matchers[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              Sizzle2(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map2, filter2, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map2 != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter2 || filter2(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map2.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
              if (matcher) {
                matcher(matcherIn, matcherOut, context, xml);
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando]) {
                  j = ++i3;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i3 > 1 && elementMatcher(matchers),
                    i3 > 1 && toSelector(
                      tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                    ).replace(rtrim2, "$1"),
                    matcher,
                    i3 < j && matcherFromTokens(tokens.slice(i3, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context || document3, xml)) {
                      results.push(elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  Sizzle2.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          compile = Sizzle2.compile = function(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          };
          select = Sizzle2.select = function(selector, context, results, seed) {
            var i3, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find = Expr.find[type]) {
                  if (seed = find(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          };
          support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          support2.detectDuplicates = !!hasDuplicate;
          setDocument();
          support2.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
          })) {
            addHandle("type|href|height|width", function(elem, name, isXML2) {
              if (!isXML2) {
                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
              }
            });
          }
          if (!support2.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
          })) {
            addHandle("value", function(elem, _name, isXML2) {
              if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                return elem.defaultValue;
              }
            });
          }
          if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
          })) {
            addHandle(booleans, function(elem, name, isXML2) {
              var val;
              if (!isXML2) {
                return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
              }
            });
          }
          return Sizzle2;
        }(window2);
        jQuery5.find = Sizzle;
        jQuery5.expr = Sizzle.selectors;
        jQuery5.expr[":"] = jQuery5.expr.pseudos;
        jQuery5.uniqueSort = jQuery5.unique = Sizzle.uniqueSort;
        jQuery5.text = Sizzle.getText;
        jQuery5.isXMLDoc = Sizzle.isXML;
        jQuery5.contains = Sizzle.contains;
        jQuery5.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery5(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery5.expr.match.needsContext;
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery5.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery5.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery5.grep(elements, function(elem) {
              return indexOf.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery5.filter(qualifier, elements, not);
        }
        jQuery5.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery5.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery5.find.matches(expr, jQuery5.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery5.fn.extend({
          find: function(selector) {
            var i2, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery5(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery5.contains(self2[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i2 = 0; i2 < len; i2++) {
              jQuery5.find(selector, self2[i2], ret);
            }
            return len > 1 ? jQuery5.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery5(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery5.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery5 ? context[0] : context;
                jQuery5.merge(this, jQuery5.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery5.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : selector(jQuery5);
          }
          return jQuery5.makeArray(selector, this);
        };
        init.prototype = jQuery5.fn;
        rootjQuery = jQuery5(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery5.fn.extend({
          has: function(target) {
            var targets = jQuery5(target, this), l = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l; i2++) {
                if (jQuery5.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery5(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i2 < l; i2++) {
                for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery5.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery5.uniqueSort(matched) : matched);
          },
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery5(elem), this[0]);
            }
            return indexOf.call(
              this,
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery5.uniqueSort(
                jQuery5.merge(this.get(), jQuery5(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery5.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery5.merge([], elem.childNodes);
          }
        }, function(name, fn) {
          jQuery5.fn[name] = function(until, selector) {
            var matched = jQuery5.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery5.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery5.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options2) {
          var object = {};
          jQuery5.each(options2.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery5.Callbacks = function(options2) {
          options2 = typeof options2 === "string" ? createOptions(options2) : jQuery5.extend({}, options2);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options2.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options2.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options2.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add(args) {
                  jQuery5.each(args, function(_, arg) {
                    if (isFunction(arg)) {
                      if (!options2.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            remove: function() {
              jQuery5.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery5.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            has: function(fn) {
              return fn ? jQuery5.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery5.extend({
          Deferred: function(func) {
            var tuples = [
              [
                "notify",
                "progress",
                jQuery5.Callbacks("memory"),
                jQuery5.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery5.Callbacks("once memory"),
                jQuery5.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery5.Callbacks("once memory"),
                jQuery5.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn) {
                return promise.then(null, fn);
              },
              pipe: function() {
                var fns = arguments;
                return jQuery5.Deferred(function(newDefer) {
                  jQuery5.each(tuples, function(_i, tuple) {
                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e) {
                        if (jQuery5.Deferred.exceptionHook) {
                          jQuery5.Deferred.exceptionHook(
                            e,
                            process.stackTrace
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process();
                    } else {
                      if (jQuery5.Deferred.getStackHook) {
                        process.stackTrace = jQuery5.Deferred.getStackHook();
                      }
                      window2.setTimeout(process);
                    }
                  };
                }
                return jQuery5.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              promise: function(obj) {
                return obj != null ? jQuery5.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery5.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  tuples[3 - i2][2].disable,
                  tuples[3 - i2][3].disable,
                  tuples[0][2].lock,
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          when: function(singleValue) {
            var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), primary = jQuery5.Deferred(), updateFunc = function(i3) {
              return function(value) {
                resolveContexts[i3] = this;
                resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i2)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i2] && resolveValues[i2].then)) {
                return primary.then();
              }
            }
            while (i2--) {
              adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery5.Deferred.exceptionHook = function(error, stack) {
          if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
            window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
          }
        };
        jQuery5.readyException = function(error) {
          window2.setTimeout(function() {
            throw error;
          });
        };
        var readyList = jQuery5.Deferred();
        jQuery5.fn.ready = function(fn) {
          readyList.then(fn).catch(function(error) {
            jQuery5.readyException(error);
          });
          return this;
        };
        jQuery5.extend({
          isReady: false,
          readyWait: 1,
          ready: function(wait) {
            if (wait === true ? --jQuery5.readyWait : jQuery5.isReady) {
              return;
            }
            jQuery5.isReady = true;
            if (wait !== true && --jQuery5.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery5]);
          }
        });
        jQuery5.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery5.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery5.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i2 in key) {
              access(elems, fn, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, _key, value2) {
                  return bulk.call(jQuery5(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i2 < len; i2++) {
                fn(
                  elems[i2],
                  key,
                  raw ? value : value.call(elems[i2], i2, fn(elems[i2], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn.call(elems);
          }
          return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery5.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
              cache[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache[camelCase(prop)] = data[prop];
              }
            }
            return cache;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, cache = owner[this.expando];
            if (cache === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
              }
              i2 = key.length;
              while (i2--) {
                delete cache[key[i2]];
              }
            }
            if (key === void 0 || jQuery5.isEmptyObject(cache)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== void 0 && !jQuery5.isEmptyObject(cache);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery5.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery5.fn.extend({
          data: function(key, value) {
            var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name = attrs[i2].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery5.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery5.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery5.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery5._queueHooks(elem, type), next = function() {
              jQuery5.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery5.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery5.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery5.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery5.queue(this, type, data);
              jQuery5._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery5.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery5.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery5.Deferred(), elements = this, i2 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = dataPriv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery5.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery5.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery5.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale2, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery5.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery5.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery5.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery5.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery5.style(elem, prop, initialInUnit + unit);
              if ((1 - scale2) * (1 - (scale2 = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale2;
            }
            initialInUnit = initialInUnit * 2;
            jQuery5.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery5.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery5.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery5(this).show();
              } else {
                jQuery5(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery5.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l = elems.length;
          for (; i2 < l; i2++) {
            dataPriv.set(
              elems[i2],
              "globalEval",
              !refElements || dataPriv.get(refElements[i2], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l = elems.length;
          for (; i2 < l; i2++) {
            elem = elems[i2];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery5.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery5.htmlPrefilter(elem) + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery5.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i2 = 0;
          while (elem = nodes[i2++]) {
            if (selection && jQuery5.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function expectSync(elem, type) {
          return elem === safeActiveElement() === (type === "focus");
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        function on(elem, types, selector, data, fn, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn == null) {
            fn = selector;
            data = selector = void 0;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data;
              data = void 0;
            } else {
              fn = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return elem;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery5().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery5.guid++);
          }
          return elem.each(function() {
            jQuery5.event.add(this, types, fn, data, selector);
          });
        }
        jQuery5.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery5.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery5.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery5 !== "undefined" && jQuery5.event.triggered !== e.type ? jQuery5.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery5.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery5.event.special[type] || {};
              handleObj = jQuery5.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery5.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery5.event.global[type] = true;
            }
          },
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery5.event.remove(elem, type + types[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery5.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery5.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery5.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i2, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery5.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery5.event.special[event.type] || {};
            args[0] = event;
            for (i2 = 1; i2 < arguments.length; i2++) {
              args[i2] = arguments[i2];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery5.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery5.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery5(sel, this).index(cur) > -1 : jQuery5.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery5.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery5.expando] ? originalEvent : new jQuery5.Event(originalEvent);
          },
          special: {
            load: {
              noBubble: true
            },
            click: {
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", returnTrue);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, expectSync2) {
          if (!expectSync2) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery5.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery5.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var notAsync, result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved.length) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  notAsync = expectSync2(this, type);
                  this[type]();
                  result = dataPriv.get(this, type);
                  if (saved !== result || notAsync) {
                    dataPriv.set(this, type, false);
                  } else {
                    result = {};
                  }
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result && result.value;
                  }
                } else if ((jQuery5.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved.length) {
                dataPriv.set(this, type, {
                  value: jQuery5.event.trigger(
                    jQuery5.extend(saved[0], jQuery5.Event.prototype),
                    saved.slice(1),
                    this
                  )
                });
                event.stopImmediatePropagation();
              }
            }
          });
        }
        jQuery5.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery5.Event = function(src, props) {
          if (!(this instanceof jQuery5.Event)) {
            return new jQuery5.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery5.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery5.expando] = true;
        };
        jQuery5.Event.prototype = {
          constructor: jQuery5.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery5.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery5.event.addProp);
        jQuery5.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          jQuery5.event.special[type] = {
            setup: function() {
              leverageNative(this, type, expectSync);
              return false;
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
        });
        jQuery5.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery5.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery5.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery5.fn.extend({
          on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
          },
          one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
          },
          off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery5(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery5.event.remove(this, types, fn, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery5(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i2, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i2 = 0, l = events[type].length; i2 < l; i2++) {
                  jQuery5.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery5.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first2, scripts, hasScripts, node, doc, i2 = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first2 = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first2;
            }
            if (first2 || ignored) {
              scripts = jQuery5.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i2 < l; i2++) {
                node = fragment;
                if (i2 !== iNoClone) {
                  node = jQuery5.clone(node, true, true);
                  if (hasScripts) {
                    jQuery5.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i2], node, i2);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery5.map(scripts, restoreScript);
                for (i2 = 0; i2 < hasScripts; i2++) {
                  node = scripts[i2];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery5.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery5._evalUrl && !node.noModule) {
                        jQuery5._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery5.filter(selector, elem) : elem, i2 = 0;
          for (; (node = nodes[i2]) != null; i2++) {
            if (!keepData && node.nodeType === 1) {
              jQuery5.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery5.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery5.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery5.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery5.event.remove(elem, type);
                      } else {
                        jQuery5.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery5.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery5.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery5.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery5.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery5.htmlPrefilter(value2);
                try {
                  for (; i2 < l; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery5.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery5.inArray(this, ignored) < 0) {
                jQuery5.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery5.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery5.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery5(selector), last = insert.length - 1, i2 = 0;
            for (; i2 <= last; i2++) {
              elems = i2 === last ? this : this.clone(true);
              jQuery5(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options2, callback) {
          var ret, name, old = {};
          for (name in options2) {
            old[name] = elem.style[name];
            elem.style[name] = options2[name];
          }
          ret = callback.call(elem);
          for (name in options2) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery5.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp) {
              ret = ret.replace(rtrimCSS, "$1");
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery5.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? ret + "" : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
          while (i2--) {
            name = cssPrefixes[i2] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery5.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i2 < 4; i2 += 2) {
            if (box === "margin") {
              delta += jQuery5.css(elem, box + cssExpand[i2], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery5.css(elem, "padding" + cssExpand[i2], true, styles);
              if (box !== "padding") {
                delta += jQuery5.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              } else {
                extra += jQuery5.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery5.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery5.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            )) || 0;
          }
          return delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery5.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery5.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
            isBorderBox = jQuery5.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            val
          ) + "px";
        }
        jQuery5.extend({
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          cssProps: {},
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery5.cssHooks[name] || jQuery5.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery5.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery5.cssHooks[name] || jQuery5.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery5.each(["height", "width"], function(_i, dimension) {
          jQuery5.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery5.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery5.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery5.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery5.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery5.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery5.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery5.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery5.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map2 = {}, i2 = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i2 < len; i2++) {
                  map2[name2[i2]] = jQuery5.css(elem, name2[i2], false, styles);
                }
                return map2;
              }
              return value2 !== void 0 ? jQuery5.style(elem, name2, value2) : jQuery5.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options2, prop, end, easing) {
          return new Tween.prototype.init(elem, options2, prop, end, easing);
        }
        jQuery5.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options2, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery5.easing._default;
            this.options = options2;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery5.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery5.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery5.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery5.fx.step[tween.prop]) {
                jQuery5.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery5.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery5.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery5.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery5.fx = Tween.prototype.init;
        jQuery5.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery5.fx.interval);
            }
            jQuery5.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery5._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery5.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery5.style(elem, prop);
            }
          }
          propTween = !jQuery5.isEmptyObject(props);
          if (!propTween && jQuery5.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery5.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery5.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery5.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery5.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery5.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options2) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery5.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery5.extend({}, properties),
            opts: jQuery5.extend(true, {
              specialEasing: {},
              easing: jQuery5.easing._default
            }, options2),
            originalProperties: properties,
            originalOptions: options2,
            startTime: fxNow || createFxNow(),
            duration: options2.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery5.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery5._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery5.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery5.fx.timer(
            jQuery5.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery5.Animation = jQuery5.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery5.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery5.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery5.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery5.fx.speeds) {
                opt.duration = jQuery5.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery5.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery5.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery5.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery5.isEmptyObject(prop), optall = jQuery5.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery5.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery5.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery5.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery5.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery5.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery5.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery5.fn[name];
          jQuery5.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery5.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery5.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery5.timers = [];
        jQuery5.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery5.timers;
          fxNow = Date.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery5.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery5.fx.timer = function(timer) {
          jQuery5.timers.push(timer);
          jQuery5.fx.start();
        };
        jQuery5.fx.interval = 13;
        jQuery5.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery5.fx.stop = function() {
          inProgress = null;
        };
        jQuery5.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        };
        jQuery5.fn.delay = function(time, type) {
          time = jQuery5.fx ? jQuery5.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery5.expr.attrHandle;
        jQuery5.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery5.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery5.removeAttr(this, name);
            });
          }
        });
        jQuery5.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery5.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery5.isXMLDoc(elem)) {
              hooks = jQuery5.attrHooks[name.toLowerCase()] || (jQuery5.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery5.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery5.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i2++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery5.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery5.each(jQuery5.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery5.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery5.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery5.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery5.propFix[name] || name];
            });
          }
        });
        jQuery5.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery5.isXMLDoc(elem)) {
              name = jQuery5.propFix[name] || name;
              hooks = jQuery5.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery5.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery5.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery5.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery5.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery5.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery5(this).addClass(value.call(this, j, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery5(this).removeClass(value.call(this, j, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i2, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i3) {
                jQuery5(this).toggleClass(
                  value.call(this, i3, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery5(this);
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i2 = 0;
            className = " " + selector + " ";
            while (elem = this[i2++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery5.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery5.valHooks[elem.type] || jQuery5.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i2, jQuery5(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery5.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery5.valHooks[this.type] || jQuery5.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery5.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery5.find.attr(elem, "value");
                return val != null ? val : stripAndCollapse(jQuery5.text(elem));
              }
            },
            select: {
              get: function(elem) {
                var value, option, i2, options2 = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options2.length;
                if (index < 0) {
                  i2 = max;
                } else {
                  i2 = one ? index : 0;
                }
                for (; i2 < max; i2++) {
                  option = options2[i2];
                  if ((option.selected || i2 === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery5(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options2 = elem.options, values = jQuery5.makeArray(value), i2 = options2.length;
                while (i2--) {
                  option = options2[i2];
                  if (option.selected = jQuery5.inArray(jQuery5.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery5.each(["radio", "checkbox"], function() {
          jQuery5.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery5.inArray(jQuery5(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery5.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        support.focusin = "onfocusin" in window2;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
          e.stopPropagation();
        };
        jQuery5.extend(jQuery5.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery5.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery5.expando] ? event : new jQuery5.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery5.makeArray(data, [event]);
            special = jQuery5.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery5.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery5.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          simulate: function(type, elem, event) {
            var e = jQuery5.extend(
              new jQuery5.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery5.event.trigger(e, null, elem);
          }
        });
        jQuery5.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery5.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery5.event.trigger(type, data, elem, true);
            }
          }
        });
        if (!support.focusin) {
          jQuery5.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event) {
              jQuery5.event.simulate(fix, event.target, jQuery5.event.fix(event));
            };
            jQuery5.event.special[fix] = {
              setup: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) {
                  doc.addEventListener(orig, handler, true);
                }
                dataPriv.access(doc, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                  doc.removeEventListener(orig, handler, true);
                  dataPriv.remove(doc, fix);
                } else {
                  dataPriv.access(doc, fix, attaches);
                }
              }
            };
          });
        }
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery5.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery5.error("Invalid XML: " + (parserErrorElem ? jQuery5.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add) {
          var name;
          if (Array.isArray(obj)) {
            jQuery5.each(obj, function(i2, v) {
              if (traditional || rbracket.test(prefix)) {
                add(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i2 : "") + "]",
                  v,
                  traditional,
                  add
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
          } else {
            add(prefix, obj);
          }
        }
        jQuery5.param = function(a, traditional) {
          var prefix, s = [], add = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a == null) {
            return "";
          }
          if (Array.isArray(a) || a.jquery && !jQuery5.isPlainObject(a)) {
            jQuery5.each(a, function() {
              add(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add);
            }
          }
          return s.join("&");
        };
        jQuery5.fn.extend({
          serialize: function() {
            return jQuery5.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery5.prop(this, "elements");
              return elements ? jQuery5.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery5(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery5(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery5.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options2, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery5.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options2, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options2.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options2.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery5.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery5.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery5.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            converters: {
              "* text": String,
              "text html": true,
              "text json": JSON.parse,
              "text xml": jQuery5.parseXML
            },
            flatOptions: {
              url: true,
              context: true
            }
          },
          ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery5.ajaxSettings), settings) : ajaxExtend(jQuery5.ajaxSettings, target);
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          ajax: function(url, options2) {
            if (typeof url === "object") {
              options2 = url;
              url = void 0;
            }
            options2 = options2 || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s = jQuery5.ajaxSetup({}, options2), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery5(callbackContext) : jQuery5.event, deferred = jQuery5.Deferred(), completeDeferred = jQuery5.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              statusCode: function(map2) {
                var code;
                if (map2) {
                  if (completed2) {
                    jqXHR.always(map2[jqXHR.status]);
                  } else {
                    for (code in map2) {
                      statusCode[code] = [statusCode[code], map2[code]];
                    }
                  }
                }
                return this;
              },
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options2.method || options2.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery5.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options2, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery5.event && s.global;
            if (fireGlobals && jQuery5.active++ === 0) {
              jQuery5.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery5.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery5.lastModified[cacheURL]);
              }
              if (jQuery5.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery5.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options2.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i2 in s.headers) {
              jqXHR.setRequestHeader(i2, s.headers[i2]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options2, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (completed2) {
                  throw e;
                }
                done(-1, e);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery5.inArray("script", s.dataTypes) > -1 && jQuery5.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery5.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery5.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error = response.error;
                  isSuccess = !error;
                }
              } else {
                error = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery5.active) {
                  jQuery5.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery5.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery5.get(url, void 0, callback, "script");
          }
        });
        jQuery5.each(["get", "post"], function(_i, method) {
          jQuery5[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery5.ajax(jQuery5.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery5.isPlainObject(url) && url));
          };
        });
        jQuery5.ajaxPrefilter(function(s) {
          var i2;
          for (i2 in s.headers) {
            if (i2.toLowerCase() === "content-type") {
              s.contentType = s.headers[i2] || "";
            }
          }
        });
        jQuery5._evalUrl = function(url, options2, doc) {
          return jQuery5.ajax({
            url,
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery5.globalEval(response, options2, doc);
            }
          });
        };
        jQuery5.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery5(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i2) {
                jQuery5(this).wrapInner(html.call(this, i2));
              });
            }
            return this.each(function() {
              var self2 = jQuery5(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i2) {
              jQuery5(this).wrapAll(htmlIsFunction ? html.call(this, i2) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery5(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery5.expr.pseudos.hidden = function(elem) {
          return !jQuery5.expr.pseudos.visible(elem);
        };
        jQuery5.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery5.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrSuccessStatus = {
          0: 200,
          1223: 204
        }, xhrSupported = jQuery5.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery5.ajaxTransport(function(options2) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options2.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options2.xhr();
                xhr.open(
                  options2.type,
                  options2.url,
                  options2.async,
                  options2.username,
                  options2.password
                );
                if (options2.xhrFields) {
                  for (i2 in options2.xhrFields) {
                    xhr[i2] = options2.xhrFields[i2];
                  }
                }
                if (options2.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options2.mimeType);
                }
                if (!options2.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options2.hasContent && options2.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery5.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery5.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery5.globalEval(text);
              return text;
            }
          }
        });
        jQuery5.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery5.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery5("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery5.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery5.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery5.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery5.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery5(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery5.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery5(scripts).remove();
          }
          return jQuery5.merge([], parsed.childNodes);
        };
        jQuery5.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery5.ajax({
              url,
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? jQuery5("<div>").append(jQuery5.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery5.expr.pseudos.animated = function(elem) {
          return jQuery5.grep(jQuery5.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        jQuery5.offset = {
          setOffset: function(elem, options2, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery5.css(elem, "position"), curElem = jQuery5(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery5.css(elem, "top");
            curCSSLeft = jQuery5.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options2)) {
              options2 = options2.call(elem, i2, jQuery5.extend({}, curOffset));
            }
            if (options2.top != null) {
              props.top = options2.top - curOffset.top + curTop;
            }
            if (options2.left != null) {
              props.left = options2.left - curOffset.left + curLeft;
            }
            if ("using" in options2) {
              options2.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery5.fn.extend({
          offset: function(options2) {
            if (arguments.length) {
              return options2 === void 0 ? this : this.each(function(i2) {
                jQuery5.offset.setOffset(this, options2, i2);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery5.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery5.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery5(offsetParent).offset();
                parentOffset.top += jQuery5.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery5.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery5.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery5.css(elem, "marginLeft", true)
            };
          },
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery5.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery5.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery5.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery5.each(["top", "left"], function(_i, prop) {
          jQuery5.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery5(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery5.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery5.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery5.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? jQuery5.css(elem, type2, extra) : jQuery5.style(elem, type2, value2, extra);
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery5.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery5.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery5.fn.extend({
          bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
          },
          unbind: function(types, fn) {
            return this.off(types, null, fn);
          },
          delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
          },
          undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery5.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery5.fn[name] = function(data, fn) {
              return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery5.proxy = function(fn, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!isFunction(fn)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery5.guid++;
          return proxy;
        };
        jQuery5.holdReady = function(hold) {
          if (hold) {
            jQuery5.readyWait++;
          } else {
            jQuery5.ready(true);
          }
        };
        jQuery5.isArray = Array.isArray;
        jQuery5.parseJSON = JSON.parse;
        jQuery5.nodeName = nodeName;
        jQuery5.isFunction = isFunction;
        jQuery5.isWindow = isWindow;
        jQuery5.camelCase = camelCase;
        jQuery5.type = toType;
        jQuery5.now = Date.now;
        jQuery5.isNumeric = function(obj) {
          var type = jQuery5.type(obj);
          return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
        };
        jQuery5.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery5;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery5.noConflict = function(deep) {
          if (window2.$ === jQuery5) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery5) {
            window2.jQuery = _jQuery;
          }
          return jQuery5;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery5;
        }
        return jQuery5;
      });
    }
  });

  // node_modules/jqplot-exported/jqplot.core.js
  var require_jqplot_core = __commonJS({
    "node_modules/jqplot-exported/jqplot.core.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ColorGenerator = exports.EventListenerManager = exports.HooksManager = exports.GenericCanvas = exports.ElemContainer = exports.CanvasManager = undefined2;
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      exports.default = jqplot;
      exports.jqPlot = jqPlot;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var undefined2;
      _jquery2.default.fn.emptyForce = function() {
        for (var i2 = 0, elem; (elem = (0, _jquery2.default)(this)[i2]) != null; i2++) {
          if (elem.nodeType === 1) {
            _jquery2.default.cleanData(elem.getElementsByTagName("*"));
          }
          if (jqplot.use_excanvas) {
            elem.outerHTML = "";
          } else {
            while (elem.firstChild) {
              elem.removeChild(elem.firstChild);
            }
          }
          elem = null;
        }
        return (0, _jquery2.default)(this);
      };
      _jquery2.default.fn.removeChildForce = function(parent) {
        while (parent.firstChild) {
          this.removeChildForce(parent.firstChild);
          parent.removeChild(parent.firstChild);
        }
      };
      _jquery2.default.fn.jqplot = function() {
        var datas = [];
        var options2 = [];
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          if (_jquery2.default.isArray(arguments[i2])) {
            datas.push(arguments[i2]);
          } else if (_jquery2.default.isPlainObject(arguments[i2])) {
            options2.push(arguments[i2]);
          }
        }
        return this.each(function(index) {
          var tid, plot, $this = (0, _jquery2.default)(this), dl = datas.length, ol = options2.length, data, opts;
          if (index < dl) {
            data = datas[index];
          } else {
            data = dl ? datas[dl - 1] : null;
          }
          if (index < ol) {
            opts = options2[index];
          } else {
            opts = ol ? options2[ol - 1] : null;
          }
          tid = $this.attr("id");
          if (tid === undefined2) {
            tid = "jqplot_target_" + jqplot.targetCounter++;
            $this.attr("id", tid);
          }
          plot = jqplot(tid, data, opts);
          $this.data("./jqplot.core", plot);
        });
      };
      function jqplot(target, data, options2) {
        var _data = null, _options = null;
        if (arguments.length === 3) {
          _data = data;
          _options = options2;
        } else if (arguments.length === 2) {
          if (_jquery2.default.isArray(data)) {
            _data = data;
          } else if (_jquery2.default.isPlainObject(data)) {
            _options = data;
          }
        }
        if (_data === null && _options !== null && _options.data) {
          _data = _options.data;
        }
        var plot = new jqPlot();
        (0, _jquery2.default)("#" + target).removeClass("jqplot-error");
        if (jqplot.config.catchErrors) {
          try {
            plot.init(target, _data, _options);
            plot.draw();
            plot.themeEngine.init.call(plot);
            return plot;
          } catch (e) {
            var msg = jqplot.config.errorMessage || e.message;
            (0, _jquery2.default)("#" + target).append('<div class="jqplot-error-message">' + msg + "</div>");
            (0, _jquery2.default)("#" + target).addClass("jqplot-error");
            document.getElementById(target).style.background = jqplot.config.errorBackground;
            document.getElementById(target).style.border = jqplot.config.errorBorder;
            document.getElementById(target).style.fontFamily = jqplot.config.errorFontFamily;
            document.getElementById(target).style.fontSize = jqplot.config.errorFontSize;
            document.getElementById(target).style.fontStyle = jqplot.config.errorFontStyle;
            document.getElementById(target).style.fontWeight = jqplot.config.errorFontWeight;
          }
        } else {
          plot.init(target, _data, _options);
          plot.draw();
          plot.themeEngine.init.call(plot);
          return plot;
        }
      }
      jqplot.version = "@VERSION";
      jqplot.revision = "@REVISION";
      jqplot.targetCounter = 1;
      var CanvasManager = exports.CanvasManager = jqplot.CanvasManager = function() {
        if (typeof jqplot.CanvasManager.canvases == "undefined") {
          jqplot.CanvasManager.canvases = [];
          jqplot.CanvasManager.free = [];
        }
        var myCanvases = [];
        this.getCanvas = function() {
          var canvas;
          var makeNew = true;
          if (!jqplot.use_excanvas) {
            for (var i2 = 0, l = jqplot.CanvasManager.canvases.length; i2 < l; i2++) {
              if (jqplot.CanvasManager.free[i2] === true) {
                makeNew = false;
                canvas = jqplot.CanvasManager.canvases[i2];
                jqplot.CanvasManager.free[i2] = false;
                myCanvases.push(i2);
                break;
              }
            }
          }
          if (makeNew) {
            canvas = document.createElement("canvas");
            myCanvases.push(jqplot.CanvasManager.canvases.length);
            jqplot.CanvasManager.canvases.push(canvas);
            jqplot.CanvasManager.free.push(false);
          }
          return canvas;
        };
        this.initCanvas = function(canvas) {
          if (jqplot.use_excanvas) {
            return window.G_vmlCanvasManager.initElement(canvas);
          }
          var cctx = canvas.getContext("2d");
          var canvasBackingScale = 1;
          if (window.devicePixelRatio > 1 && (cctx.webkitBackingStorePixelRatio === undefined2 || cctx.webkitBackingStorePixelRatio < 2)) {
            canvasBackingScale = window.devicePixelRatio;
          }
          var oldWidth = canvas.width;
          var oldHeight = canvas.height;
          canvas.width = canvasBackingScale * canvas.width;
          canvas.height = canvasBackingScale * canvas.height;
          canvas.style.width = oldWidth + "px";
          canvas.style.height = oldHeight + "px";
          cctx.save();
          cctx.scale(canvasBackingScale, canvasBackingScale);
          return canvas;
        };
        this.freeAllCanvases = function() {
          for (var i2 = 0, l = myCanvases.length; i2 < l; i2++) {
            this.freeCanvas(myCanvases[i2]);
          }
          myCanvases = [];
        };
        this.freeCanvas = function(idx) {
          if (jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined2) {
            window.G_vmlCanvasManager.uninitElement(jqplot.CanvasManager.canvases[idx]);
            jqplot.CanvasManager.canvases[idx] = null;
          } else {
            var canvas = jqplot.CanvasManager.canvases[idx];
            canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
            (0, _jquery2.default)(canvas).unbind().removeAttr("class").removeAttr("style");
            (0, _jquery2.default)(canvas).css({ left: "", top: "", position: "" });
            canvas.width = 0;
            canvas.height = 0;
            jqplot.CanvasManager.free[idx] = true;
          }
        };
      };
      jqplot.log = function() {
        if (window.console) {
          window.console.log.apply(window.console, arguments);
        }
      };
      jqplot.config = {
        addDomReference: false,
        enablePlugins: false,
        defaultHeight: 300,
        defaultWidth: 400,
        UTCAdjust: false,
        timezoneOffset: new Date(new Date().getTimezoneOffset() * 6e4),
        errorMessage: "",
        errorBackground: "",
        errorBorder: "",
        errorFontFamily: "",
        errorFontSize: "",
        errorFontStyle: "",
        errorFontWeight: "",
        catchErrors: false,
        defaultTickFormatString: "%.1f",
        defaultColors: ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"],
        defaultNegativeColors: ["#498991", "#C08840", "#9F9274", "#546D61", "#646C4A", "#6F6621", "#6E3F5F", "#4F64B0", "#A89050", "#C45923", "#187399", "#945381", "#959E5C", "#C7AF7B", "#478396", "#907294"],
        dashLength: 4,
        gapLength: 4,
        dotGapLength: 2.5,
        srcLocation: "jqplot/src/",
        pluginLocation: "jqplot/src/plugins/"
      };
      jqplot.arrayMax = function(array) {
        return Math.max.apply(Math, array);
      };
      jqplot.arrayMin = function(array) {
        return Math.min.apply(Math, array);
      };
      jqplot.enablePlugins = jqplot.config.enablePlugins;
      jqplot.support_canvas = function() {
        if (typeof jqplot.support_canvas.result == "undefined") {
          jqplot.support_canvas.result = !!document.createElement("canvas").getContext;
        }
        return jqplot.support_canvas.result;
      };
      jqplot.support_canvas_text = function() {
        if (typeof jqplot.support_canvas_text.result == "undefined") {
          if (window.G_vmlCanvasManager !== undefined2 && window.G_vmlCanvasManager._version > 887) {
            jqplot.support_canvas_text.result = true;
          } else {
            jqplot.support_canvas_text.result = !!(document.createElement("canvas").getContext && typeof document.createElement("canvas").getContext("2d").fillText == "function");
          }
        }
        return jqplot.support_canvas_text.result;
      };
      jqplot.use_excanvas = (!_jquery2.default.support.boxModel || !_jquery2.default.support.objectAll || !$support.leadingWhitespace) && !jqplot.support_canvas() ? true : false;
      jqplot.preInitHooks = [];
      jqplot.postInitHooks = [];
      jqplot.preParseOptionsHooks = [];
      jqplot.postParseOptionsHooks = [];
      jqplot.preDrawHooks = [];
      jqplot.postDrawHooks = [];
      jqplot.preDrawSeriesHooks = [];
      jqplot.postDrawSeriesHooks = [];
      jqplot.preDrawLegendHooks = [];
      jqplot.addLegendRowHooks = [];
      jqplot.preSeriesInitHooks = [];
      jqplot.postSeriesInitHooks = [];
      jqplot.preParseSeriesOptionsHooks = [];
      jqplot.postParseSeriesOptionsHooks = [];
      jqplot.eventListenerHooks = [];
      jqplot.preDrawSeriesShadowHooks = [];
      jqplot.postDrawSeriesShadowHooks = [];
      var ElemContainer = exports.ElemContainer = jqplot.ElemContainer = function() {
        this._elem;
        this._plotWidth;
        this._plotHeight;
        this._plotDimensions = { height: null, width: null };
      };
      jqplot.ElemContainer.prototype.createElement = function(el, offsets, clss, cssopts, attrib) {
        this._offsets = offsets;
        var klass = clss || "./jqplot.core";
        var elem = document.createElement(el);
        this._elem = (0, _jquery2.default)(elem);
        this._elem.addClass(klass);
        this._elem.css(cssopts);
        this._elem.attr(attrib);
        elem = null;
        return this._elem;
      };
      jqplot.ElemContainer.prototype.getWidth = function() {
        if (this._elem) {
          return this._elem.outerWidth(true);
        } else {
          return null;
        }
      };
      jqplot.ElemContainer.prototype.getHeight = function() {
        if (this._elem) {
          return this._elem.outerHeight(true);
        } else {
          return null;
        }
      };
      jqplot.ElemContainer.prototype.getPosition = function() {
        if (this._elem) {
          return this._elem.position();
        } else {
          return { top: null, left: null, bottom: null, right: null };
        }
      };
      jqplot.ElemContainer.prototype.getTop = function() {
        return this.getPosition().top;
      };
      jqplot.ElemContainer.prototype.getLeft = function() {
        return this.getPosition().left;
      };
      jqplot.ElemContainer.prototype.getBottom = function() {
        return this._elem.css("bottom");
      };
      jqplot.ElemContainer.prototype.getRight = function() {
        return this._elem.css("right");
      };
      function Axis(name) {
        jqplot.ElemContainer.call(this);
        this.name = name;
        this._series = [];
        this.show = false;
        this.tickRenderer = jqplot.AxisTickRenderer;
        this.tickOptions = {};
        this.labelRenderer = jqplot.AxisLabelRenderer;
        this.labelOptions = {};
        this.label = null;
        this.showLabel = true;
        this.min = null;
        this.max = null;
        this.autoscale = false;
        this.pad = 1.2;
        this.padMax = null;
        this.padMin = null;
        this.ticks = [];
        this.numberTicks;
        this.tickInterval;
        this.renderer = jqplot.LinearAxisRenderer;
        this.rendererOptions = {};
        this.showTicks = true;
        this.showTickMarks = true;
        this.showMinorTicks = true;
        this.drawMajorGridlines = true;
        this.drawMinorGridlines = false;
        this.drawMajorTickMarks = true;
        this.drawMinorTickMarks = true;
        this.useSeriesColor = false;
        this.borderWidth = null;
        this.borderColor = null;
        this.scaleToHiddenSeries = false;
        this._dataBounds = { min: null, max: null };
        this._intervalStats = [];
        this._offsets = { min: null, max: null };
        this._ticks = [];
        this._label = null;
        this.syncTicks = null;
        this.tickSpacing = 75;
        this._min = null;
        this._max = null;
        this._tickInterval = null;
        this._numberTicks = null;
        this.__ticks = null;
        this._options = {};
      }
      Axis.prototype = new jqplot.ElemContainer();
      Axis.prototype.constructor = Axis;
      Axis.prototype.init = function() {
        if (_jquery2.default.isFunction(this.renderer)) {
          this.renderer = new this.renderer();
        }
        this.tickOptions.axis = this.name;
        if (this.tickOptions.showMark == null) {
          this.tickOptions.showMark = this.showTicks;
        }
        if (this.tickOptions.showMark == null) {
          this.tickOptions.showMark = this.showTickMarks;
        }
        if (this.tickOptions.showLabel == null) {
          this.tickOptions.showLabel = this.showTicks;
        }
        if (this.label == null || this.label == "") {
          this.showLabel = false;
        } else {
          this.labelOptions.label = this.label;
        }
        if (this.showLabel == false) {
          this.labelOptions.show = false;
        }
        if (this.pad == 0) {
          this.pad = 1;
        }
        if (this.padMax == 0) {
          this.padMax = 1;
        }
        if (this.padMin == 0) {
          this.padMin = 1;
        }
        if (this.padMax == null) {
          this.padMax = (this.pad - 1) / 2 + 1;
        }
        if (this.padMin == null) {
          this.padMin = (this.pad - 1) / 2 + 1;
        }
        this.pad = this.padMax + this.padMin - 1;
        if (this.min != null || this.max != null) {
          this.autoscale = false;
        }
        if (this.syncTicks == null && this.name.indexOf("y") > -1) {
          this.syncTicks = true;
        } else if (this.syncTicks == null) {
          this.syncTicks = false;
        }
        this.renderer.init.call(this, this.rendererOptions);
      };
      Axis.prototype.draw = function(ctx, plot) {
        if (this.__ticks) {
          this.__ticks = null;
        }
        return this.renderer.draw.call(this, ctx, plot);
      };
      Axis.prototype.set = function() {
        this.renderer.set.call(this);
      };
      Axis.prototype.pack = function(pos, offsets) {
        if (this.show) {
          this.renderer.pack.call(this, pos, offsets);
        }
        if (this._min == null) {
          this._min = this.min;
          this._max = this.max;
          this._tickInterval = this.tickInterval;
          this._numberTicks = this.numberTicks;
          this.__ticks = this._ticks;
        }
      };
      Axis.prototype.reset = function() {
        this.renderer.reset.call(this);
      };
      Axis.prototype.resetScale = function(opts) {
        _jquery2.default.extend(true, this, { min: null, max: null, numberTicks: null, tickInterval: null, _ticks: [], ticks: [] }, opts);
        this.resetDataBounds();
      };
      Axis.prototype.resetDataBounds = function() {
        var db = this._dataBounds;
        db.min = null;
        db.max = null;
        var l, s, d2;
        var doforce = this.show ? true : false;
        for (var i2 = 0; i2 < this._series.length; i2++) {
          s = this._series[i2];
          if (s.show || this.scaleToHiddenSeries) {
            d2 = s._plotData;
            if (s._type === "line" && s.renderer.bands.show && this.name.charAt(0) !== "x") {
              d2 = [[0, s.renderer.bands._min], [1, s.renderer.bands._max]];
            }
            var minyidx = 1, maxyidx = 1;
            if (s._type != null && s._type == "ohlc") {
              minyidx = 3;
              maxyidx = 2;
            }
            for (var j = 0, l = d2.length; j < l; j++) {
              if (this.name == "xaxis" || this.name == "x2axis") {
                if (d2[j][0] != null && d2[j][0] < db.min || db.min == null) {
                  db.min = d2[j][0];
                }
                if (d2[j][0] != null && d2[j][0] > db.max || db.max == null) {
                  db.max = d2[j][0];
                }
              } else {
                if (d2[j][minyidx] != null && d2[j][minyidx] < db.min || db.min == null) {
                  db.min = d2[j][minyidx];
                }
                if (d2[j][maxyidx] != null && d2[j][maxyidx] > db.max || db.max == null) {
                  db.max = d2[j][maxyidx];
                }
              }
            }
            if (doforce && s.renderer.constructor !== jqplot.BarRenderer) {
              doforce = false;
            } else if (doforce && this._options.hasOwnProperty("forceTickAt0") && this._options.forceTickAt0 == false) {
              doforce = false;
            } else if (doforce && s.renderer.constructor === jqplot.BarRenderer) {
              if (s.barDirection == "vertical" && this.name != "xaxis" && this.name != "x2axis") {
                if (this._options.pad != null || this._options.padMin != null) {
                  doforce = false;
                }
              } else if (s.barDirection == "horizontal" && (this.name == "xaxis" || this.name == "x2axis")) {
                if (this._options.pad != null || this._options.padMin != null) {
                  doforce = false;
                }
              }
            }
          }
        }
        if (doforce && this.renderer.constructor === jqplot.LinearAxisRenderer && db.min >= 0) {
          this.padMin = 1;
          this.forceTickAt0 = true;
        }
      };
      function Legend(options2) {
        jqplot.ElemContainer.call(this);
        this.show = false;
        this.location = "ne";
        this.labels = [];
        this.showLabels = true;
        this.showSwatches = true;
        this.placement = "insideGrid";
        this.xoffset = 0;
        this.yoffset = 0;
        this.border;
        this.background;
        this.textColor;
        this.fontFamily;
        this.fontSize;
        this.rowSpacing = "0.5em";
        this.renderer = jqplot.TableLegendRenderer;
        this.rendererOptions = {};
        this.preDraw = false;
        this.marginTop = null;
        this.marginRight = null;
        this.marginBottom = null;
        this.marginLeft = null;
        this.escapeHtml = false;
        this._series = [];
        _jquery2.default.extend(true, this, options2);
      }
      Legend.prototype = new jqplot.ElemContainer();
      Legend.prototype.constructor = Legend;
      Legend.prototype.setOptions = function(options2) {
        _jquery2.default.extend(true, this, options2);
        if (this.placement == "inside") {
          this.placement = "insideGrid";
        }
        if (this.xoffset > 0) {
          if (this.placement == "insideGrid") {
            switch (this.location) {
              case "nw":
              case "w":
              case "sw":
                if (this.marginLeft == null) {
                  this.marginLeft = this.xoffset + "px";
                }
                this.marginRight = "0px";
                break;
              case "ne":
              case "e":
              case "se":
              default:
                if (this.marginRight == null) {
                  this.marginRight = this.xoffset + "px";
                }
                this.marginLeft = "0px";
                break;
            }
          } else if (this.placement == "outside") {
            switch (this.location) {
              case "nw":
              case "w":
              case "sw":
                if (this.marginRight == null) {
                  this.marginRight = this.xoffset + "px";
                }
                this.marginLeft = "0px";
                break;
              case "ne":
              case "e":
              case "se":
              default:
                if (this.marginLeft == null) {
                  this.marginLeft = this.xoffset + "px";
                }
                this.marginRight = "0px";
                break;
            }
          }
          this.xoffset = 0;
        }
        if (this.yoffset > 0) {
          if (this.placement == "outside") {
            switch (this.location) {
              case "sw":
              case "s":
              case "se":
                if (this.marginTop == null) {
                  this.marginTop = this.yoffset + "px";
                }
                this.marginBottom = "0px";
                break;
              case "ne":
              case "n":
              case "nw":
              default:
                if (this.marginBottom == null) {
                  this.marginBottom = this.yoffset + "px";
                }
                this.marginTop = "0px";
                break;
            }
          } else if (this.placement == "insideGrid") {
            switch (this.location) {
              case "sw":
              case "s":
              case "se":
                if (this.marginBottom == null) {
                  this.marginBottom = this.yoffset + "px";
                }
                this.marginTop = "0px";
                break;
              case "ne":
              case "n":
              case "nw":
              default:
                if (this.marginTop == null) {
                  this.marginTop = this.yoffset + "px";
                }
                this.marginBottom = "0px";
                break;
            }
          }
          this.yoffset = 0;
        }
      };
      Legend.prototype.init = function() {
        if (_jquery2.default.isFunction(this.renderer)) {
          this.renderer = new this.renderer();
        }
        this.renderer.init.call(this, this.rendererOptions);
      };
      Legend.prototype.draw = function(offsets, plot) {
        for (var i2 = 0; i2 < jqplot.preDrawLegendHooks.length; i2++) {
          jqplot.preDrawLegendHooks[i2].call(this, offsets);
        }
        return this.renderer.draw.call(this, offsets, plot);
      };
      Legend.prototype.pack = function(offsets) {
        this.renderer.pack.call(this, offsets);
      };
      function Title(text) {
        jqplot.ElemContainer.call(this);
        this.text = text;
        this.show = true;
        this.fontFamily;
        this.fontSize;
        this.textAlign;
        this.textColor;
        this.renderer = jqplot.DivTitleRenderer;
        this.rendererOptions = {};
        this.escapeHtml = false;
      }
      Title.prototype = new jqplot.ElemContainer();
      Title.prototype.constructor = Title;
      Title.prototype.init = function() {
        if (_jquery2.default.isFunction(this.renderer)) {
          this.renderer = new this.renderer();
        }
        this.renderer.init.call(this, this.rendererOptions);
      };
      Title.prototype.draw = function(width) {
        return this.renderer.draw.call(this, width);
      };
      Title.prototype.pack = function() {
        this.renderer.pack.call(this);
      };
      function Series(options2) {
        options2 = options2 || {};
        jqplot.ElemContainer.call(this);
        this.show = true;
        this.xaxis = "xaxis";
        this._xaxis;
        this.yaxis = "yaxis";
        this._yaxis;
        this.gridBorderWidth = 2;
        this.renderer = jqplot.LineRenderer;
        this.rendererOptions = {};
        this.data = [];
        this.gridData = [];
        this.label = "";
        this.showLabel = true;
        this.color;
        this.negativeColor;
        this.lineWidth = 2.5;
        this.lineJoin = "round";
        this.lineCap = "round";
        this.linePattern = "solid";
        this.shadow = true;
        this.shadowAngle = 45;
        this.shadowOffset = 1.25;
        this.shadowDepth = 3;
        this.shadowAlpha = "0.1";
        this.breakOnNull = false;
        this.markerRenderer = jqplot.MarkerRenderer;
        this.markerOptions = {};
        this.showLine = true;
        this.showMarker = true;
        this.index;
        this.fill = false;
        this.fillColor;
        this.fillAlpha;
        this.fillAndStroke = false;
        this.disableStack = false;
        this._stack = false;
        this.neighborThreshold = 4;
        this.fillToZero = false;
        this.fillToValue = 0;
        this.fillAxis = "y";
        this.useNegativeColors = true;
        this._stackData = [];
        this._plotData = [];
        this._plotValues = { x: [], y: [] };
        this._intervals = { x: {}, y: {} };
        this._prevPlotData = [];
        this._prevGridData = [];
        this._stackAxis = "y";
        this._primaryAxis = "_xaxis";
        this.canvas = new jqplot.GenericCanvas();
        this.shadowCanvas = new jqplot.GenericCanvas();
        this.plugins = {};
        this._sumy = 0;
        this._sumx = 0;
        this._type = "";
        this.step = false;
      }
      Series.prototype = new jqplot.ElemContainer();
      Series.prototype.constructor = Series;
      Series.prototype.init = function(index, gridbw, plot) {
        this.index = index;
        this.gridBorderWidth = gridbw;
        var d2 = this.data;
        var temp = [], i2, l;
        for (i2 = 0, l = d2.length; i2 < l; i2++) {
          if (!this.breakOnNull) {
            if (d2[i2] == null || d2[i2][0] == null || d2[i2][1] == null) {
              continue;
            } else {
              temp.push(d2[i2]);
            }
          } else {
            temp.push(d2[i2]);
          }
        }
        this.data = temp;
        if (!this.color) {
          this.color = plot.colorGenerator.get(this.index);
        }
        if (!this.negativeColor) {
          this.negativeColor = plot.negativeColorGenerator.get(this.index);
        }
        if (!this.fillColor) {
          this.fillColor = this.color;
        }
        if (this.fillAlpha) {
          var comp = jqplot.normalize2rgb(this.fillColor);
          var comp = jqplot.getColorComponents(comp);
          this.fillColor = "rgba(" + comp[0] + "," + comp[1] + "," + comp[2] + "," + this.fillAlpha + ")";
        }
        if (_jquery2.default.isFunction(this.renderer)) {
          this.renderer = new this.renderer();
        }
        this.renderer.init.call(this, this.rendererOptions, plot);
        this.markerRenderer = new this.markerRenderer();
        if (!this.markerOptions.color) {
          this.markerOptions.color = this.color;
        }
        if (this.markerOptions.show == null) {
          this.markerOptions.show = this.showMarker;
        }
        this.showMarker = this.markerOptions.show;
        this.markerRenderer.init(this.markerOptions);
      };
      Series.prototype.draw = function(sctx, opts, plot) {
        var options2 = opts == undefined2 ? {} : opts;
        sctx = sctx == undefined2 ? this.canvas._ctx : sctx;
        var j, data, gridData;
        for (j = 0; j < jqplot.preDrawSeriesHooks.length; j++) {
          jqplot.preDrawSeriesHooks[j].call(this, sctx, options2);
        }
        if (this.show) {
          this.renderer.setGridData.call(this, plot);
          if (!options2.preventJqPlotSeriesDrawTrigger) {
            (0, _jquery2.default)(sctx.canvas).trigger("jqplotSeriesDraw", [this.data, this.gridData]);
          }
          data = [];
          if (options2.data) {
            data = options2.data;
          } else if (!this._stack) {
            data = this.data;
          } else {
            data = this._plotData;
          }
          gridData = options2.gridData || this.renderer.makeGridData.call(this, data, plot);
          if (this._type === "line" && this.renderer.smooth && this.renderer._smoothedData.length) {
            gridData = this.renderer._smoothedData;
          }
          this.renderer.draw.call(this, sctx, gridData, options2, plot);
        }
        for (j = 0; j < jqplot.postDrawSeriesHooks.length; j++) {
          jqplot.postDrawSeriesHooks[j].call(this, sctx, options2, plot);
        }
        sctx = opts = plot = j = data = gridData = null;
      };
      Series.prototype.drawShadow = function(sctx, opts, plot) {
        var options2 = opts == undefined2 ? {} : opts;
        sctx = sctx == undefined2 ? this.shadowCanvas._ctx : sctx;
        var j, data, gridData;
        for (j = 0; j < jqplot.preDrawSeriesShadowHooks.length; j++) {
          jqplot.preDrawSeriesShadowHooks[j].call(this, sctx, options2);
        }
        if (this.shadow) {
          this.renderer.setGridData.call(this, plot);
          data = [];
          if (options2.data) {
            data = options2.data;
          } else if (!this._stack) {
            data = this.data;
          } else {
            data = this._plotData;
          }
          gridData = options2.gridData || this.renderer.makeGridData.call(this, data, plot);
          this.renderer.drawShadow.call(this, sctx, gridData, options2, plot);
        }
        for (j = 0; j < jqplot.postDrawSeriesShadowHooks.length; j++) {
          jqplot.postDrawSeriesShadowHooks[j].call(this, sctx, options2);
        }
        sctx = opts = plot = j = data = gridData = null;
      };
      Series.prototype.toggleDisplay = function(ev, callback) {
        var s, speed;
        if (ev.data.series) {
          s = ev.data.series;
        } else {
          s = this;
        }
        if (ev.data.speed) {
          speed = ev.data.speed;
        }
        if (speed) {
          if (s.canvas._elem.is(":hidden") || !s.show) {
            s.show = true;
            s.canvas._elem.removeClass("jqplot-series-hidden");
            if (s.shadowCanvas._elem) {
              s.shadowCanvas._elem.fadeIn(speed);
            }
            s.canvas._elem.fadeIn(speed, callback);
            s.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + s.index).fadeIn(speed);
          } else {
            s.show = false;
            s.canvas._elem.addClass("jqplot-series-hidden");
            if (s.shadowCanvas._elem) {
              s.shadowCanvas._elem.fadeOut(speed);
            }
            s.canvas._elem.fadeOut(speed, callback);
            s.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + s.index).fadeOut(speed);
          }
        } else {
          if (s.canvas._elem.is(":hidden") || !s.show) {
            s.show = true;
            s.canvas._elem.removeClass("jqplot-series-hidden");
            if (s.shadowCanvas._elem) {
              s.shadowCanvas._elem.show();
            }
            s.canvas._elem.show(0, callback);
            s.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + s.index).show();
          } else {
            s.show = false;
            s.canvas._elem.addClass("jqplot-series-hidden");
            if (s.shadowCanvas._elem) {
              s.shadowCanvas._elem.hide();
            }
            s.canvas._elem.hide(0, callback);
            s.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + s.index).hide();
          }
        }
      };
      function Grid() {
        jqplot.ElemContainer.call(this);
        this.drawGridlines = true;
        this.gridLineColor = "#cccccc";
        this.gridLineWidth = 1;
        this.background = "#fffdf6";
        this.borderColor = "#999999";
        this.borderWidth = 2;
        this.drawBorder = true;
        this.shadow = true;
        this.shadowAngle = 45;
        this.shadowOffset = 1.5;
        this.shadowWidth = 3;
        this.shadowDepth = 3;
        this.shadowColor = null;
        this.shadowAlpha = "0.07";
        this._left;
        this._top;
        this._right;
        this._bottom;
        this._width;
        this._height;
        this._axes = [];
        this.renderer = jqplot.CanvasGridRenderer;
        this.rendererOptions = {};
        this._offsets = { top: null, bottom: null, left: null, right: null };
      }
      Grid.prototype = new jqplot.ElemContainer();
      Grid.prototype.constructor = Grid;
      Grid.prototype.init = function() {
        if (_jquery2.default.isFunction(this.renderer)) {
          this.renderer = new this.renderer();
        }
        this.renderer.init.call(this, this.rendererOptions);
      };
      Grid.prototype.createElement = function(offsets, plot) {
        this._offsets = offsets;
        return this.renderer.createElement.call(this, plot);
      };
      Grid.prototype.draw = function() {
        this.renderer.draw.call(this);
      };
      var GenericCanvas = exports.GenericCanvas = jqplot.GenericCanvas = function() {
        jqplot.ElemContainer.call(this);
        this._ctx;
      };
      jqplot.GenericCanvas.prototype = new jqplot.ElemContainer();
      jqplot.GenericCanvas.prototype.constructor = jqplot.GenericCanvas;
      jqplot.GenericCanvas.prototype.createElement = function(offsets, clss, plotDimensions, plot) {
        this._offsets = offsets;
        var klass = "./jqplot.core";
        if (clss != undefined2) {
          klass = clss;
        }
        var elem;
        elem = plot.canvasManager.getCanvas();
        if (plotDimensions != null) {
          this._plotDimensions = plotDimensions;
        }
        elem.width = this._plotDimensions.width - this._offsets.left - this._offsets.right;
        elem.height = this._plotDimensions.height - this._offsets.top - this._offsets.bottom;
        this._elem = (0, _jquery2.default)(elem);
        this._elem.css({ position: "absolute", left: this._offsets.left, top: this._offsets.top });
        this._elem.addClass(klass);
        elem = plot.canvasManager.initCanvas(elem);
        elem = null;
        return this._elem;
      };
      jqplot.GenericCanvas.prototype.setContext = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        return this._ctx;
      };
      jqplot.GenericCanvas.prototype.resetCanvas = function() {
        if (this._elem) {
          if (jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined2) {
            window.G_vmlCanvasManager.uninitElement(this._elem.get(0));
          }
          this._elem.emptyForce();
        }
        this._ctx = null;
      };
      var HooksManager = exports.HooksManager = jqplot.HooksManager = function() {
        this.hooks = [];
        this.args = [];
      };
      jqplot.HooksManager.prototype.addOnce = function(fn, args) {
        args = args || [];
        var havehook = false;
        for (var i2 = 0, l = this.hooks.length; i2 < l; i2++) {
          if (this.hooks[i2] == fn) {
            havehook = true;
          }
        }
        if (!havehook) {
          this.hooks.push(fn);
          this.args.push(args);
        }
      };
      jqplot.HooksManager.prototype.add = function(fn, args) {
        args = args || [];
        this.hooks.push(fn);
        this.args.push(args);
      };
      var EventListenerManager = exports.EventListenerManager = jqplot.EventListenerManager = function() {
        this.hooks = [];
      };
      jqplot.EventListenerManager.prototype.addOnce = function(ev, fn) {
        var havehook = false, h, i2;
        for (var i2 = 0, l = this.hooks.length; i2 < l; i2++) {
          h = this.hooks[i2];
          if (h[0] == ev && h[1] == fn) {
            havehook = true;
          }
        }
        if (!havehook) {
          this.hooks.push([ev, fn]);
        }
      };
      jqplot.EventListenerManager.prototype.add = function(ev, fn) {
        this.hooks.push([ev, fn]);
      };
      var _axisNames = ["yMidAxis", "xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis"];
      function jqPlot() {
        this.animate = false;
        this.animateReplot = false;
        this.axes = { xaxis: new Axis("xaxis"), yaxis: new Axis("yaxis"), x2axis: new Axis("x2axis"), y2axis: new Axis("y2axis"), y3axis: new Axis("y3axis"), y4axis: new Axis("y4axis"), y5axis: new Axis("y5axis"), y6axis: new Axis("y6axis"), y7axis: new Axis("y7axis"), y8axis: new Axis("y8axis"), y9axis: new Axis("y9axis"), yMidAxis: new Axis("yMidAxis") };
        this.baseCanvas = new jqplot.GenericCanvas();
        this.captureRightClick = false;
        this.data = [];
        this.dataRenderer;
        this.dataRendererOptions;
        this.defaults = {
          axesDefaults: {},
          axes: { xaxis: {}, yaxis: {}, x2axis: {}, y2axis: {}, y3axis: {}, y4axis: {}, y5axis: {}, y6axis: {}, y7axis: {}, y8axis: {}, y9axis: {}, yMidAxis: {} },
          seriesDefaults: {},
          series: []
        };
        this.defaultAxisStart = 1;
        this.drawIfHidden = false;
        this.eventCanvas = new jqplot.GenericCanvas();
        this.fillBetween = {
          series1: null,
          series2: null,
          color: null,
          baseSeries: 0,
          fill: true
        };
        this.fontFamily;
        this.fontSize;
        this.grid = new Grid();
        this.legend = new Legend();
        this.noDataIndicator = {
          show: false,
          indicator: "Loading Data...",
          axes: {
            xaxis: {
              min: 0,
              max: 10,
              tickInterval: 2,
              show: true
            },
            yaxis: {
              min: 0,
              max: 12,
              tickInterval: 3,
              show: true
            }
          }
        };
        this.negativeSeriesColors = jqplot.config.defaultNegativeColors;
        this.options = {};
        this.previousSeriesStack = [];
        this.plugins = {};
        this.series = [];
        this.seriesStack = [];
        this.seriesColors = jqplot.config.defaultColors;
        this.sortData = true;
        this.stackSeries = false;
        this.syncXTicks = true;
        this.syncYTicks = true;
        this.target = null;
        this.targetId = null;
        this.textColor;
        this.title = new Title();
        this._drawCount = 0;
        this._sumy = 0;
        this._sumx = 0;
        this._stackData = [];
        this._plotData = [];
        this._width = null;
        this._height = null;
        this._plotDimensions = { height: null, width: null };
        this._gridPadding = { top: null, right: null, bottom: null, left: null };
        this._defaultGridPadding = { top: 10, right: 10, bottom: 23, left: 10 };
        this._addDomReference = jqplot.config.addDomReference;
        this.preInitHooks = new jqplot.HooksManager();
        this.postInitHooks = new jqplot.HooksManager();
        this.preParseOptionsHooks = new jqplot.HooksManager();
        this.postParseOptionsHooks = new jqplot.HooksManager();
        this.preDrawHooks = new jqplot.HooksManager();
        this.postDrawHooks = new jqplot.HooksManager();
        this.preDrawSeriesHooks = new jqplot.HooksManager();
        this.postDrawSeriesHooks = new jqplot.HooksManager();
        this.preDrawLegendHooks = new jqplot.HooksManager();
        this.addLegendRowHooks = new jqplot.HooksManager();
        this.preSeriesInitHooks = new jqplot.HooksManager();
        this.postSeriesInitHooks = new jqplot.HooksManager();
        this.preParseSeriesOptionsHooks = new jqplot.HooksManager();
        this.postParseSeriesOptionsHooks = new jqplot.HooksManager();
        this.eventListenerHooks = new jqplot.EventListenerManager();
        this.preDrawSeriesShadowHooks = new jqplot.HooksManager();
        this.postDrawSeriesShadowHooks = new jqplot.HooksManager();
        this.colorGenerator = new jqplot.ColorGenerator();
        this.negativeColorGenerator = new jqplot.ColorGenerator();
        this.canvasManager = new jqplot.CanvasManager();
        this.themeEngine = new jqplot.ThemeEngine();
        var seriesColorsIndex = 0;
        this.init = function(target, data, options2) {
          options2 = options2 || {};
          for (var i2 = 0; i2 < jqplot.preInitHooks.length; i2++) {
            jqplot.preInitHooks[i2].call(this, target, data, options2);
          }
          for (var i2 = 0; i2 < this.preInitHooks.hooks.length; i2++) {
            this.preInitHooks.hooks[i2].call(this, target, data, options2);
          }
          this.targetId = "#" + target;
          this.target = (0, _jquery2.default)("#" + target);
          if (this._addDomReference) {
            this.target.data("./jqplot.core", this);
          }
          this.target.removeClass("jqplot-error");
          if (!this.target.get(0)) {
            throw new Error("No plot target specified");
          }
          if (this.target.css("position") == "static") {
            this.target.css("position", "relative");
          }
          if (!this.target.hasClass("jqplot-target")) {
            this.target.addClass("jqplot-target");
          }
          if (!this.target.height()) {
            var h;
            if (options2 && options2.height) {
              h = parseInt(options2.height, 10);
            } else if (this.target.attr("data-height")) {
              h = parseInt(this.target.attr("data-height"), 10);
            } else {
              h = parseInt(jqplot.config.defaultHeight, 10);
            }
            this._height = h;
            this.target.css("height", h + "px");
          } else {
            this._height = h = this.target.height();
          }
          if (!this.target.width()) {
            var w;
            if (options2 && options2.width) {
              w = parseInt(options2.width, 10);
            } else if (this.target.attr("data-width")) {
              w = parseInt(this.target.attr("data-width"), 10);
            } else {
              w = parseInt(jqplot.config.defaultWidth, 10);
            }
            this._width = w;
            this.target.css("width", w + "px");
          } else {
            this._width = w = this.target.width();
          }
          for (var i2 = 0, l = _axisNames.length; i2 < l; i2++) {
            this.axes[_axisNames[i2]] = new Axis(_axisNames[i2]);
          }
          this._plotDimensions.height = this._height;
          this._plotDimensions.width = this._width;
          this.grid._plotDimensions = this._plotDimensions;
          this.title._plotDimensions = this._plotDimensions;
          this.baseCanvas._plotDimensions = this._plotDimensions;
          this.eventCanvas._plotDimensions = this._plotDimensions;
          this.legend._plotDimensions = this._plotDimensions;
          if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) {
            throw new Error("Canvas dimension not set");
          }
          if (options2.dataRenderer && _jquery2.default.isFunction(options2.dataRenderer)) {
            if (options2.dataRendererOptions) {
              this.dataRendererOptions = options2.dataRendererOptions;
            }
            this.dataRenderer = options2.dataRenderer;
            data = this.dataRenderer(data, this, this.dataRendererOptions);
          }
          if (options2.noDataIndicator && _jquery2.default.isPlainObject(options2.noDataIndicator)) {
            _jquery2.default.extend(true, this.noDataIndicator, options2.noDataIndicator);
          }
          if (data == null || _jquery2.default.isArray(data) == false || data.length == 0 || _jquery2.default.isArray(data[0]) == false || data[0].length == 0) {
            if (this.noDataIndicator.show == false) {
              throw new Error("No data specified");
            } else {
              for (var ax in this.noDataIndicator.axes) {
                for (var prop in this.noDataIndicator.axes[ax]) {
                  this.axes[ax][prop] = this.noDataIndicator.axes[ax][prop];
                }
              }
              this.postDrawHooks.add(function() {
                var eh = this.eventCanvas.getHeight();
                var ew = this.eventCanvas.getWidth();
                var temp = (0, _jquery2.default)('<div class="jqplot-noData-container" style="position:absolute;"></div>');
                this.target.append(temp);
                temp.height(eh);
                temp.width(ew);
                temp.css("top", this.eventCanvas._offsets.top);
                temp.css("left", this.eventCanvas._offsets.left);
                var temp2 = (0, _jquery2.default)('<div class="jqplot-noData-contents" style="text-align:center; position:relative; margin-left:auto; margin-right:auto;"></div>');
                temp.append(temp2);
                temp2.html(this.noDataIndicator.indicator);
                var th = temp2.height();
                var tw = temp2.width();
                temp2.height(th);
                temp2.width(tw);
                temp2.css("top", (eh - th) / 2 + "px");
              });
            }
          }
          this.data = _jquery2.default.extend(true, [], data);
          this.parseOptions(options2);
          if (this.textColor) {
            this.target.css("color", this.textColor);
          }
          if (this.fontFamily) {
            this.target.css("font-family", this.fontFamily);
          }
          if (this.fontSize) {
            this.target.css("font-size", this.fontSize);
          }
          this.title.init();
          this.legend.init();
          this._sumy = 0;
          this._sumx = 0;
          this.computePlotData();
          for (var i2 = 0; i2 < this.series.length; i2++) {
            this.seriesStack.push(i2);
            this.previousSeriesStack.push(i2);
            this.series[i2].shadowCanvas._plotDimensions = this._plotDimensions;
            this.series[i2].canvas._plotDimensions = this._plotDimensions;
            for (var j = 0; j < jqplot.preSeriesInitHooks.length; j++) {
              jqplot.preSeriesInitHooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            for (var j = 0; j < this.preSeriesInitHooks.hooks.length; j++) {
              this.preSeriesInitHooks.hooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            this.series[i2]._plotDimensions = this._plotDimensions;
            this.series[i2].init(i2, this.grid.borderWidth, this);
            for (var j = 0; j < jqplot.postSeriesInitHooks.length; j++) {
              jqplot.postSeriesInitHooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            for (var j = 0; j < this.postSeriesInitHooks.hooks.length; j++) {
              this.postSeriesInitHooks.hooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            this._sumy += this.series[i2]._sumy;
            this._sumx += this.series[i2]._sumx;
          }
          var name, axis;
          for (var i2 = 0, l = _axisNames.length; i2 < l; i2++) {
            name = _axisNames[i2];
            axis = this.axes[name];
            axis._plotDimensions = this._plotDimensions;
            axis.init();
            if (this.axes[name].borderColor == null) {
              if (name.charAt(0) !== "x" && axis.useSeriesColor === true && axis.show) {
                axis.borderColor = axis._series[0].color;
              } else {
                axis.borderColor = this.grid.borderColor;
              }
            }
          }
          if (this.sortData) {
            sortData(this.series);
          }
          this.grid.init();
          this.grid._axes = this.axes;
          this.legend._series = this.series;
          for (var i2 = 0; i2 < jqplot.postInitHooks.length; i2++) {
            jqplot.postInitHooks[i2].call(this, target, this.data, options2);
          }
          for (var i2 = 0; i2 < this.postInitHooks.hooks.length; i2++) {
            this.postInitHooks.hooks[i2].call(this, target, this.data, options2);
          }
        };
        this.resetAxesScale = function(axes, options2) {
          var opts = options2 || {};
          var ax = axes || this.axes;
          if (ax === true) {
            ax = this.axes;
          }
          if (_jquery2.default.isArray(ax)) {
            for (var i2 = 0; i2 < ax.length; i2++) {
              this.axes[ax[i2]].resetScale(opts[ax[i2]]);
            }
          } else if ((typeof ax === "undefined" ? "undefined" : _typeof(ax)) === "object") {
            for (var name in ax) {
              this.axes[name].resetScale(opts[name]);
            }
          }
        };
        this.reInitialize = function(data, opts) {
          var options2 = _jquery2.default.extend(true, {}, this.options, opts);
          var target = this.targetId.substr(1);
          var tdata = data == null ? this.data : data;
          for (var i2 = 0; i2 < jqplot.preInitHooks.length; i2++) {
            jqplot.preInitHooks[i2].call(this, target, tdata, options2);
          }
          for (var i2 = 0; i2 < this.preInitHooks.hooks.length; i2++) {
            this.preInitHooks.hooks[i2].call(this, target, tdata, options2);
          }
          this._height = this.target.height();
          this._width = this.target.width();
          if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) {
            throw new Error("Target dimension not set");
          }
          this._plotDimensions.height = this._height;
          this._plotDimensions.width = this._width;
          this.grid._plotDimensions = this._plotDimensions;
          this.title._plotDimensions = this._plotDimensions;
          this.baseCanvas._plotDimensions = this._plotDimensions;
          this.eventCanvas._plotDimensions = this._plotDimensions;
          this.legend._plotDimensions = this._plotDimensions;
          var name, t, j, axis;
          for (var i2 = 0, l = _axisNames.length; i2 < l; i2++) {
            name = _axisNames[i2];
            axis = this.axes[name];
            t = axis._ticks;
            for (var j = 0, tlen = t.length; j < tlen; j++) {
              var el = t[j]._elem;
              if (el) {
                if (jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined2) {
                  window.G_vmlCanvasManager.uninitElement(el.get(0));
                }
                el.emptyForce();
                el = null;
                t._elem = null;
              }
            }
            t = null;
            delete axis.ticks;
            delete axis._ticks;
            this.axes[name] = new Axis(name);
            this.axes[name]._plotWidth = this._width;
            this.axes[name]._plotHeight = this._height;
          }
          if (data) {
            if (options2.dataRenderer && _jquery2.default.isFunction(options2.dataRenderer)) {
              if (options2.dataRendererOptions) {
                this.dataRendererOptions = options2.dataRendererOptions;
              }
              this.dataRenderer = options2.dataRenderer;
              data = this.dataRenderer(data, this, this.dataRendererOptions);
            }
            this.data = _jquery2.default.extend(true, [], data);
          }
          if (opts) {
            this.parseOptions(options2);
          }
          this.title._plotWidth = this._width;
          if (this.textColor) {
            this.target.css("color", this.textColor);
          }
          if (this.fontFamily) {
            this.target.css("font-family", this.fontFamily);
          }
          if (this.fontSize) {
            this.target.css("font-size", this.fontSize);
          }
          this.title.init();
          this.legend.init();
          this._sumy = 0;
          this._sumx = 0;
          this.seriesStack = [];
          this.previousSeriesStack = [];
          this.computePlotData();
          for (var i2 = 0, l = this.series.length; i2 < l; i2++) {
            this.seriesStack.push(i2);
            this.previousSeriesStack.push(i2);
            this.series[i2].shadowCanvas._plotDimensions = this._plotDimensions;
            this.series[i2].canvas._plotDimensions = this._plotDimensions;
            for (var j = 0; j < jqplot.preSeriesInitHooks.length; j++) {
              jqplot.preSeriesInitHooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            for (var j = 0; j < this.preSeriesInitHooks.hooks.length; j++) {
              this.preSeriesInitHooks.hooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            this.series[i2]._plotDimensions = this._plotDimensions;
            this.series[i2].init(i2, this.grid.borderWidth, this);
            for (var j = 0; j < jqplot.postSeriesInitHooks.length; j++) {
              jqplot.postSeriesInitHooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            for (var j = 0; j < this.postSeriesInitHooks.hooks.length; j++) {
              this.postSeriesInitHooks.hooks[j].call(this.series[i2], target, this.data, this.options.seriesDefaults, this.options.series[i2], this);
            }
            this._sumy += this.series[i2]._sumy;
            this._sumx += this.series[i2]._sumx;
          }
          for (var i2 = 0, l = _axisNames.length; i2 < l; i2++) {
            name = _axisNames[i2];
            axis = this.axes[name];
            axis._plotDimensions = this._plotDimensions;
            axis.init();
            if (axis.borderColor == null) {
              if (name.charAt(0) !== "x" && axis.useSeriesColor === true && axis.show) {
                axis.borderColor = axis._series[0].color;
              } else {
                axis.borderColor = this.grid.borderColor;
              }
            }
          }
          if (this.sortData) {
            sortData(this.series);
          }
          this.grid.init();
          this.grid._axes = this.axes;
          this.legend._series = this.series;
          for (var i2 = 0, l = jqplot.postInitHooks.length; i2 < l; i2++) {
            jqplot.postInitHooks[i2].call(this, target, this.data, options2);
          }
          for (var i2 = 0, l = this.postInitHooks.hooks.length; i2 < l; i2++) {
            this.postInitHooks.hooks[i2].call(this, target, this.data, options2);
          }
        };
        this.quickInit = function() {
          this._height = this.target.height();
          this._width = this.target.width();
          if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) {
            throw new Error("Target dimension not set");
          }
          this._plotDimensions.height = this._height;
          this._plotDimensions.width = this._width;
          this.grid._plotDimensions = this._plotDimensions;
          this.title._plotDimensions = this._plotDimensions;
          this.baseCanvas._plotDimensions = this._plotDimensions;
          this.eventCanvas._plotDimensions = this._plotDimensions;
          this.legend._plotDimensions = this._plotDimensions;
          for (var n in this.axes) {
            this.axes[n]._plotWidth = this._width;
            this.axes[n]._plotHeight = this._height;
          }
          this.title._plotWidth = this._width;
          if (this.textColor) {
            this.target.css("color", this.textColor);
          }
          if (this.fontFamily) {
            this.target.css("font-family", this.fontFamily);
          }
          if (this.fontSize) {
            this.target.css("font-size", this.fontSize);
          }
          this._sumy = 0;
          this._sumx = 0;
          this.computePlotData();
          for (var i2 = 0; i2 < this.series.length; i2++) {
            if (this.series[i2]._type === "line" && this.series[i2].renderer.bands.show) {
              this.series[i2].renderer.initBands.call(this.series[i2], this.series[i2].renderer.options, this);
            }
            this.series[i2]._plotDimensions = this._plotDimensions;
            this.series[i2].canvas._plotDimensions = this._plotDimensions;
            this._sumy += this.series[i2]._sumy;
            this._sumx += this.series[i2]._sumx;
          }
          var name;
          for (var j = 0; j < 12; j++) {
            name = _axisNames[j];
            var t = this.axes[name]._ticks;
            for (var i2 = 0; i2 < t.length; i2++) {
              var el = t[i2]._elem;
              if (el) {
                if (jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined2) {
                  window.G_vmlCanvasManager.uninitElement(el.get(0));
                }
                el.emptyForce();
                el = null;
                t._elem = null;
              }
            }
            t = null;
            this.axes[name]._plotDimensions = this._plotDimensions;
            this.axes[name]._ticks = [];
          }
          if (this.sortData) {
            sortData(this.series);
          }
          this.grid._axes = this.axes;
          this.legend._series = this.series;
        };
        function sortData(series) {
          var d2, sd, pd, ppd, ret;
          for (var i2 = 0; i2 < series.length; i2++) {
            var check;
            var bat = [series[i2].data, series[i2]._stackData, series[i2]._plotData, series[i2]._prevPlotData];
            for (var n = 0; n < 4; n++) {
              check = true;
              d2 = bat[n];
              if (series[i2]._stackAxis == "x") {
                for (var j = 0; j < d2.length; j++) {
                  if (typeof d2[j][1] != "number") {
                    check = false;
                    break;
                  }
                }
                if (check) {
                  d2.sort(function(a, b) {
                    return a[1] - b[1];
                  });
                }
              } else {
                for (var j = 0; j < d2.length; j++) {
                  if (typeof d2[j][0] != "number") {
                    check = false;
                    break;
                  }
                }
                if (check) {
                  d2.sort(function(a, b) {
                    return a[0] - b[0];
                  });
                }
              }
            }
          }
        }
        this.computePlotData = function() {
          this._plotData = [];
          this._stackData = [];
          var series, index, l;
          for (index = 0, l = this.series.length; index < l; index++) {
            series = this.series[index];
            this._plotData.push([]);
            this._stackData.push([]);
            var cd = series.data;
            this._plotData[index] = _jquery2.default.extend(true, [], cd);
            this._stackData[index] = _jquery2.default.extend(true, [], cd);
            series._plotData = this._plotData[index];
            series._stackData = this._stackData[index];
            var plotValues = { x: [], y: [] };
            if (this.stackSeries && !series.disableStack) {
              series._stack = true;
              var sidx = series._stackAxis === "x" ? 0 : 1;
              for (var k = 0, cdl = cd.length; k < cdl; k++) {
                var temp = cd[k][sidx];
                if (temp == null) {
                  temp = 0;
                }
                this._plotData[index][k][sidx] = temp;
                this._stackData[index][k][sidx] = temp;
                if (index > 0) {
                  for (var j = index; j--; ) {
                    var prevval = this._plotData[j][k][sidx];
                    if (temp * prevval >= 0) {
                      this._plotData[index][k][sidx] += prevval;
                      this._stackData[index][k][sidx] += prevval;
                      break;
                    }
                  }
                }
              }
            } else {
              for (var i2 = 0; i2 < series.data.length; i2++) {
                plotValues.x.push(series.data[i2][0]);
                plotValues.y.push(series.data[i2][1]);
              }
              this._stackData.push(series.data);
              this.series[index]._stackData = series.data;
              this._plotData.push(series.data);
              series._plotData = series.data;
              series._plotValues = plotValues;
            }
            if (index > 0) {
              series._prevPlotData = this.series[index - 1]._plotData;
            }
            series._sumy = 0;
            series._sumx = 0;
            for (i2 = series.data.length - 1; i2 > -1; i2--) {
              series._sumy += series.data[i2][1];
              series._sumx += series.data[i2][0];
            }
          }
        };
        this.populatePlotData = function(series, index) {
          this._plotData = [];
          this._stackData = [];
          series._stackData = [];
          series._plotData = [];
          var plotValues = { x: [], y: [] };
          if (this.stackSeries && !series.disableStack) {
            series._stack = true;
            var sidx = series._stackAxis === "x" ? 0 : 1;
            var temp = _jquery2.default.extend(true, [], series.data);
            var plotdata = _jquery2.default.extend(true, [], series.data);
            var tempx, tempy, dval, stackval, comparator;
            for (var j = 0; j < index; j++) {
              var cd = this.series[j].data;
              for (var k = 0; k < cd.length; k++) {
                dval = cd[k];
                tempx = dval[0] != null ? dval[0] : 0;
                tempy = dval[1] != null ? dval[1] : 0;
                temp[k][0] += tempx;
                temp[k][1] += tempy;
                stackval = sidx ? tempy : tempx;
                if (series.data[k][sidx] * stackval >= 0) {
                  plotdata[k][sidx] += stackval;
                }
              }
            }
            for (var i2 = 0; i2 < plotdata.length; i2++) {
              plotValues.x.push(plotdata[i2][0]);
              plotValues.y.push(plotdata[i2][1]);
            }
            this._plotData.push(plotdata);
            this._stackData.push(temp);
            series._stackData = temp;
            series._plotData = plotdata;
            series._plotValues = plotValues;
          } else {
            for (var i2 = 0; i2 < series.data.length; i2++) {
              plotValues.x.push(series.data[i2][0]);
              plotValues.y.push(series.data[i2][1]);
            }
            this._stackData.push(series.data);
            this.series[index]._stackData = series.data;
            this._plotData.push(series.data);
            series._plotData = series.data;
            series._plotValues = plotValues;
          }
          if (index > 0) {
            series._prevPlotData = this.series[index - 1]._plotData;
          }
          series._sumy = 0;
          series._sumx = 0;
          for (i2 = series.data.length - 1; i2 > -1; i2--) {
            series._sumy += series.data[i2][1];
            series._sumx += series.data[i2][0];
          }
        };
        this.getNextSeriesColor = function(t) {
          var idx = 0;
          var sc = t.seriesColors;
          return function() {
            if (idx < sc.length) {
              return sc[idx++];
            } else {
              idx = 0;
              return sc[idx++];
            }
          };
        }(this);
        this.parseOptions = function(options2) {
          for (var i2 = 0; i2 < this.preParseOptionsHooks.hooks.length; i2++) {
            this.preParseOptionsHooks.hooks[i2].call(this, options2);
          }
          for (var i2 = 0; i2 < jqplot.preParseOptionsHooks.length; i2++) {
            jqplot.preParseOptionsHooks[i2].call(this, options2);
          }
          this.options = _jquery2.default.extend(true, {}, this.defaults, options2);
          var opts = this.options;
          this.animate = opts.animate;
          this.animateReplot = opts.animateReplot;
          this.stackSeries = opts.stackSeries;
          if (_jquery2.default.isPlainObject(opts.fillBetween)) {
            var temp = ["series1", "series2", "color", "baseSeries", "fill"], tempi;
            for (var i2 = 0, l = temp.length; i2 < l; i2++) {
              tempi = temp[i2];
              if (opts.fillBetween[tempi] != null) {
                this.fillBetween[tempi] = opts.fillBetween[tempi];
              }
            }
          }
          if (opts.seriesColors) {
            this.seriesColors = opts.seriesColors;
          }
          if (opts.negativeSeriesColors) {
            this.negativeSeriesColors = opts.negativeSeriesColors;
          }
          if (opts.captureRightClick) {
            this.captureRightClick = opts.captureRightClick;
          }
          this.defaultAxisStart = options2 && options2.defaultAxisStart != null ? options2.defaultAxisStart : this.defaultAxisStart;
          this.colorGenerator.setColors(this.seriesColors);
          this.negativeColorGenerator.setColors(this.negativeSeriesColors);
          _jquery2.default.extend(true, this._gridPadding, opts.gridPadding);
          this.sortData = opts.sortData != null ? opts.sortData : this.sortData;
          for (var i2 = 0; i2 < 12; i2++) {
            var n = _axisNames[i2];
            var axis = this.axes[n];
            axis._options = _jquery2.default.extend(true, {}, opts.axesDefaults, opts.axes[n]);
            _jquery2.default.extend(true, axis, opts.axesDefaults, opts.axes[n]);
            axis._plotWidth = this._width;
            axis._plotHeight = this._height;
          }
          var normalizeData = function normalizeData2(data, dir2, start) {
            var temp2 = [];
            var i3, l2;
            dir2 = dir2 || "vertical";
            if (!_jquery2.default.isArray(data[0])) {
              for (i3 = 0, l2 = data.length; i3 < l2; i3++) {
                if (dir2 == "vertical") {
                  temp2.push([start + i3, data[i3]]);
                } else {
                  temp2.push([data[i3], start + i3]);
                }
              }
            } else {
              _jquery2.default.extend(true, temp2, data);
            }
            return temp2;
          };
          var colorIndex = 0;
          this.series = [];
          for (var i2 = 0; i2 < this.data.length; i2++) {
            var sopts = _jquery2.default.extend(true, { index: i2 }, { seriesColors: this.seriesColors, negativeSeriesColors: this.negativeSeriesColors }, this.options.seriesDefaults, this.options.series[i2], { rendererOptions: { animation: { show: this.animate } } });
            var temp = new Series(sopts);
            for (var j = 0; j < jqplot.preParseSeriesOptionsHooks.length; j++) {
              jqplot.preParseSeriesOptionsHooks[j].call(temp, this.options.seriesDefaults, this.options.series[i2]);
            }
            for (var j = 0; j < this.preParseSeriesOptionsHooks.hooks.length; j++) {
              this.preParseSeriesOptionsHooks.hooks[j].call(temp, this.options.seriesDefaults, this.options.series[i2]);
            }
            _jquery2.default.extend(true, temp, sopts);
            var dir = "vertical";
            if (temp.renderer === jqplot.BarRenderer && temp.rendererOptions && temp.rendererOptions.barDirection == "horizontal") {
              dir = "horizontal";
              temp._stackAxis = "x";
              temp._primaryAxis = "_yaxis";
            }
            temp.data = normalizeData(this.data[i2], dir, this.defaultAxisStart);
            switch (temp.xaxis) {
              case "xaxis":
                temp._xaxis = this.axes.xaxis;
                break;
              case "x2axis":
                temp._xaxis = this.axes.x2axis;
                break;
              default:
                break;
            }
            temp._yaxis = this.axes[temp.yaxis];
            temp._xaxis._series.push(temp);
            temp._yaxis._series.push(temp);
            if (temp.show) {
              temp._xaxis.show = true;
              temp._yaxis.show = true;
            } else {
              if (temp._xaxis.scaleToHiddenSeries) {
                temp._xaxis.show = true;
              }
              if (temp._yaxis.scaleToHiddenSeries) {
                temp._yaxis.show = true;
              }
            }
            if (!temp.label) {
              temp.label = "Series " + (i2 + 1).toString();
            }
            this.series.push(temp);
            for (var j = 0; j < jqplot.postParseSeriesOptionsHooks.length; j++) {
              jqplot.postParseSeriesOptionsHooks[j].call(this.series[i2], this.options.seriesDefaults, this.options.series[i2]);
            }
            for (var j = 0; j < this.postParseSeriesOptionsHooks.hooks.length; j++) {
              this.postParseSeriesOptionsHooks.hooks[j].call(this.series[i2], this.options.seriesDefaults, this.options.series[i2]);
            }
          }
          _jquery2.default.extend(true, this.grid, this.options.grid);
          for (var i2 = 0, l = _axisNames.length; i2 < l; i2++) {
            var n = _axisNames[i2];
            var axis = this.axes[n];
            if (axis.borderWidth == null) {
              axis.borderWidth = this.grid.borderWidth;
            }
          }
          if (typeof this.options.title == "string") {
            this.title.text = this.options.title;
          } else if (_typeof(this.options.title) == "object") {
            _jquery2.default.extend(true, this.title, this.options.title);
          }
          this.title._plotWidth = this._width;
          this.legend.setOptions(this.options.legend);
          for (var i2 = 0; i2 < jqplot.postParseOptionsHooks.length; i2++) {
            jqplot.postParseOptionsHooks[i2].call(this, options2);
          }
          for (var i2 = 0; i2 < this.postParseOptionsHooks.hooks.length; i2++) {
            this.postParseOptionsHooks.hooks[i2].call(this, options2);
          }
        };
        this.destroy = function() {
          this.canvasManager.freeAllCanvases();
          if (this.eventCanvas && this.eventCanvas._elem) {
            this.eventCanvas._elem.unbind();
          }
          this.target.empty();
          this.target[0].innerHTML = "";
        };
        this.replot = function(options2) {
          var opts = options2 || {};
          var data = opts.data || null;
          var clear = opts.clear === false ? false : true;
          var resetAxes = opts.resetAxes || false;
          delete opts.data;
          delete opts.clear;
          delete opts.resetAxes;
          this.target.trigger("jqplotPreReplot");
          if (clear) {
            this.destroy();
          }
          if (data || !_jquery2.default.isEmptyObject(opts)) {
            this.reInitialize(data, opts);
          } else {
            this.quickInit();
          }
          if (resetAxes) {
            this.resetAxesScale(resetAxes, opts.axes);
          }
          this.draw();
          this.target.trigger("jqplotPostReplot");
        };
        this.redraw = function(clear) {
          clear = clear != null ? clear : true;
          this.target.trigger("jqplotPreRedraw");
          if (clear) {
            this.canvasManager.freeAllCanvases();
            this.eventCanvas._elem.unbind();
            this.target.empty();
          }
          for (var ax in this.axes) {
            this.axes[ax]._ticks = [];
          }
          this.computePlotData();
          this._sumy = 0;
          this._sumx = 0;
          for (var i2 = 0, tsl = this.series.length; i2 < tsl; i2++) {
            this._sumy += this.series[i2]._sumy;
            this._sumx += this.series[i2]._sumx;
          }
          this.draw();
          this.target.trigger("jqplotPostRedraw");
        };
        this.draw = function() {
          if (this.drawIfHidden || this.target.is(":visible")) {
            this.target.trigger("jqplotPreDraw");
            var i2, j, l, tempseries;
            for (i2 = 0, l = jqplot.preDrawHooks.length; i2 < l; i2++) {
              jqplot.preDrawHooks[i2].call(this);
            }
            for (i2 = 0, l = this.preDrawHooks.hooks.length; i2 < l; i2++) {
              this.preDrawHooks.hooks[i2].apply(this, this.preDrawSeriesHooks.args[i2]);
            }
            this.target.append(this.baseCanvas.createElement({ left: 0, right: 0, top: 0, bottom: 0 }, "jqplot-base-canvas", null, this));
            this.baseCanvas.setContext();
            this.target.append(this.title.draw());
            this.title.pack({ top: 0, left: 0 });
            var legendElem = this.legend.draw({}, this);
            var gridPadding = { top: 0, left: 0, bottom: 0, right: 0 };
            if (this.legend.placement == "outsideGrid") {
              this.target.append(legendElem);
              switch (this.legend.location) {
                case "n":
                  gridPadding.top += this.legend.getHeight();
                  break;
                case "s":
                  gridPadding.bottom += this.legend.getHeight();
                  break;
                case "ne":
                case "e":
                case "se":
                  gridPadding.right += this.legend.getWidth();
                  break;
                case "nw":
                case "w":
                case "sw":
                  gridPadding.left += this.legend.getWidth();
                  break;
                default:
                  gridPadding.right += this.legend.getWidth();
                  break;
              }
              legendElem = legendElem.detach();
            }
            var ax = this.axes;
            var name;
            for (i2 = 0; i2 < 12; i2++) {
              name = _axisNames[i2];
              this.target.append(ax[name].draw(this.baseCanvas._ctx, this));
              ax[name].set();
            }
            if (ax.yaxis.show) {
              gridPadding.left += ax.yaxis.getWidth();
            }
            var ra = ["y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis"];
            var rapad = [0, 0, 0, 0, 0, 0, 0, 0];
            var gpr = 0;
            var n;
            for (n = 0; n < 8; n++) {
              if (ax[ra[n]].show) {
                gpr += ax[ra[n]].getWidth();
                rapad[n] = gpr;
              }
            }
            gridPadding.right += gpr;
            if (ax.x2axis.show) {
              gridPadding.top += ax.x2axis.getHeight();
            }
            if (this.title.show) {
              gridPadding.top += this.title.getHeight();
            }
            if (ax.xaxis.show) {
              gridPadding.bottom += ax.xaxis.getHeight();
            }
            if (this.options.gridDimensions && _jquery2.default.isPlainObject(this.options.gridDimensions)) {
              var gdw = parseInt(this.options.gridDimensions.width, 10) || 0;
              var gdh = parseInt(this.options.gridDimensions.height, 10) || 0;
              var widthAdj = (this._width - gridPadding.left - gridPadding.right - gdw) / 2;
              var heightAdj = (this._height - gridPadding.top - gridPadding.bottom - gdh) / 2;
              if (heightAdj >= 0 && widthAdj >= 0) {
                gridPadding.top += heightAdj;
                gridPadding.bottom += heightAdj;
                gridPadding.left += widthAdj;
                gridPadding.right += widthAdj;
              }
            }
            var arr = ["top", "bottom", "left", "right"];
            for (var n in arr) {
              if (this._gridPadding[arr[n]] == null && gridPadding[arr[n]] > 0) {
                this._gridPadding[arr[n]] = gridPadding[arr[n]];
              } else if (this._gridPadding[arr[n]] == null) {
                this._gridPadding[arr[n]] = this._defaultGridPadding[arr[n]];
              }
            }
            var legendPadding = this._gridPadding;
            if (this.legend.placement === "outsideGrid") {
              legendPadding = { top: this.title.getHeight(), left: 0, right: 0, bottom: 0 };
            }
            ax.xaxis.pack({ position: "absolute", bottom: this._gridPadding.bottom - ax.xaxis.getHeight(), left: 0, width: this._width }, { min: this._gridPadding.left, max: this._width - this._gridPadding.right });
            ax.yaxis.pack({ position: "absolute", top: 0, left: this._gridPadding.left - ax.yaxis.getWidth(), height: this._height }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top });
            ax.x2axis.pack({ position: "absolute", top: this._gridPadding.top - ax.x2axis.getHeight(), left: 0, width: this._width }, { min: this._gridPadding.left, max: this._width - this._gridPadding.right });
            for (i2 = 8; i2 > 0; i2--) {
              ax[ra[i2 - 1]].pack({ position: "absolute", top: 0, right: this._gridPadding.right - rapad[i2 - 1] }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top });
            }
            var ltemp = (this._width - this._gridPadding.left - this._gridPadding.right) / 2 + this._gridPadding.left - ax.yMidAxis.getWidth() / 2;
            ax.yMidAxis.pack({ position: "absolute", top: 0, left: ltemp, zIndex: 9, textAlign: "center" }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top });
            this.target.append(this.grid.createElement(this._gridPadding, this));
            this.grid.draw();
            var series = this.series;
            var seriesLength = series.length;
            for (i2 = 0, l = seriesLength; i2 < l; i2++) {
              j = this.seriesStack[i2];
              this.target.append(series[j].shadowCanvas.createElement(this._gridPadding, "jqplot-series-shadowCanvas", null, this));
              series[j].shadowCanvas.setContext();
              series[j].shadowCanvas._elem.data("seriesIndex", j);
            }
            for (i2 = 0, l = seriesLength; i2 < l; i2++) {
              j = this.seriesStack[i2];
              this.target.append(series[j].canvas.createElement(this._gridPadding, "jqplot-series-canvas", null, this));
              series[j].canvas.setContext();
              series[j].canvas._elem.data("seriesIndex", j);
            }
            this.target.append(this.eventCanvas.createElement(this._gridPadding, "jqplot-event-canvas", null, this));
            this.eventCanvas.setContext();
            this.eventCanvas._ctx.fillStyle = "rgba(0,0,0,0)";
            this.eventCanvas._ctx.fillRect(0, 0, this.eventCanvas._ctx.canvas.width, this.eventCanvas._ctx.canvas.height);
            this.bindCustomEvents();
            if (this.legend.preDraw) {
              this.eventCanvas._elem.before(legendElem);
              this.legend.pack(legendPadding);
              if (this.legend._elem) {
                this.drawSeries({ legendInfo: { location: this.legend.location, placement: this.legend.placement, width: this.legend.getWidth(), height: this.legend.getHeight(), xoffset: this.legend.xoffset, yoffset: this.legend.yoffset } });
              } else {
                this.drawSeries();
              }
            } else {
              this.drawSeries();
              if (seriesLength) {
                (0, _jquery2.default)(series[seriesLength - 1].canvas._elem).after(legendElem);
              }
              this.legend.pack(legendPadding);
            }
            for (var i2 = 0, l = jqplot.eventListenerHooks.length; i2 < l; i2++) {
              this.eventCanvas._elem.bind(jqplot.eventListenerHooks[i2][0], { plot: this }, jqplot.eventListenerHooks[i2][1]);
            }
            for (var i2 = 0, l = this.eventListenerHooks.hooks.length; i2 < l; i2++) {
              this.eventCanvas._elem.bind(this.eventListenerHooks.hooks[i2][0], { plot: this }, this.eventListenerHooks.hooks[i2][1]);
            }
            var fb = this.fillBetween;
            if (typeof fb.series1 == "number") {
              if (fb.fill && fb.series1 !== fb.series2 && fb.series1 < seriesLength && fb.series2 < seriesLength && series[fb.series1]._type === "line" && series[fb.series2]._type === "line")
                this.doFillBetweenLines();
            } else {
              if (fb.series1 != null && fb.series2 != null) {
                var doFb = false;
                if (fb.series1.length === fb.series2.length) {
                  var tempSeries1 = 0;
                  var tempSeries2 = 0;
                  for (var cnt = 0; cnt < fb.series1.length; cnt++) {
                    tempSeries1 = fb.series1[cnt];
                    tempSeries2 = fb.series2[cnt];
                    if (tempSeries1 !== tempSeries2 && tempSeries1 < seriesLength && tempSeries2 < seriesLength && series[tempSeries1]._type === "line" && series[tempSeries2]._type === "line") {
                      doFb = true;
                    } else {
                      doFb = false;
                      break;
                    }
                  }
                }
                if (fb.fill && doFb) {
                  this.doFillBetweenLines();
                }
              }
            }
            for (var i2 = 0, l = jqplot.postDrawHooks.length; i2 < l; i2++) {
              jqplot.postDrawHooks[i2].call(this);
            }
            for (var i2 = 0, l = this.postDrawHooks.hooks.length; i2 < l; i2++) {
              this.postDrawHooks.hooks[i2].apply(this, this.postDrawHooks.args[i2]);
            }
            if (this.target.is(":visible")) {
              this._drawCount += 1;
            }
            var temps, tempr, sel, _els;
            for (i2 = 0, l = seriesLength; i2 < l; i2++) {
              temps = series[i2];
              tempr = temps.renderer;
              sel = ".jqplot-point-label.jqplot-series-" + i2;
              if (tempr.animation && tempr.animation._supported && tempr.animation.show && (this._drawCount < 2 || this.animateReplot)) {
                _els = this.target.find(sel);
                _els.stop(true, true).hide();
                temps.canvas._elem.stop(true, true).hide();
                temps.shadowCanvas._elem.stop(true, true).hide();
                temps.canvas._elem.jqplotEffect("blind", { mode: "show", direction: tempr.animation.direction }, tempr.animation.speed);
                temps.shadowCanvas._elem.jqplotEffect("blind", { mode: "show", direction: tempr.animation.direction }, tempr.animation.speed);
                _els.fadeIn(tempr.animation.speed * 0.8);
              }
            }
            _els = null;
            this.target.trigger("jqplotPostDraw", [this]);
          }
        };
        jqPlot.prototype.doFillBetweenLines = function() {
          var fb = this.fillBetween;
          var series = this.series;
          var sid1 = fb.series1;
          var sid2 = fb.series2;
          var id1 = 0, id2 = 0;
          function fill(id12, id22) {
            var series1 = series[id12];
            var series2 = series[id22];
            if (series2.renderer.smooth)
              var tempgd = series2.renderer._smoothedData.slice(0).reverse();
            else
              var tempgd = series2.gridData.slice(0).reverse();
            if (series1.renderer.smooth)
              var gd = series1.renderer._smoothedData.concat(tempgd);
            else
              var gd = series1.gridData.concat(tempgd);
            var color = fb.color !== null ? fb.color : series[id12].fillColor;
            var baseSeries = fb.baseSeries !== null ? fb.baseSeries : id12;
            var sr = series[baseSeries].renderer.shapeRenderer;
            var opts = {
              fillStyle: color,
              fill: true,
              closePath: true
            };
            sr.draw(series1.shadowCanvas._ctx, gd, opts);
          }
          if (typeof sid1 == "number" && typeof sid2 == "number") {
            id1 = sid1 < sid2 ? sid1 : sid2;
            id2 = sid2 > sid1 ? sid2 : sid1;
            fill(id1, id2);
          } else {
            for (var cnt = 0; cnt < sid1.length; cnt++) {
              id1 = sid1[cnt] < sid2[cnt] ? sid1[cnt] : sid2[cnt];
              id2 = sid2[cnt] > sid1[cnt] ? sid2[cnt] : sid1[cnt];
              fill(id1, id2);
            }
          }
        };
        this.bindCustomEvents = function() {
          this.eventCanvas._elem.bind("click", { plot: this }, this.onClick);
          this.eventCanvas._elem.bind("dblclick", { plot: this }, this.onDblClick);
          this.eventCanvas._elem.bind("mousedown", { plot: this }, this.onMouseDown);
          this.eventCanvas._elem.bind("mousemove", { plot: this }, this.onMouseMove);
          this.eventCanvas._elem.bind("mouseenter", { plot: this }, this.onMouseEnter);
          this.eventCanvas._elem.bind("mouseleave", { plot: this }, this.onMouseLeave);
          if (this.captureRightClick) {
            this.eventCanvas._elem.bind("mouseup", { plot: this }, this.onRightClick);
            this.eventCanvas._elem.get(0).oncontextmenu = function() {
              return false;
            };
          } else {
            this.eventCanvas._elem.bind("mouseup", { plot: this }, this.onMouseUp);
          }
        };
        function getEventPosition(ev) {
          var plot = ev.data.plot;
          var go = plot.eventCanvas._elem.offset();
          var gridPos = { x: ev.pageX - go.left, y: ev.pageY - go.top };
          var dataPos = { xaxis: null, yaxis: null, x2axis: null, y2axis: null, y3axis: null, y4axis: null, y5axis: null, y6axis: null, y7axis: null, y8axis: null, y9axis: null, yMidAxis: null };
          var an = ["xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis"];
          var ax = plot.axes;
          var n, axis;
          for (n = 11; n > 0; n--) {
            axis = an[n - 1];
            if (ax[axis].show) {
              dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
            }
          }
          return { offsets: go, gridPos, dataPos };
        }
        function checkIntersection(gridpos, plot) {
          var series = plot.series;
          var i2, j, k, s, r, x, y, theta, sm, sa, minang, maxang;
          var d0, d2, p, pp, points, bw, hp;
          var threshold, t;
          for (k = plot.seriesStack.length - 1; k >= 0; k--) {
            i2 = plot.seriesStack[k];
            s = series[i2];
            hp = s._highlightThreshold;
            switch (s.renderer.constructor) {
              case jqplot.BarRenderer:
                x = gridpos.x;
                y = gridpos.y;
                for (j = 0; j < s._barPoints.length; j++) {
                  points = s._barPoints[j];
                  p = s.gridData[j];
                  if (x > points[0][0] && x < points[2][0] && (y > points[2][1] && y < points[0][1] || y < points[2][1] && y > points[0][1])) {
                    return { seriesIndex: s.index, pointIndex: j, gridData: p, data: s.data[j], points: s._barPoints[j] };
                  }
                }
                break;
              case jqplot.PyramidRenderer:
                x = gridpos.x;
                y = gridpos.y;
                for (j = 0; j < s._barPoints.length; j++) {
                  points = s._barPoints[j];
                  p = s.gridData[j];
                  if (x > points[0][0] + hp[0][0] && x < points[2][0] + hp[2][0] && y > points[2][1] && y < points[0][1]) {
                    return { seriesIndex: s.index, pointIndex: j, gridData: p, data: s.data[j], points: s._barPoints[j] };
                  }
                }
                break;
              case jqplot.DonutRenderer:
                sa = s.startAngle / 180 * Math.PI;
                x = gridpos.x - s._center[0];
                y = gridpos.y - s._center[1];
                r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                if (x > 0 && -y >= 0) {
                  theta = 2 * Math.PI - Math.atan(-y / x);
                } else if (x > 0 && -y < 0) {
                  theta = -Math.atan(-y / x);
                } else if (x < 0) {
                  theta = Math.PI - Math.atan(-y / x);
                } else if (x == 0 && -y > 0) {
                  theta = 3 * Math.PI / 2;
                } else if (x == 0 && -y < 0) {
                  theta = Math.PI / 2;
                } else if (x == 0 && y == 0) {
                  theta = 0;
                }
                if (sa) {
                  theta -= sa;
                  if (theta < 0) {
                    theta += 2 * Math.PI;
                  } else if (theta > 2 * Math.PI) {
                    theta -= 2 * Math.PI;
                  }
                }
                sm = s.sliceMargin / 180 * Math.PI;
                if (r < s._radius && r > s._innerRadius) {
                  for (j = 0; j < s.gridData.length; j++) {
                    minang = j > 0 ? s.gridData[j - 1][1] + sm : sm;
                    maxang = s.gridData[j][1];
                    if (theta > minang && theta < maxang) {
                      return { seriesIndex: s.index, pointIndex: j, gridData: [gridpos.x, gridpos.y], data: s.data[j] };
                    }
                  }
                }
                break;
              case jqplot.PieRenderer:
                sa = s.startAngle / 180 * Math.PI;
                x = gridpos.x - s._center[0];
                y = gridpos.y - s._center[1];
                r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                if (x > 0 && -y >= 0) {
                  theta = 2 * Math.PI - Math.atan(-y / x);
                } else if (x > 0 && -y < 0) {
                  theta = -Math.atan(-y / x);
                } else if (x < 0) {
                  theta = Math.PI - Math.atan(-y / x);
                } else if (x == 0 && -y > 0) {
                  theta = 3 * Math.PI / 2;
                } else if (x == 0 && -y < 0) {
                  theta = Math.PI / 2;
                } else if (x == 0 && y == 0) {
                  theta = 0;
                }
                if (sa) {
                  theta -= sa;
                  if (theta < 0) {
                    theta += 2 * Math.PI;
                  } else if (theta > 2 * Math.PI) {
                    theta -= 2 * Math.PI;
                  }
                }
                sm = s.sliceMargin / 180 * Math.PI;
                if (r < s._radius) {
                  for (j = 0; j < s.gridData.length; j++) {
                    minang = j > 0 ? s.gridData[j - 1][1] + sm : sm;
                    maxang = s.gridData[j][1];
                    if (theta > minang && theta < maxang) {
                      return { seriesIndex: s.index, pointIndex: j, gridData: [gridpos.x, gridpos.y], data: s.data[j] };
                    }
                  }
                }
                break;
              case jqplot.BubbleRenderer:
                x = gridpos.x;
                y = gridpos.y;
                var ret = null;
                if (s.show) {
                  for (var j = 0; j < s.gridData.length; j++) {
                    p = s.gridData[j];
                    d2 = Math.sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]));
                    if (d2 <= p[2] && (d2 <= d0 || d0 == null)) {
                      d0 = d2;
                      ret = { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                    }
                  }
                  if (ret != null) {
                    return ret;
                  }
                }
                break;
              case jqplot.FunnelRenderer:
                x = gridpos.x;
                y = gridpos.y;
                var v = s._vertices, vfirst = v[0], vlast = v[v.length - 1], lex, rex, cv;
                var findedge = function findedge2(l, p1, p2) {
                  var m = (p1[1] - p2[1]) / (p1[0] - p2[0]);
                  var b = p1[1] - m * p1[0];
                  var y2 = l + p1[1];
                  return [(y2 - b) / m, y2];
                };
                lex = findedge(y, vfirst[0], vlast[3]);
                rex = findedge(y, vfirst[1], vlast[2]);
                for (j = 0; j < v.length; j++) {
                  cv = v[j];
                  if (y >= cv[0][1] && y <= cv[3][1] && x >= lex[0] && x <= rex[0]) {
                    return { seriesIndex: s.index, pointIndex: j, gridData: null, data: s.data[j] };
                  }
                }
                break;
              case jqplot.LineRenderer:
                x = gridpos.x;
                y = gridpos.y;
                r = s.renderer;
                if (s.show) {
                  if ((s.fill || s.renderer.bands.show && s.renderer.bands.fill) && (!plot.plugins.highlighter || !plot.plugins.highlighter.show)) {
                    var inside = false;
                    if (x > s._boundingBox[0][0] && x < s._boundingBox[1][0] && y > s._boundingBox[1][1] && y < s._boundingBox[0][1]) {
                      var numPoints = s._areaPoints.length;
                      var ii;
                      var j = numPoints - 1;
                      for (var ii = 0; ii < numPoints; ii++) {
                        var vertex1 = [s._areaPoints[ii][0], s._areaPoints[ii][1]];
                        var vertex2 = [s._areaPoints[j][0], s._areaPoints[j][1]];
                        if (vertex1[1] < y && vertex2[1] >= y || vertex2[1] < y && vertex1[1] >= y) {
                          if (vertex1[0] + (y - vertex1[1]) / (vertex2[1] - vertex1[1]) * (vertex2[0] - vertex1[0]) < x) {
                            inside = !inside;
                          }
                        }
                        j = ii;
                      }
                    }
                    if (inside) {
                      return { seriesIndex: i2, pointIndex: null, gridData: s.gridData, data: s.data, points: s._areaPoints };
                    }
                    break;
                  } else {
                    t = s.markerRenderer.size / 2 + s.neighborThreshold;
                    threshold = t > 0 ? t : 0;
                    for (var j = 0; j < s.gridData.length; j++) {
                      p = s.gridData[j];
                      if (r.constructor == jqplot.OHLCRenderer) {
                        if (r.candleStick) {
                          var yp = s._yaxis.series_u2p;
                          if (x >= p[0] - r._bodyWidth / 2 && x <= p[0] + r._bodyWidth / 2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                            return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                          }
                        } else if (!r.hlc) {
                          var yp = s._yaxis.series_u2p;
                          if (x >= p[0] - r._tickLength && x <= p[0] + r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                            return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                          }
                        } else {
                          var yp = s._yaxis.series_u2p;
                          if (x >= p[0] - r._tickLength && x <= p[0] + r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                            return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                          }
                        }
                      } else if (p[0] != null && p[1] != null) {
                        d2 = Math.sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]));
                        if (d2 <= threshold && (d2 <= d0 || d0 == null)) {
                          d0 = d2;
                          return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                        }
                      }
                    }
                  }
                }
                break;
              default:
                x = gridpos.x;
                y = gridpos.y;
                r = s.renderer;
                if (s.show) {
                  t = s.markerRenderer.size / 2 + s.neighborThreshold;
                  threshold = t > 0 ? t : 0;
                  for (var j = 0; j < s.gridData.length; j++) {
                    p = s.gridData[j];
                    if (r.constructor == jqplot.OHLCRenderer) {
                      if (r.candleStick) {
                        var yp = s._yaxis.series_u2p;
                        if (x >= p[0] - r._bodyWidth / 2 && x <= p[0] + r._bodyWidth / 2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                          return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                        }
                      } else if (!r.hlc) {
                        var yp = s._yaxis.series_u2p;
                        if (x >= p[0] - r._tickLength && x <= p[0] + r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                          return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                        }
                      } else {
                        var yp = s._yaxis.series_u2p;
                        if (x >= p[0] - r._tickLength && x <= p[0] + r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                          return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                        }
                      }
                    } else {
                      d2 = Math.sqrt((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]));
                      if (d2 <= threshold && (d2 <= d0 || d0 == null)) {
                        d0 = d2;
                        return { seriesIndex: i2, pointIndex: j, gridData: p, data: s.data[j] };
                      }
                    }
                  }
                }
                break;
            }
          }
          return null;
        }
        this.onClick = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var neighbor = checkIntersection(positions.gridPos, p);
          var evt = _jquery2.default.Event("jqplotClick");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        this.onDblClick = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var neighbor = checkIntersection(positions.gridPos, p);
          var evt = _jquery2.default.Event("jqplotDblClick");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        this.onMouseDown = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var neighbor = checkIntersection(positions.gridPos, p);
          var evt = _jquery2.default.Event("jqplotMouseDown");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        this.onMouseUp = function(ev) {
          var positions = getEventPosition(ev);
          var evt = _jquery2.default.Event("jqplotMouseUp");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, null, ev.data.plot]);
        };
        this.onRightClick = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var neighbor = checkIntersection(positions.gridPos, p);
          if (p.captureRightClick) {
            if (ev.which == 3) {
              var evt = _jquery2.default.Event("jqplotRightClick");
              evt.pageX = ev.pageX;
              evt.pageY = ev.pageY;
              (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
            } else {
              var evt = _jquery2.default.Event("jqplotMouseUp");
              evt.pageX = ev.pageX;
              evt.pageY = ev.pageY;
              (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
            }
          }
        };
        this.onMouseMove = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var neighbor = checkIntersection(positions.gridPos, p);
          var evt = _jquery2.default.Event("jqplotMouseMove");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        this.onMouseEnter = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var evt = _jquery2.default.Event("jqplotMouseEnter");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          evt.relatedTarget = ev.relatedTarget;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
        };
        this.onMouseLeave = function(ev) {
          var positions = getEventPosition(ev);
          var p = ev.data.plot;
          var evt = _jquery2.default.Event("jqplotMouseLeave");
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          evt.relatedTarget = ev.relatedTarget;
          (0, _jquery2.default)(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
        };
        this.drawSeries = function(options2, idx) {
          var i2, series, ctx;
          idx = typeof options2 === "number" && idx == null ? options2 : idx;
          options2 = (typeof options2 === "undefined" ? "undefined" : _typeof(options2)) === "object" ? options2 : {};
          if (idx != undefined2) {
            series = this.series[idx];
            ctx = series.shadowCanvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            series.drawShadow(ctx, options2, this);
            ctx = series.canvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            series.draw(ctx, options2, this);
            if (series.renderer.constructor == jqplot.BezierCurveRenderer) {
              if (idx < this.series.length - 1) {
                this.drawSeries(idx + 1);
              }
            }
          } else {
            for (i2 = 0; i2 < this.series.length; i2++) {
              series = this.series[i2];
              ctx = series.shadowCanvas._ctx;
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              series.drawShadow(ctx, options2, this);
              ctx = series.canvas._ctx;
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              series.draw(ctx, options2, this);
            }
          }
          options2 = idx = i2 = series = ctx = null;
        };
        this.moveSeriesToFront = function(idx) {
          idx = parseInt(idx, 10);
          var stackIndex = _jquery2.default.inArray(idx, this.seriesStack);
          if (stackIndex == -1) {
            return;
          }
          if (stackIndex == this.seriesStack.length - 1) {
            this.previousSeriesStack = this.seriesStack.slice(0);
            return;
          }
          var opidx = this.seriesStack[this.seriesStack.length - 1];
          var serelem = this.series[idx].canvas._elem.detach();
          var shadelem = this.series[idx].shadowCanvas._elem.detach();
          this.series[opidx].shadowCanvas._elem.after(shadelem);
          this.series[opidx].canvas._elem.after(serelem);
          this.previousSeriesStack = this.seriesStack.slice(0);
          this.seriesStack.splice(stackIndex, 1);
          this.seriesStack.push(idx);
        };
        this.moveSeriesToBack = function(idx) {
          idx = parseInt(idx, 10);
          var stackIndex = _jquery2.default.inArray(idx, this.seriesStack);
          if (stackIndex == 0 || stackIndex == -1) {
            return;
          }
          var opidx = this.seriesStack[0];
          var serelem = this.series[idx].canvas._elem.detach();
          var shadelem = this.series[idx].shadowCanvas._elem.detach();
          this.series[opidx].shadowCanvas._elem.before(shadelem);
          this.series[opidx].canvas._elem.before(serelem);
          this.previousSeriesStack = this.seriesStack.slice(0);
          this.seriesStack.splice(stackIndex, 1);
          this.seriesStack.unshift(idx);
        };
        this.restorePreviousSeriesOrder = function() {
          var i2, j, serelem, shadelem, temp, move, keep;
          if (this.seriesStack == this.previousSeriesStack) {
            return;
          }
          for (i2 = 1; i2 < this.previousSeriesStack.length; i2++) {
            move = this.previousSeriesStack[i2];
            keep = this.previousSeriesStack[i2 - 1];
            serelem = this.series[move].canvas._elem.detach();
            shadelem = this.series[move].shadowCanvas._elem.detach();
            this.series[keep].shadowCanvas._elem.after(shadelem);
            this.series[keep].canvas._elem.after(serelem);
          }
          temp = this.seriesStack.slice(0);
          this.seriesStack = this.previousSeriesStack.slice(0);
          this.previousSeriesStack = temp;
        };
        this.restoreOriginalSeriesOrder = function() {
          var i2, j, arr = [], serelem, shadelem;
          for (i2 = 0; i2 < this.series.length; i2++) {
            arr.push(i2);
          }
          if (this.seriesStack == arr) {
            return;
          }
          this.previousSeriesStack = this.seriesStack.slice(0);
          this.seriesStack = arr;
          for (i2 = 1; i2 < this.seriesStack.length; i2++) {
            serelem = this.series[i2].canvas._elem.detach();
            shadelem = this.series[i2].shadowCanvas._elem.detach();
            this.series[i2 - 1].shadowCanvas._elem.after(shadelem);
            this.series[i2 - 1].canvas._elem.after(serelem);
          }
        };
        this.activateTheme = function(name) {
          this.themeEngine.activate(this, name);
        };
      }
      jqplot.computeHighlightColors = function(colors) {
        var ret;
        if (_jquery2.default.isArray(colors)) {
          ret = [];
          for (var i2 = 0; i2 < colors.length; i2++) {
            var rgba = jqplot.getColorComponents(colors[i2]);
            var newrgb = [rgba[0], rgba[1], rgba[2]];
            var sum = newrgb[0] + newrgb[1] + newrgb[2];
            for (var j = 0; j < 3; j++) {
              newrgb[j] = sum > 660 ? newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;
              newrgb[j] = parseInt(newrgb[j], 10);
              newrgb[j] > 255 ? 255 : newrgb[j];
            }
            newrgb[3] = 0.3 + 0.35 * rgba[3];
            ret.push("rgba(" + newrgb[0] + "," + newrgb[1] + "," + newrgb[2] + "," + newrgb[3] + ")");
          }
        } else {
          var rgba = jqplot.getColorComponents(colors);
          var newrgb = [rgba[0], rgba[1], rgba[2]];
          var sum = newrgb[0] + newrgb[1] + newrgb[2];
          for (var j = 0; j < 3; j++) {
            newrgb[j] = sum > 660 ? newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;
            newrgb[j] = parseInt(newrgb[j], 10);
            newrgb[j] > 255 ? 255 : newrgb[j];
          }
          newrgb[3] = 0.3 + 0.35 * rgba[3];
          ret = "rgba(" + newrgb[0] + "," + newrgb[1] + "," + newrgb[2] + "," + newrgb[3] + ")";
        }
        return ret;
      };
      var ColorGenerator = exports.ColorGenerator = jqplot.ColorGenerator = function(colors) {
        colors = colors || jqplot.config.defaultColors;
        var idx = 0;
        this.next = function() {
          if (idx < colors.length) {
            return colors[idx++];
          } else {
            idx = 0;
            return colors[idx++];
          }
        };
        this.previous = function() {
          if (idx > 0) {
            return colors[idx--];
          } else {
            idx = colors.length - 1;
            return colors[idx];
          }
        };
        this.get = function(i2) {
          var idx2 = i2 - colors.length * Math.floor(i2 / colors.length);
          return colors[idx2];
        };
        this.setColors = function(c2) {
          colors = c2;
        };
        this.reset = function() {
          idx = 0;
        };
        this.getIndex = function() {
          return idx;
        };
        this.setIndex = function(index) {
          idx = index;
        };
      };
      jqplot.hex2rgb = function(h, a) {
        h = h.replace("#", "");
        if (h.length == 3) {
          h = h.charAt(0) + h.charAt(0) + h.charAt(1) + h.charAt(1) + h.charAt(2) + h.charAt(2);
        }
        var rgb2;
        rgb2 = "rgba(" + parseInt(h.slice(0, 2), 16) + ", " + parseInt(h.slice(2, 4), 16) + ", " + parseInt(h.slice(4, 6), 16);
        if (a) {
          rgb2 += ", " + a;
        }
        rgb2 += ")";
        return rgb2;
      };
      jqplot.rgb2hex = function(s) {
        var pat = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *(?:, *[0-9.]*)?\)/;
        var m = s.match(pat);
        var h = "#";
        for (var i2 = 1; i2 < 4; i2++) {
          var temp;
          if (m[i2].search(/%/) != -1) {
            temp = parseInt(255 * m[i2] / 100, 10).toString(16);
            if (temp.length == 1) {
              temp = "0" + temp;
            }
          } else {
            temp = parseInt(m[i2], 10).toString(16);
            if (temp.length == 1) {
              temp = "0" + temp;
            }
          }
          h += temp;
        }
        return h;
      };
      jqplot.normalize2rgb = function(s, a) {
        if (s.search(/^ *rgba?\(/) != -1) {
          return s;
        } else if (s.search(/^ *#?[0-9a-fA-F]?[0-9a-fA-F]/) != -1) {
          return jqplot.hex2rgb(s, a);
        } else {
          throw new Error("Invalid color spec");
        }
      };
      jqplot.getColorComponents = function(s) {
        s = jqplot.colorKeywordMap[s] || s;
        var rgb2 = jqplot.normalize2rgb(s);
        var pat = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *,? *([0-9.]* *)?\)/;
        var m = rgb2.match(pat);
        var ret = [];
        for (var i2 = 1; i2 < 4; i2++) {
          if (m[i2].search(/%/) != -1) {
            ret[i2 - 1] = parseInt(255 * m[i2] / 100, 10);
          } else {
            ret[i2 - 1] = parseInt(m[i2], 10);
          }
        }
        ret[3] = parseFloat(m[4]) ? parseFloat(m[4]) : 1;
        return ret;
      };
      jqplot.colorKeywordMap = {
        aliceblue: "rgb(240, 248, 255)",
        antiquewhite: "rgb(250, 235, 215)",
        aqua: "rgb( 0, 255, 255)",
        aquamarine: "rgb(127, 255, 212)",
        azure: "rgb(240, 255, 255)",
        beige: "rgb(245, 245, 220)",
        bisque: "rgb(255, 228, 196)",
        black: "rgb( 0, 0, 0)",
        blanchedalmond: "rgb(255, 235, 205)",
        blue: "rgb( 0, 0, 255)",
        blueviolet: "rgb(138, 43, 226)",
        brown: "rgb(165, 42, 42)",
        burlywood: "rgb(222, 184, 135)",
        cadetblue: "rgb( 95, 158, 160)",
        chartreuse: "rgb(127, 255, 0)",
        chocolate: "rgb(210, 105, 30)",
        coral: "rgb(255, 127, 80)",
        cornflowerblue: "rgb(100, 149, 237)",
        cornsilk: "rgb(255, 248, 220)",
        crimson: "rgb(220, 20, 60)",
        cyan: "rgb( 0, 255, 255)",
        darkblue: "rgb( 0, 0, 139)",
        darkcyan: "rgb( 0, 139, 139)",
        darkgoldenrod: "rgb(184, 134, 11)",
        darkgray: "rgb(169, 169, 169)",
        darkgreen: "rgb( 0, 100, 0)",
        darkgrey: "rgb(169, 169, 169)",
        darkkhaki: "rgb(189, 183, 107)",
        darkmagenta: "rgb(139, 0, 139)",
        darkolivegreen: "rgb( 85, 107, 47)",
        darkorange: "rgb(255, 140, 0)",
        darkorchid: "rgb(153, 50, 204)",
        darkred: "rgb(139, 0, 0)",
        darksalmon: "rgb(233, 150, 122)",
        darkseagreen: "rgb(143, 188, 143)",
        darkslateblue: "rgb( 72, 61, 139)",
        darkslategray: "rgb( 47, 79, 79)",
        darkslategrey: "rgb( 47, 79, 79)",
        darkturquoise: "rgb( 0, 206, 209)",
        darkviolet: "rgb(148, 0, 211)",
        deeppink: "rgb(255, 20, 147)",
        deepskyblue: "rgb( 0, 191, 255)",
        dimgray: "rgb(105, 105, 105)",
        dimgrey: "rgb(105, 105, 105)",
        dodgerblue: "rgb( 30, 144, 255)",
        firebrick: "rgb(178, 34, 34)",
        floralwhite: "rgb(255, 250, 240)",
        forestgreen: "rgb( 34, 139, 34)",
        fuchsia: "rgb(255, 0, 255)",
        gainsboro: "rgb(220, 220, 220)",
        ghostwhite: "rgb(248, 248, 255)",
        gold: "rgb(255, 215, 0)",
        goldenrod: "rgb(218, 165, 32)",
        gray: "rgb(128, 128, 128)",
        grey: "rgb(128, 128, 128)",
        green: "rgb( 0, 128, 0)",
        greenyellow: "rgb(173, 255, 47)",
        honeydew: "rgb(240, 255, 240)",
        hotpink: "rgb(255, 105, 180)",
        indianred: "rgb(205, 92, 92)",
        indigo: "rgb( 75, 0, 130)",
        ivory: "rgb(255, 255, 240)",
        khaki: "rgb(240, 230, 140)",
        lavender: "rgb(230, 230, 250)",
        lavenderblush: "rgb(255, 240, 245)",
        lawngreen: "rgb(124, 252, 0)",
        lemonchiffon: "rgb(255, 250, 205)",
        lightblue: "rgb(173, 216, 230)",
        lightcoral: "rgb(240, 128, 128)",
        lightcyan: "rgb(224, 255, 255)",
        lightgoldenrodyellow: "rgb(250, 250, 210)",
        lightgray: "rgb(211, 211, 211)",
        lightgreen: "rgb(144, 238, 144)",
        lightgrey: "rgb(211, 211, 211)",
        lightpink: "rgb(255, 182, 193)",
        lightsalmon: "rgb(255, 160, 122)",
        lightseagreen: "rgb( 32, 178, 170)",
        lightskyblue: "rgb(135, 206, 250)",
        lightslategray: "rgb(119, 136, 153)",
        lightslategrey: "rgb(119, 136, 153)",
        lightsteelblue: "rgb(176, 196, 222)",
        lightyellow: "rgb(255, 255, 224)",
        lime: "rgb( 0, 255, 0)",
        limegreen: "rgb( 50, 205, 50)",
        linen: "rgb(250, 240, 230)",
        magenta: "rgb(255, 0, 255)",
        maroon: "rgb(128, 0, 0)",
        mediumaquamarine: "rgb(102, 205, 170)",
        mediumblue: "rgb( 0, 0, 205)",
        mediumorchid: "rgb(186, 85, 211)",
        mediumpurple: "rgb(147, 112, 219)",
        mediumseagreen: "rgb( 60, 179, 113)",
        mediumslateblue: "rgb(123, 104, 238)",
        mediumspringgreen: "rgb( 0, 250, 154)",
        mediumturquoise: "rgb( 72, 209, 204)",
        mediumvioletred: "rgb(199, 21, 133)",
        midnightblue: "rgb( 25, 25, 112)",
        mintcream: "rgb(245, 255, 250)",
        mistyrose: "rgb(255, 228, 225)",
        moccasin: "rgb(255, 228, 181)",
        navajowhite: "rgb(255, 222, 173)",
        navy: "rgb( 0, 0, 128)",
        oldlace: "rgb(253, 245, 230)",
        olive: "rgb(128, 128, 0)",
        olivedrab: "rgb(107, 142, 35)",
        orange: "rgb(255, 165, 0)",
        orangered: "rgb(255, 69, 0)",
        orchid: "rgb(218, 112, 214)",
        palegoldenrod: "rgb(238, 232, 170)",
        palegreen: "rgb(152, 251, 152)",
        paleturquoise: "rgb(175, 238, 238)",
        palevioletred: "rgb(219, 112, 147)",
        papayawhip: "rgb(255, 239, 213)",
        peachpuff: "rgb(255, 218, 185)",
        peru: "rgb(205, 133, 63)",
        pink: "rgb(255, 192, 203)",
        plum: "rgb(221, 160, 221)",
        powderblue: "rgb(176, 224, 230)",
        purple: "rgb(128, 0, 128)",
        red: "rgb(255, 0, 0)",
        rosybrown: "rgb(188, 143, 143)",
        royalblue: "rgb( 65, 105, 225)",
        saddlebrown: "rgb(139, 69, 19)",
        salmon: "rgb(250, 128, 114)",
        sandybrown: "rgb(244, 164, 96)",
        seagreen: "rgb( 46, 139, 87)",
        seashell: "rgb(255, 245, 238)",
        sienna: "rgb(160, 82, 45)",
        silver: "rgb(192, 192, 192)",
        skyblue: "rgb(135, 206, 235)",
        slateblue: "rgb(106, 90, 205)",
        slategray: "rgb(112, 128, 144)",
        slategrey: "rgb(112, 128, 144)",
        snow: "rgb(255, 250, 250)",
        springgreen: "rgb( 0, 255, 127)",
        steelblue: "rgb( 70, 130, 180)",
        tan: "rgb(210, 180, 140)",
        teal: "rgb( 0, 128, 128)",
        thistle: "rgb(216, 191, 216)",
        tomato: "rgb(255, 99, 71)",
        turquoise: "rgb( 64, 224, 208)",
        violet: "rgb(238, 130, 238)",
        wheat: "rgb(245, 222, 179)",
        white: "rgb(255, 255, 255)",
        whitesmoke: "rgb(245, 245, 245)",
        yellow: "rgb(255, 255, 0)",
        yellowgreen: "rgb(154, 205, 50)"
      };
    }
  });

  // node_modules/jqplot-exported/AxisLabelRenderer.js
  var require_AxisLabelRenderer = __commonJS({
    "node_modules/jqplot-exported/AxisLabelRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AxisLabelRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var AxisLabelRenderer = exports.AxisLabelRenderer = _jqplot2.default.AxisLabelRenderer = function(options2) {
        _jqplot2.default.ElemContainer.call(this);
        this.axis;
        this.show = true;
        this.label = "";
        this.fontFamily = null;
        this.fontSize = null;
        this.textColor = null;
        this._elem;
        this.escapeHTML = false;
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.AxisLabelRenderer.prototype = new _jqplot2.default.ElemContainer();
      _jqplot2.default.AxisLabelRenderer.prototype.constructor = _jqplot2.default.AxisLabelRenderer;
      _jqplot2.default.AxisLabelRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.AxisLabelRenderer.prototype.draw = function(ctx, plot) {
        if (this._elem) {
          this._elem.emptyForce();
          this._elem = null;
        }
        this._elem = (0, _jquery2.default)('<div style="position:absolute;" class="jqplot-' + this.axis + '-label"></div>');
        if (Number(this.label)) {
          this._elem.css("white-space", "nowrap");
        }
        if (!this.escapeHTML) {
          this._elem.html(this.label);
        } else {
          this._elem.text(this.label);
        }
        if (this.fontFamily) {
          this._elem.css("font-family", this.fontFamily);
        }
        if (this.fontSize) {
          this._elem.css("font-size", this.fontSize);
        }
        if (this.textColor) {
          this._elem.css("color", this.textColor);
        }
        return this._elem;
      };
      _jqplot2.default.AxisLabelRenderer.prototype.pack = function() {
      };
    }
  });

  // node_modules/jqplot-exported/AxisTickRenderer.js
  var require_AxisTickRenderer = __commonJS({
    "node_modules/jqplot-exported/AxisTickRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PercentTickFormatter = exports.DefaultTickFormatter = exports.AxisTickRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var AxisTickRenderer = exports.AxisTickRenderer = _jqplot2.default.AxisTickRenderer = function(options2) {
        _jqplot2.default.ElemContainer.call(this);
        this.mark = "outside";
        this.axis;
        this.showMark = true;
        this.showGridline = true;
        this.isMinorTick = false;
        this.size = 4;
        this.markSize = 6;
        this.show = true;
        this.showLabel = true;
        this.label = null;
        this.value = null;
        this._styles = {};
        this.formatter = _jqplot2.default.DefaultTickFormatter;
        this.prefix = "";
        this.suffix = "";
        this.formatString = "";
        this.fontFamily;
        this.fontSize;
        this.textColor;
        this.escapeHTML = false;
        this._elem;
        this._breakTick = false;
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.AxisTickRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.AxisTickRenderer.prototype = new _jqplot2.default.ElemContainer();
      _jqplot2.default.AxisTickRenderer.prototype.constructor = _jqplot2.default.AxisTickRenderer;
      _jqplot2.default.AxisTickRenderer.prototype.setTick = function(value, axisName, isMinor) {
        this.value = value;
        this.axis = axisName;
        if (isMinor) {
          this.isMinorTick = true;
        }
        return this;
      };
      _jqplot2.default.AxisTickRenderer.prototype.draw = function() {
        if (this.label === null) {
          this.label = this.prefix + this.formatter(this.formatString, this.value) + this.suffix;
        }
        var style = { position: "absolute" };
        if (Number(this.label)) {
          style["whitSpace"] = "nowrap";
        }
        if (this._elem) {
          this._elem.emptyForce();
          this._elem = null;
        }
        this._elem = (0, _jquery2.default)(document.createElement("div"));
        this._elem.addClass("jqplot-" + this.axis + "-tick");
        if (!this.escapeHTML) {
          this._elem.html(this.label);
        } else {
          this._elem.text(this.label);
        }
        this._elem.css(style);
        for (var s in this._styles) {
          this._elem.css(s, this._styles[s]);
        }
        if (this.fontFamily) {
          this._elem.css("font-family", this.fontFamily);
        }
        if (this.fontSize) {
          this._elem.css("font-size", this.fontSize);
        }
        if (this.textColor) {
          this._elem.css("color", this.textColor);
        }
        if (this._breakTick) {
          this._elem.addClass("jqplot-breakTick");
        }
        return this._elem;
      };
      var DefaultTickFormatter = exports.DefaultTickFormatter = _jqplot2.default.DefaultTickFormatter = function(format, val) {
        if (typeof val == "number") {
          if (!format) {
            format = _jqplot2.default.config.defaultTickFormatString;
          }
          return _jqplot2.default.sprintf(format, val);
        } else {
          return String(val);
        }
      };
      var PercentTickFormatter = exports.PercentTickFormatter = _jqplot2.default.PercentTickFormatter = function(format, val) {
        if (typeof val == "number") {
          val = 100 * val;
          if (!format) {
            format = _jqplot2.default.config.defaultTickFormatString;
          }
          return _jqplot2.default.sprintf(format, val);
        } else {
          return String(val);
        }
      };
      _jqplot2.default.AxisTickRenderer.prototype.pack = function() {
      };
    }
  });

  // node_modules/jqplot-exported/CanvasGridRenderer.js
  var require_CanvasGridRenderer = __commonJS({
    "node_modules/jqplot-exported/CanvasGridRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CanvasGridRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var CanvasGridRenderer = exports.CanvasGridRenderer = _jqplot2.default.CanvasGridRenderer = function() {
        this.shadowRenderer = new _jqplot2.default.ShadowRenderer();
      };
      _jqplot2.default.CanvasGridRenderer.prototype.init = function(options2) {
        this._ctx;
        _jquery2.default.extend(true, this, options2);
        var sopts = { lineJoin: "miter", lineCap: "round", fill: false, isarc: false, angle: this.shadowAngle, offset: this.shadowOffset, alpha: this.shadowAlpha, depth: this.shadowDepth, lineWidth: this.shadowWidth, closePath: false, strokeStyle: this.shadowColor };
        this.renderer.shadowRenderer.init(sopts);
      };
      _jqplot2.default.CanvasGridRenderer.prototype.createElement = function(plot) {
        var elem;
        if (this._elem) {
          if (_jqplot2.default.use_excanvas && window.G_vmlCanvasManager.uninitElement !== void 0) {
            elem = this._elem.get(0);
            window.G_vmlCanvasManager.uninitElement(elem);
            elem = null;
          }
          this._elem.emptyForce();
          this._elem = null;
        }
        elem = plot.canvasManager.getCanvas();
        var w = this._plotDimensions.width;
        var h = this._plotDimensions.height;
        elem.width = w;
        elem.height = h;
        this._elem = (0, _jquery2.default)(elem);
        this._elem.addClass("jqplot-grid-canvas");
        this._elem.css({ position: "absolute", left: 0, top: 0 });
        elem = plot.canvasManager.initCanvas(elem);
        this._top = this._offsets.top;
        this._bottom = h - this._offsets.bottom;
        this._left = this._offsets.left;
        this._right = w - this._offsets.right;
        this._width = this._right - this._left;
        this._height = this._bottom - this._top;
        elem = null;
        return this._elem;
      };
      _jqplot2.default.CanvasGridRenderer.prototype.draw = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        var ctx = this._ctx;
        var axes = this._axes;
        ctx.save();
        ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height);
        ctx.fillStyle = this.backgroundColor || this.background;
        ctx.fillRect(this._left, this._top, this._width, this._height);
        ctx.save();
        ctx.lineJoin = "miter";
        ctx.lineCap = "butt";
        ctx.lineWidth = this.gridLineWidth;
        ctx.strokeStyle = this.gridLineColor;
        var b, e, s, m;
        var ax = ["xaxis", "yaxis", "x2axis", "y2axis"];
        for (var i2 = 4; i2 > 0; i2--) {
          var name = ax[i2 - 1];
          var axis = axes[name];
          var ticks = axis._ticks;
          var numticks = ticks.length;
          if (axis.show) {
            if (axis.drawBaseline) {
              var bopts = {};
              if (axis.baselineWidth !== null) {
                bopts.lineWidth = axis.baselineWidth;
              }
              if (axis.baselineColor !== null) {
                bopts.strokeStyle = axis.baselineColor;
              }
              switch (name) {
                case "xaxis":
                  drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                  break;
                case "yaxis":
                  drawLine(this._left, this._bottom, this._left, this._top, bopts);
                  break;
                case "x2axis":
                  drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                  break;
                case "y2axis":
                  drawLine(this._right, this._bottom, this._right, this._top, bopts);
                  break;
              }
            }
            for (var j = numticks; j > 0; j--) {
              var t = ticks[j - 1];
              if (t.show) {
                var pos = Math.round(axis.u2p(t.value)) + 0.5;
                switch (name) {
                  case "xaxis":
                    if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines)) {
                      drawLine(pos, this._top, pos, this._bottom);
                    }
                    if (t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                      s = t.markSize;
                      m = t.mark;
                      var pos = Math.round(axis.u2p(t.value)) + 0.5;
                      switch (m) {
                        case "outside":
                          b = this._bottom;
                          e = this._bottom + s;
                          break;
                        case "inside":
                          b = this._bottom - s;
                          e = this._bottom;
                          break;
                        case "cross":
                          b = this._bottom - s;
                          e = this._bottom + s;
                          break;
                        default:
                          b = this._bottom;
                          e = this._bottom + s;
                          break;
                      }
                      if (this.shadow) {
                        this.renderer.shadowRenderer.draw(ctx, [[pos, b], [pos, e]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * 0.75, depth: 2, fill: false, closePath: false });
                      }
                      drawLine(pos, b, pos, e);
                    }
                    break;
                  case "yaxis":
                    if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines)) {
                      drawLine(this._right, pos, this._left, pos);
                    }
                    if (t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                      s = t.markSize;
                      m = t.mark;
                      var pos = Math.round(axis.u2p(t.value)) + 0.5;
                      switch (m) {
                        case "outside":
                          b = this._left - s;
                          e = this._left;
                          break;
                        case "inside":
                          b = this._left;
                          e = this._left + s;
                          break;
                        case "cross":
                          b = this._left - s;
                          e = this._left + s;
                          break;
                        default:
                          b = this._left - s;
                          e = this._left;
                          break;
                      }
                      if (this.shadow) {
                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * 0.75, fill: false, closePath: false });
                      }
                      drawLine(b, pos, e, pos, { strokeStyle: axis.borderColor });
                    }
                    break;
                  case "x2axis":
                    if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines)) {
                      drawLine(pos, this._bottom, pos, this._top);
                    }
                    if (t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                      s = t.markSize;
                      m = t.mark;
                      var pos = Math.round(axis.u2p(t.value)) + 0.5;
                      switch (m) {
                        case "outside":
                          b = this._top - s;
                          e = this._top;
                          break;
                        case "inside":
                          b = this._top;
                          e = this._top + s;
                          break;
                        case "cross":
                          b = this._top - s;
                          e = this._top + s;
                          break;
                        default:
                          b = this._top - s;
                          e = this._top;
                          break;
                      }
                      if (this.shadow) {
                        this.renderer.shadowRenderer.draw(ctx, [[pos, b], [pos, e]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * 0.75, depth: 2, fill: false, closePath: false });
                      }
                      drawLine(pos, b, pos, e);
                    }
                    break;
                  case "y2axis":
                    if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines)) {
                      drawLine(this._left, pos, this._right, pos);
                    }
                    if (t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                      s = t.markSize;
                      m = t.mark;
                      var pos = Math.round(axis.u2p(t.value)) + 0.5;
                      switch (m) {
                        case "outside":
                          b = this._right;
                          e = this._right + s;
                          break;
                        case "inside":
                          b = this._right - s;
                          e = this._right;
                          break;
                        case "cross":
                          b = this._right - s;
                          e = this._right + s;
                          break;
                        default:
                          b = this._right;
                          e = this._right + s;
                          break;
                      }
                      if (this.shadow) {
                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * 0.75, fill: false, closePath: false });
                      }
                      drawLine(b, pos, e, pos, { strokeStyle: axis.borderColor });
                    }
                    break;
                  default:
                    break;
                }
              }
            }
            t = null;
          }
          axis = null;
          ticks = null;
        }
        ax = ["y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis"];
        for (var i2 = 7; i2 > 0; i2--) {
          var axis = axes[ax[i2 - 1]];
          var ticks = axis._ticks;
          if (axis.show) {
            var tn = ticks[axis.numberTicks - 1];
            var t0 = ticks[0];
            var left = axis.getLeft();
            var points = [[left, tn.getTop() + tn.getHeight() / 2], [left, t0.getTop() + t0.getHeight() / 2 + 1]];
            if (this.shadow) {
              this.renderer.shadowRenderer.draw(ctx, points, { lineCap: "butt", fill: false, closePath: false });
            }
            drawLine(points[0][0], points[0][1], points[1][0], points[1][1], { lineCap: "butt", strokeStyle: axis.borderColor, lineWidth: axis.borderWidth });
            for (var j = ticks.length; j > 0; j--) {
              var t = ticks[j - 1];
              s = t.markSize;
              m = t.mark;
              var pos = Math.round(axis.u2p(t.value)) + 0.5;
              if (t.showMark && t.mark) {
                switch (m) {
                  case "outside":
                    b = left;
                    e = left + s;
                    break;
                  case "inside":
                    b = left - s;
                    e = left;
                    break;
                  case "cross":
                    b = left - s;
                    e = left + s;
                    break;
                  default:
                    b = left;
                    e = left + s;
                    break;
                }
                points = [[b, pos], [e, pos]];
                if (this.shadow) {
                  this.renderer.shadowRenderer.draw(ctx, points, { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * 0.75, fill: false, closePath: false });
                }
                drawLine(b, pos, e, pos, { strokeStyle: axis.borderColor });
              }
              t = null;
            }
            t0 = null;
          }
          axis = null;
          ticks = null;
        }
        ctx.restore();
        function drawLine(bx, by, ex, ey, opts) {
          ctx.save();
          opts = opts || {};
          if (opts.lineWidth == null || opts.lineWidth != 0) {
            _jquery2.default.extend(true, ctx, opts);
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            ctx.restore();
          }
        }
        if (this.shadow) {
          var points = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]];
          this.renderer.shadowRenderer.draw(ctx, points);
        }
        if (this.borderWidth != 0 && this.drawBorder) {
          drawLine(this._left, this._top, this._right, this._top, { lineCap: "round", strokeStyle: axes.x2axis.borderColor, lineWidth: axes.x2axis.borderWidth });
          drawLine(this._right, this._top, this._right, this._bottom, { lineCap: "round", strokeStyle: axes.y2axis.borderColor, lineWidth: axes.y2axis.borderWidth });
          drawLine(this._right, this._bottom, this._left, this._bottom, { lineCap: "round", strokeStyle: axes.xaxis.borderColor, lineWidth: axes.xaxis.borderWidth });
          drawLine(this._left, this._bottom, this._left, this._top, { lineCap: "round", strokeStyle: axes.yaxis.borderColor, lineWidth: axes.yaxis.borderWidth });
        }
        ctx.restore();
        ctx = null;
        axes = null;
      };
    }
  });

  // node_modules/jqplot-exported/DivTitleRenderer.js
  var require_DivTitleRenderer = __commonJS({
    "node_modules/jqplot-exported/DivTitleRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DivTitleRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var DivTitleRenderer = exports.DivTitleRenderer = _jqplot2.default.DivTitleRenderer = function() {
      };
      _jqplot2.default.DivTitleRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.DivTitleRenderer.prototype.draw = function() {
        if (this._elem) {
          this._elem.emptyForce();
          this._elem = null;
        }
        var r = this.renderer;
        var elem = document.createElement("div");
        this._elem = (0, _jquery2.default)(elem);
        this._elem.addClass("jqplot-title");
        if (!this.text) {
          this.show = false;
          this._elem.height(0);
          this._elem.width(0);
        } else if (this.text) {
          var color;
          if (this.color) {
            color = this.color;
          } else if (this.textColor) {
            color = this.textColor;
          }
          var styles = { position: "absolute", top: "0px", left: "0px" };
          if (this._plotWidth) {
            styles["width"] = this._plotWidth + "px";
          }
          if (this.fontSize) {
            styles["fontSize"] = this.fontSize;
          }
          if (typeof this.textAlign === "string") {
            styles["textAlign"] = this.textAlign;
          } else {
            styles["textAlign"] = "center";
          }
          if (color) {
            styles["color"] = color;
          }
          if (this.paddingBottom) {
            styles["paddingBottom"] = this.paddingBottom;
          }
          if (this.fontFamily) {
            styles["fontFamily"] = this.fontFamily;
          }
          this._elem.css(styles);
          if (this.escapeHtml) {
            this._elem.text(this.text);
          } else {
            this._elem.html(this.text);
          }
        }
        elem = null;
        return this._elem;
      };
      _jqplot2.default.DivTitleRenderer.prototype.pack = function() {
      };
    }
  });

  // node_modules/jqplot-exported/LinePattern.js
  var require_LinePattern = __commonJS({
    "node_modules/jqplot-exported/LinePattern.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LinePattern = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var dotlen = 0.1;
      var LinePattern = exports.LinePattern = _jqplot2.default.LinePattern = function(ctx, pattern) {
        var defaultLinePatterns = {
          dotted: [dotlen, _jqplot2.default.config.dotGapLength],
          dashed: [_jqplot2.default.config.dashLength, _jqplot2.default.config.gapLength],
          solid: null
        };
        if (typeof pattern === "string") {
          if (pattern[0] === "." || pattern[0] === "-") {
            var s = pattern;
            pattern = [];
            for (var i2 = 0, imax = s.length; i2 < imax; i2++) {
              if (s[i2] === ".") {
                pattern.push(dotlen);
              } else if (s[i2] === "-") {
                pattern.push(_jqplot2.default.config.dashLength);
              } else {
                continue;
              }
              pattern.push(_jqplot2.default.config.gapLength);
            }
          } else {
            pattern = defaultLinePatterns[pattern];
          }
        }
        if (!(pattern && pattern.length)) {
          return ctx;
        }
        var patternIndex = 0;
        var patternDistance = pattern[0];
        var px = 0;
        var py = 0;
        var pathx0 = 0;
        var pathy0 = 0;
        var moveTo = function moveTo2(x, y) {
          ctx.moveTo(x, y);
          px = x;
          py = y;
          pathx0 = x;
          pathy0 = y;
        };
        var lineTo = function lineTo2(x, y) {
          var scale2 = ctx.lineWidth;
          var dx = x - px;
          var dy = y - py;
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0 && scale2 > 0) {
            dx /= dist;
            dy /= dist;
            while (true) {
              var dp = scale2 * patternDistance;
              if (dp < dist) {
                px += dp * dx;
                py += dp * dy;
                if ((patternIndex & 1) == 0) {
                  ctx.lineTo(px, py);
                } else {
                  ctx.moveTo(px, py);
                }
                dist -= dp;
                patternIndex++;
                if (patternIndex >= pattern.length) {
                  patternIndex = 0;
                }
                patternDistance = pattern[patternIndex];
              } else {
                px = x;
                py = y;
                if ((patternIndex & 1) == 0) {
                  ctx.lineTo(px, py);
                } else {
                  ctx.moveTo(px, py);
                }
                patternDistance -= dist / scale2;
                break;
              }
            }
          }
        };
        var beginPath = function beginPath2() {
          ctx.beginPath();
        };
        var closePath = function closePath2() {
          lineTo(pathx0, pathy0);
        };
        return {
          moveTo,
          lineTo,
          beginPath,
          closePath
        };
      };
    }
  });

  // node_modules/jqplot-exported/LineRenderer.js
  var require_LineRenderer = __commonJS({
    "node_modules/jqplot-exported/LineRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LineRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var LineRenderer = exports.LineRenderer = _jqplot2.default.LineRenderer = function() {
        this.shapeRenderer = new _jqplot2.default.ShapeRenderer();
        this.shadowRenderer = new _jqplot2.default.ShadowRenderer();
      };
      _jqplot2.default.LineRenderer.prototype.init = function(options2, plot) {
        options2 = options2 || {};
        this._type = "line";
        this.renderer.animation = {
          show: false,
          direction: "left",
          speed: 2500,
          _supported: true
        };
        this.renderer.smooth = false;
        this.renderer.tension = null;
        this.renderer.constrainSmoothing = true;
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        this.renderer.bandData = [];
        this.renderer.bands = {
          show: false,
          hiData: [],
          lowData: [],
          color: this.color,
          showLines: false,
          fill: true,
          fillColor: null,
          _min: null,
          _max: null,
          interval: "3%"
        };
        var lopts = { highlightMouseOver: options2.highlightMouseOver, highlightMouseDown: options2.highlightMouseDown, highlightColor: options2.highlightColor };
        delete options2.highlightMouseOver;
        delete options2.highlightMouseDown;
        delete options2.highlightColor;
        _jquery2.default.extend(true, this.renderer, options2);
        this.renderer.options = options2;
        if (this.renderer.bandData.length > 1 && (!options2.bands || options2.bands.show == null)) {
          this.renderer.bands.show = true;
        } else if (options2.bands && options2.bands.show == null && options2.bands.interval != null) {
          this.renderer.bands.show = true;
        }
        if (this.fill) {
          this.renderer.bands.show = false;
        }
        if (this.renderer.bands.show) {
          this.renderer.initBands.call(this, this.renderer.options, plot);
        }
        if (this._stack) {
          this.renderer.smooth = false;
        }
        var opts = { lineJoin: this.lineJoin, lineCap: this.lineCap, fill: this.fill, isarc: false, strokeStyle: this.color, fillStyle: this.fillColor, lineWidth: this.lineWidth, linePattern: this.linePattern, closePath: this.fill };
        this.renderer.shapeRenderer.init(opts);
        var shadow_offset = options2.shadowOffset;
        if (shadow_offset == null) {
          if (this.lineWidth > 2.5) {
            shadow_offset = 1.25 * (1 + (Math.atan(this.lineWidth / 2.5) / 0.785398163 - 1) * 0.6);
          } else {
            shadow_offset = 1.25 * Math.atan(this.lineWidth / 2.5) / 0.785398163;
          }
        }
        var sopts = { lineJoin: this.lineJoin, lineCap: this.lineCap, fill: this.fill, isarc: false, angle: this.shadowAngle, offset: shadow_offset, alpha: this.shadowAlpha, depth: this.shadowDepth, lineWidth: this.lineWidth, linePattern: this.linePattern, closePath: this.fill };
        this.renderer.shadowRenderer.init(sopts);
        this._areaPoints = [];
        this._boundingBox = [[], []];
        if (!this.isTrendline && this.fill || this.renderer.bands.show) {
          this.highlightMouseOver = true;
          this.highlightMouseDown = false;
          this.highlightColor = null;
          if (lopts.highlightMouseDown && lopts.highlightMouseOver == null) {
            lopts.highlightMouseOver = false;
          }
          _jquery2.default.extend(true, this, { highlightMouseOver: lopts.highlightMouseOver, highlightMouseDown: lopts.highlightMouseDown, highlightColor: lopts.highlightColor });
          if (!this.highlightColor) {
            var fc = this.renderer.bands.show ? this.renderer.bands.fillColor : this.fillColor;
            this.highlightColor = _jqplot2.default.computeHighlightColors(fc);
          }
          if (this.highlighter) {
            this.highlighter.show = false;
          }
        }
        if (!this.isTrendline && plot) {
          plot.plugins.lineRenderer = {};
          plot.postInitHooks.addOnce(postInit);
          plot.postDrawHooks.addOnce(postPlotDraw);
          plot.eventListenerHooks.addOnce("jqplotMouseMove", handleMove);
          plot.eventListenerHooks.addOnce("jqplotMouseDown", handleMouseDown);
          plot.eventListenerHooks.addOnce("jqplotMouseUp", handleMouseUp);
          plot.eventListenerHooks.addOnce("jqplotClick", handleClick);
          plot.eventListenerHooks.addOnce("jqplotRightClick", handleRightClick);
        }
      };
      _jqplot2.default.LineRenderer.prototype.initBands = function(options2, plot) {
        var bd = options2.bandData || [];
        var bands = this.renderer.bands;
        bands.hiData = [];
        bands.lowData = [];
        var data = this.data;
        bands._max = null;
        bands._min = null;
        if (bd.length == 2) {
          if (_jquery2.default.isArray(bd[0][0])) {
            var p;
            var bdminidx = 0, bdmaxidx = 0;
            for (var i2 = 0, l = bd[0].length; i2 < l; i2++) {
              p = bd[0][i2];
              if (p[1] != null && p[1] > bands._max || bands._max == null) {
                bands._max = p[1];
              }
              if (p[1] != null && p[1] < bands._min || bands._min == null) {
                bands._min = p[1];
              }
            }
            for (var i2 = 0, l = bd[1].length; i2 < l; i2++) {
              p = bd[1][i2];
              if (p[1] != null && p[1] > bands._max || bands._max == null) {
                bands._max = p[1];
                bdmaxidx = 1;
              }
              if (p[1] != null && p[1] < bands._min || bands._min == null) {
                bands._min = p[1];
                bdminidx = 1;
              }
            }
            if (bdmaxidx === bdminidx) {
              bands.show = false;
            }
            bands.hiData = bd[bdmaxidx];
            bands.lowData = bd[bdminidx];
          } else if (bd[0].length === data.length && bd[1].length === data.length) {
            var hi = bd[0][0] > bd[1][0] ? 0 : 1;
            var low = hi ? 0 : 1;
            for (var i2 = 0, l = data.length; i2 < l; i2++) {
              bands.hiData.push([data[i2][0], bd[hi][i2]]);
              bands.lowData.push([data[i2][0], bd[low][i2]]);
            }
          } else {
            bands.show = false;
          }
        } else if (bd.length > 2 && !_jquery2.default.isArray(bd[0][0])) {
          var hi = bd[0][0] > bd[0][1] ? 0 : 1;
          var low = hi ? 0 : 1;
          for (var i2 = 0, l = bd.length; i2 < l; i2++) {
            bands.hiData.push([data[i2][0], bd[i2][hi]]);
            bands.lowData.push([data[i2][0], bd[i2][low]]);
          }
        } else {
          var intrv = bands.interval;
          var a = null;
          var b = null;
          var afunc = null;
          var bfunc = null;
          if (_jquery2.default.isArray(intrv)) {
            a = intrv[0];
            b = intrv[1];
          } else {
            a = intrv;
          }
          if (isNaN(a)) {
            if (a.charAt(a.length - 1) === "%") {
              afunc = "multiply";
              a = parseFloat(a) / 100 + 1;
            }
          } else {
            a = parseFloat(a);
            afunc = "add";
          }
          if (b !== null && isNaN(b)) {
            if (b.charAt(b.length - 1) === "%") {
              bfunc = "multiply";
              b = parseFloat(b) / 100 + 1;
            }
          } else if (b !== null) {
            b = parseFloat(b);
            bfunc = "add";
          }
          if (a !== null) {
            if (b === null) {
              b = -a;
              bfunc = afunc;
              if (bfunc === "multiply") {
                b += 2;
              }
            }
            if (a < b) {
              var temp = a;
              a = b;
              b = temp;
              temp = afunc;
              afunc = bfunc;
              bfunc = temp;
            }
            for (var i2 = 0, l = data.length; i2 < l; i2++) {
              switch (afunc) {
                case "add":
                  bands.hiData.push([data[i2][0], data[i2][1] + a]);
                  break;
                case "multiply":
                  bands.hiData.push([data[i2][0], data[i2][1] * a]);
                  break;
              }
              switch (bfunc) {
                case "add":
                  bands.lowData.push([data[i2][0], data[i2][1] + b]);
                  break;
                case "multiply":
                  bands.lowData.push([data[i2][0], data[i2][1] * b]);
                  break;
              }
            }
          } else {
            bands.show = false;
          }
        }
        var hd = bands.hiData;
        var ld = bands.lowData;
        for (var i2 = 0, l = hd.length; i2 < l; i2++) {
          if (hd[i2][1] != null && hd[i2][1] > bands._max || bands._max == null) {
            bands._max = hd[i2][1];
          }
        }
        for (var i2 = 0, l = ld.length; i2 < l; i2++) {
          if (ld[i2][1] != null && ld[i2][1] < bands._min || bands._min == null) {
            bands._min = ld[i2][1];
          }
        }
        if (bands.fillColor === null) {
          var c2 = _jqplot2.default.getColorComponents(bands.color);
          c2[3] = c2[3] * 0.5;
          bands.fillColor = "rgba(" + c2[0] + ", " + c2[1] + ", " + c2[2] + ", " + c2[3] + ")";
        }
      };
      function getSteps(d2, f) {
        return (3.4182054 + f) * Math.pow(d2, -0.3534992);
      }
      function tanh(x) {
        var a = (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
        return a;
      }
      function computeConstrainedSmoothedData(gd) {
        var smooth = this.renderer.smooth;
        var dim = this.canvas.getWidth();
        var xp = this._xaxis.series_p2u;
        var yp = this._yaxis.series_p2u;
        var steps = null;
        var _steps = null;
        var dist = gd.length / dim;
        var _smoothedData = [];
        var _smoothedPlotData = [];
        if (!isNaN(parseFloat(smooth))) {
          steps = parseFloat(smooth);
        } else {
          steps = getSteps(dist, 0.5);
        }
        var yy = [];
        var xx = [];
        for (var i2 = 0, l = gd.length; i2 < l; i2++) {
          yy.push(gd[i2][1]);
          xx.push(gd[i2][0]);
        }
        function dxx(x1, x0) {
          if (x1 - x0 == 0) {
            return Math.pow(10, 10);
          } else {
            return x1 - x0;
          }
        }
        var A, B, C, D;
        var nmax = gd.length - 1;
        for (var num = 1, gdl = gd.length; num < gdl; num++) {
          var gxx = [];
          var ggxx = [];
          for (var j = 0; j < 2; j++) {
            var i2 = num - 1 + j;
            if (i2 == 0 || i2 == nmax) {
              gxx[j] = Math.pow(10, 10);
            } else if (yy[i2 + 1] - yy[i2] == 0 || yy[i2] - yy[i2 - 1] == 0) {
              gxx[j] = 0;
            } else if ((xx[i2 + 1] - xx[i2]) / (yy[i2 + 1] - yy[i2]) + (xx[i2] - xx[i2 - 1]) / (yy[i2] - yy[i2 - 1]) == 0) {
              gxx[j] = 0;
            } else if ((yy[i2 + 1] - yy[i2]) * (yy[i2] - yy[i2 - 1]) < 0) {
              gxx[j] = 0;
            } else {
              gxx[j] = 2 / (dxx(xx[i2 + 1], xx[i2]) / (yy[i2 + 1] - yy[i2]) + dxx(xx[i2], xx[i2 - 1]) / (yy[i2] - yy[i2 - 1]));
            }
          }
          if (num == 1) {
            gxx[0] = 3 / 2 * (yy[1] - yy[0]) / dxx(xx[1], xx[0]) - gxx[1] / 2;
          } else if (num == nmax) {
            gxx[1] = 3 / 2 * (yy[nmax] - yy[nmax - 1]) / dxx(xx[nmax], xx[nmax - 1]) - gxx[0] / 2;
          }
          ggxx[0] = -2 * (gxx[1] + 2 * gxx[0]) / dxx(xx[num], xx[num - 1]) + 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);
          ggxx[1] = 2 * (2 * gxx[1] + gxx[0]) / dxx(xx[num], xx[num - 1]) - 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);
          D = 1 / 6 * (ggxx[1] - ggxx[0]) / dxx(xx[num], xx[num - 1]);
          C = 1 / 2 * (xx[num] * ggxx[0] - xx[num - 1] * ggxx[1]) / dxx(xx[num], xx[num - 1]);
          B = (yy[num] - yy[num - 1] - C * (Math.pow(xx[num], 2) - Math.pow(xx[num - 1], 2)) - D * (Math.pow(xx[num], 3) - Math.pow(xx[num - 1], 3))) / dxx(xx[num], xx[num - 1]);
          A = yy[num - 1] - B * xx[num - 1] - C * Math.pow(xx[num - 1], 2) - D * Math.pow(xx[num - 1], 3);
          var increment = (xx[num] - xx[num - 1]) / steps;
          var temp, tempx;
          for (var j = 0, l = steps; j < l; j++) {
            temp = [];
            tempx = xx[num - 1] + j * increment;
            temp.push(tempx);
            temp.push(A + B * tempx + C * Math.pow(tempx, 2) + D * Math.pow(tempx, 3));
            _smoothedData.push(temp);
            _smoothedPlotData.push([xp(temp[0]), yp(temp[1])]);
          }
        }
        _smoothedData.push(gd[i2]);
        _smoothedPlotData.push([xp(gd[i2][0]), yp(gd[i2][1])]);
        return [_smoothedData, _smoothedPlotData];
      }
      function computeHermiteSmoothedData(gd) {
        var smooth = this.renderer.smooth;
        var tension = this.renderer.tension;
        var dim = this.canvas.getWidth();
        var xp = this._xaxis.series_p2u;
        var yp = this._yaxis.series_p2u;
        var steps = null;
        var _steps = null;
        var a = null;
        var a1 = null;
        var a2 = null;
        var slope = null;
        var slope2 = null;
        var temp = null;
        var t, s, h1, h2, h3, h4;
        var TiX, TiY, Ti1X, Ti1Y;
        var pX, pY, p;
        var sd = [];
        var spd = [];
        var dist = gd.length / dim;
        var min, max, stretch, scale2, shift;
        var _smoothedData = [];
        var _smoothedPlotData = [];
        if (!isNaN(parseFloat(smooth))) {
          steps = parseFloat(smooth);
        } else {
          steps = getSteps(dist, 0.5);
        }
        if (!isNaN(parseFloat(tension))) {
          tension = parseFloat(tension);
        }
        for (var i2 = 0, l = gd.length - 1; i2 < l; i2++) {
          if (tension === null) {
            slope = Math.abs((gd[i2 + 1][1] - gd[i2][1]) / (gd[i2 + 1][0] - gd[i2][0]));
            min = 0.3;
            max = 0.6;
            stretch = (max - min) / 2;
            scale2 = 2.5;
            shift = -1.4;
            temp = slope / scale2 + shift;
            a1 = stretch * tanh(temp) - stretch * tanh(shift) + min;
            if (i2 > 0) {
              slope2 = Math.abs((gd[i2][1] - gd[i2 - 1][1]) / (gd[i2][0] - gd[i2 - 1][0]));
            }
            temp = slope2 / scale2 + shift;
            a2 = stretch * tanh(temp) - stretch * tanh(shift) + min;
            a = (a1 + a2) / 2;
          } else {
            a = tension;
          }
          for (t = 0; t < steps; t++) {
            s = t / steps;
            h1 = (1 + 2 * s) * Math.pow(1 - s, 2);
            h2 = s * Math.pow(1 - s, 2);
            h3 = Math.pow(s, 2) * (3 - 2 * s);
            h4 = Math.pow(s, 2) * (s - 1);
            if (gd[i2 - 1]) {
              TiX = a * (gd[i2 + 1][0] - gd[i2 - 1][0]);
              TiY = a * (gd[i2 + 1][1] - gd[i2 - 1][1]);
            } else {
              TiX = a * (gd[i2 + 1][0] - gd[i2][0]);
              TiY = a * (gd[i2 + 1][1] - gd[i2][1]);
            }
            if (gd[i2 + 2]) {
              Ti1X = a * (gd[i2 + 2][0] - gd[i2][0]);
              Ti1Y = a * (gd[i2 + 2][1] - gd[i2][1]);
            } else {
              Ti1X = a * (gd[i2 + 1][0] - gd[i2][0]);
              Ti1Y = a * (gd[i2 + 1][1] - gd[i2][1]);
            }
            pX = h1 * gd[i2][0] + h3 * gd[i2 + 1][0] + h2 * TiX + h4 * Ti1X;
            pY = h1 * gd[i2][1] + h3 * gd[i2 + 1][1] + h2 * TiY + h4 * Ti1Y;
            p = [pX, pY];
            _smoothedData.push(p);
            _smoothedPlotData.push([xp(pX), yp(pY)]);
          }
        }
        _smoothedData.push(gd[l]);
        _smoothedPlotData.push([xp(gd[l][0]), yp(gd[l][1])]);
        return [_smoothedData, _smoothedPlotData];
      }
      _jqplot2.default.LineRenderer.prototype.setGridData = function(plot) {
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var data = this._plotData;
        var pdata = this._prevPlotData;
        this.gridData = [];
        this._prevGridData = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var hasNull = false;
        for (var i2 = 0, l = data.length; i2 < l; i2++) {
          if (data[i2][0] != null && data[i2][1] != null) {
            this.gridData.push([xp.call(this._xaxis, data[i2][0]), yp.call(this._yaxis, data[i2][1])]);
          } else if (data[i2][0] == null) {
            hasNull = true;
            this.gridData.push([null, yp.call(this._yaxis, data[i2][1])]);
          } else if (data[i2][1] == null) {
            hasNull = true;
            this.gridData.push([xp.call(this._xaxis, data[i2][0]), null]);
          }
          if (pdata[i2] != null && pdata[i2][0] != null && pdata[i2][1] != null) {
            this._prevGridData.push([xp.call(this._xaxis, pdata[i2][0]), yp.call(this._yaxis, pdata[i2][1])]);
          } else if (pdata[i2] != null && pdata[i2][0] == null) {
            this._prevGridData.push([null, yp.call(this._yaxis, pdata[i2][1])]);
          } else if (pdata[i2] != null && pdata[i2][0] != null && pdata[i2][1] == null) {
            this._prevGridData.push([xp.call(this._xaxis, pdata[i2][0]), null]);
          }
        }
        if (hasNull) {
          this.renderer.smooth = false;
          if (this._type === "line") {
            bands.show = false;
          }
        }
        if (this._type === "line" && bands.show) {
          for (var i2 = 0, l = bands.hiData.length; i2 < l; i2++) {
            this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i2][0]), yp.call(this._yaxis, bands.hiData[i2][1])]);
          }
          for (var i2 = 0, l = bands.lowData.length; i2 < l; i2++) {
            this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i2][0]), yp.call(this._yaxis, bands.lowData[i2][1])]);
          }
        }
        if (this._type === "line" && this.renderer.smooth && this.gridData.length > 2) {
          var ret;
          if (this.renderer.constrainSmoothing) {
            ret = computeConstrainedSmoothedData.call(this, this.gridData);
            this.renderer._smoothedData = ret[0];
            this.renderer._smoothedPlotData = ret[1];
            if (bands.show) {
              ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);
              this.renderer._hiBandSmoothedData = ret[0];
              ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);
              this.renderer._lowBandSmoothedData = ret[0];
            }
            ret = null;
          } else {
            ret = computeHermiteSmoothedData.call(this, this.gridData);
            this.renderer._smoothedData = ret[0];
            this.renderer._smoothedPlotData = ret[1];
            if (bands.show) {
              ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);
              this.renderer._hiBandSmoothedData = ret[0];
              ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);
              this.renderer._lowBandSmoothedData = ret[0];
            }
            ret = null;
          }
        }
      };
      _jqplot2.default.LineRenderer.prototype.makeGridData = function(data, plot) {
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var gd = [];
        var pgd = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var hasNull = false;
        for (var i2 = 0; i2 < data.length; i2++) {
          if (data[i2][0] != null && data[i2][1] != null) {
            if (this.step && i2 > 0) {
              gd.push([xp.call(this._xaxis, data[i2][0]), yp.call(this._yaxis, data[i2 - 1][1])]);
            }
            gd.push([xp.call(this._xaxis, data[i2][0]), yp.call(this._yaxis, data[i2][1])]);
          } else if (data[i2][0] == null) {
            hasNull = true;
            gd.push([null, yp.call(this._yaxis, data[i2][1])]);
          } else if (data[i2][1] == null) {
            hasNull = true;
            gd.push([xp.call(this._xaxis, data[i2][0]), null]);
          }
        }
        if (hasNull) {
          this.renderer.smooth = false;
          if (this._type === "line") {
            bands.show = false;
          }
        }
        if (this._type === "line" && bands.show) {
          for (var i2 = 0, l = bands.hiData.length; i2 < l; i2++) {
            this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i2][0]), yp.call(this._yaxis, bands.hiData[i2][1])]);
          }
          for (var i2 = 0, l = bands.lowData.length; i2 < l; i2++) {
            this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i2][0]), yp.call(this._yaxis, bands.lowData[i2][1])]);
          }
        }
        if (this._type === "line" && this.renderer.smooth && gd.length > 2) {
          var ret;
          if (this.renderer.constrainSmoothing) {
            ret = computeConstrainedSmoothedData.call(this, gd);
            this.renderer._smoothedData = ret[0];
            this.renderer._smoothedPlotData = ret[1];
            if (bands.show) {
              ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);
              this.renderer._hiBandSmoothedData = ret[0];
              ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);
              this.renderer._lowBandSmoothedData = ret[0];
            }
            ret = null;
          } else {
            ret = computeHermiteSmoothedData.call(this, gd);
            this.renderer._smoothedData = ret[0];
            this.renderer._smoothedPlotData = ret[1];
            if (bands.show) {
              ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);
              this.renderer._hiBandSmoothedData = ret[0];
              ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);
              this.renderer._lowBandSmoothedData = ret[0];
            }
            ret = null;
          }
        }
        return gd;
      };
      _jqplot2.default.LineRenderer.prototype.draw = function(ctx, gd, options2, plot) {
        var i2;
        var opts = _jquery2.default.extend(true, {}, options2);
        var shadow = opts.shadow != void 0 ? opts.shadow : this.shadow;
        var showLine = opts.showLine != void 0 ? opts.showLine : this.showLine;
        var fill = opts.fill != void 0 ? opts.fill : this.fill;
        var fillAndStroke = opts.fillAndStroke != void 0 ? opts.fillAndStroke : this.fillAndStroke;
        var xmin, ymin, xmax, ymax;
        ctx.save();
        if (gd.length) {
          if (showLine) {
            if (fill) {
              if (this.fillToZero) {
                var negativeColor = this.negativeColor;
                if (!this.useNegativeColors) {
                  negativeColor = opts.fillStyle;
                }
                var isnegative = false;
                var posfs = opts.fillStyle;
                if (fillAndStroke) {
                  var fasgd = gd.slice(0);
                }
                if (this.index == 0 || !this._stack) {
                  var tempgd = [];
                  var pd = this.renderer.smooth ? this.renderer._smoothedPlotData : this._plotData;
                  this._areaPoints = [];
                  var pyzero = this._yaxis.series_u2p(this.fillToValue);
                  var pxzero = this._xaxis.series_u2p(this.fillToValue);
                  opts.closePath = true;
                  if (this.fillAxis == "y") {
                    tempgd.push([gd[0][0], pyzero]);
                    this._areaPoints.push([gd[0][0], pyzero]);
                    for (var i2 = 0; i2 < gd.length - 1; i2++) {
                      tempgd.push(gd[i2]);
                      this._areaPoints.push(gd[i2]);
                      if (pd[i2][1] * pd[i2 + 1][1] <= 0) {
                        if (pd[i2][1] < 0) {
                          isnegative = true;
                          opts.fillStyle = negativeColor;
                        } else {
                          isnegative = false;
                          opts.fillStyle = posfs;
                        }
                        var xintercept = gd[i2][0] + (gd[i2 + 1][0] - gd[i2][0]) * (pyzero - gd[i2][1]) / (gd[i2 + 1][1] - gd[i2][1]);
                        tempgd.push([xintercept, pyzero]);
                        this._areaPoints.push([xintercept, pyzero]);
                        if (shadow) {
                          this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                        }
                        this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                        tempgd = [[xintercept, pyzero]];
                      }
                    }
                    if (pd[gd.length - 1][1] < 0) {
                      isnegative = true;
                      opts.fillStyle = negativeColor;
                    } else {
                      isnegative = false;
                      opts.fillStyle = posfs;
                    }
                    tempgd.push(gd[gd.length - 1]);
                    this._areaPoints.push(gd[gd.length - 1]);
                    tempgd.push([gd[gd.length - 1][0], pyzero]);
                    this._areaPoints.push([gd[gd.length - 1][0], pyzero]);
                  }
                  if (shadow) {
                    this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                  }
                  this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                } else {
                  var prev = this._prevGridData;
                  for (var i2 = prev.length; i2 > 0; i2--) {
                    gd.push(prev[i2 - 1]);
                  }
                  if (shadow) {
                    this.renderer.shadowRenderer.draw(ctx, gd, opts);
                  }
                  this._areaPoints = gd;
                  this.renderer.shapeRenderer.draw(ctx, gd, opts);
                }
              } else {
                if (fillAndStroke) {
                  var fasgd = gd.slice(0);
                }
                if (this.index == 0 || !this._stack) {
                  var gridymin = ctx.canvas.height;
                  gd.unshift([gd[0][0], gridymin]);
                  var len = gd.length;
                  gd.push([gd[len - 1][0], gridymin]);
                } else {
                  var prev = this._prevGridData;
                  for (var i2 = prev.length; i2 > 0; i2--) {
                    gd.push(prev[i2 - 1]);
                  }
                }
                this._areaPoints = gd;
                if (shadow) {
                  this.renderer.shadowRenderer.draw(ctx, gd, opts);
                }
                this.renderer.shapeRenderer.draw(ctx, gd, opts);
              }
              if (fillAndStroke) {
                var fasopts = _jquery2.default.extend(true, {}, opts, { fill: false, closePath: false });
                this.renderer.shapeRenderer.draw(ctx, fasgd, fasopts);
                if (this.markerRenderer.show) {
                  if (this.renderer.smooth) {
                    fasgd = this.gridData;
                  }
                  for (i2 = 0; i2 < fasgd.length; i2++) {
                    var markerOptions = opts.markerOptions || {};
                    if (this.markerOptionsCallback) {
                      markerOptions = _jquery2.default.extend(true, markerOptions, this.markerOptionsCallback(plot, this, i2, this.data[i2], gd[i2]) || {});
                    }
                    this.markerRenderer.draw(fasgd[i2][0], fasgd[i2][1], ctx, markerOptions);
                  }
                }
              }
            } else {
              if (this.renderer.bands.show) {
                var bdat;
                var bopts = _jquery2.default.extend(true, {}, opts);
                if (this.renderer.bands.showLines) {
                  bdat = this.renderer.smooth ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData;
                  this.renderer.shapeRenderer.draw(ctx, bdat, opts);
                  bdat = this.renderer.smooth ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData;
                  this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                }
                if (this.renderer.bands.fill) {
                  if (this.renderer.smooth) {
                    bdat = this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse());
                  } else {
                    bdat = this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse());
                  }
                  this._areaPoints = bdat;
                  bopts.closePath = true;
                  bopts.fill = true;
                  bopts.fillStyle = this.renderer.bands.fillColor;
                  this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                }
              }
              if (shadow) {
                this.renderer.shadowRenderer.draw(ctx, gd, opts);
              }
              this.renderer.shapeRenderer.draw(ctx, gd, opts);
            }
          }
          var xmin = xmax = ymin = ymax = null;
          for (i2 = 0; i2 < this._areaPoints.length; i2++) {
            var p = this._areaPoints[i2];
            if (xmin > p[0] || xmin == null) {
              xmin = p[0];
            }
            if (ymax < p[1] || ymax == null) {
              ymax = p[1];
            }
            if (xmax < p[0] || xmax == null) {
              xmax = p[0];
            }
            if (ymin > p[1] || ymin == null) {
              ymin = p[1];
            }
          }
          if (this.type === "line" && this.renderer.bands.show) {
            ymax = this._yaxis.series_u2p(this.renderer.bands._min);
            ymin = this._yaxis.series_u2p(this.renderer.bands._max);
          }
          this._boundingBox = [[xmin, ymax], [xmax, ymin]];
          if (this.markerRenderer.show && !fill) {
            if (this.renderer.smooth) {
              gd = this.gridData;
            }
            for (i2 = 0; i2 < gd.length; i2++) {
              var markerOptions = opts.markerOptions || {};
              if (this.markerOptionsCallback) {
                markerOptions = _jquery2.default.extend(true, markerOptions, this.markerOptionsCallback(plot, this, i2, this.data[i2], gd[i2]) || {});
              }
              if (gd[i2][0] != null && gd[i2][1] != null) {
                this.markerRenderer.draw(gd[i2][0], gd[i2][1], ctx, markerOptions);
              }
            }
          }
        }
        ctx.restore();
      };
      _jqplot2.default.LineRenderer.prototype.drawShadow = function(ctx, gd, options2) {
      };
      function postInit(target, data, options2) {
        for (var i2 = 0; i2 < this.series.length; i2++) {
          if (this.series[i2].renderer.constructor == _jqplot2.default.LineRenderer) {
            if (this.series[i2].highlightMouseOver) {
              this.series[i2].highlightMouseDown = false;
            }
          }
        }
      }
      function postPlotDraw() {
        if (this.plugins.lineRenderer && this.plugins.lineRenderer.highlightCanvas) {
          this.plugins.lineRenderer.highlightCanvas.resetCanvas();
          this.plugins.lineRenderer.highlightCanvas = null;
        }
        this.plugins.lineRenderer.highlightedSeriesIndex = null;
        this.plugins.lineRenderer.highlightCanvas = new _jqplot2.default.GenericCanvas();
        this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-lineRenderer-highlight-canvas", this._plotDimensions, this));
        this.plugins.lineRenderer.highlightCanvas.setContext();
        this.eventCanvas._elem.bind("mouseleave", { plot: this }, function(ev) {
          unhighlight(ev.data.plot);
        });
      }
      function highlight(plot, sidx, pidx, points) {
        var s = plot.series[sidx];
        var canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        s._highlightedPoint = pidx;
        plot.plugins.lineRenderer.highlightedSeriesIndex = sidx;
        var opts = { fillStyle: s.highlightColor };
        if (s.type === "line" && s.renderer.bands.show) {
          opts.fill = true;
          opts.closePath = true;
        }
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts);
        canvas = null;
      }
      function unhighlight(plot) {
        var canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i2 = 0; i2 < plot.series.length; i2++) {
          plot.series[i2]._highlightedPoint = null;
        }
        plot.plugins.lineRenderer.highlightedSeriesIndex = null;
        plot.target.trigger("jqplotDataUnhighlight");
        canvas = null;
      }
      function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
          var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
          var evt1 = _jquery2.default.Event("jqplotDataMouseOver");
          evt1.pageX = ev.pageX;
          evt1.pageY = ev.pageY;
          plot.target.trigger(evt1, ins);
          if (plot.series[ins[0]].highlightMouseOver && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {
            var evt = _jquery2.default.Event("jqplotDataHighlight");
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
            highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
          }
        } else if (neighbor == null) {
          unhighlight(plot);
        }
      }
      function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
          var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
          if (plot.series[ins[0]].highlightMouseDown && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {
            var evt = _jquery2.default.Event("jqplotDataHighlight");
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
            highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
          }
        } else if (neighbor == null) {
          unhighlight(plot);
        }
      }
      function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {
        var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
        if (idx != null && plot.series[idx].highlightMouseDown) {
          unhighlight(plot);
        }
      }
      function handleClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
          var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
          var evt = _jquery2.default.Event("jqplotDataClick");
          evt.which = ev.which;
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          plot.target.trigger(evt, ins);
        }
      }
      function handleRightClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
          var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
          var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
          if (idx != null && plot.series[idx].highlightMouseDown) {
            unhighlight(plot);
          }
          var evt = _jquery2.default.Event("jqplotDataRightClick");
          evt.which = ev.which;
          evt.pageX = ev.pageX;
          evt.pageY = ev.pageY;
          plot.target.trigger(evt, ins);
        }
      }
    }
  });

  // node_modules/jqplot-exported/LinearAxisRenderer.js
  var require_LinearAxisRenderer = __commonJS({
    "node_modules/jqplot-exported/LinearAxisRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LinearAxisRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var LinearAxisRenderer = exports.LinearAxisRenderer = _jqplot2.default.LinearAxisRenderer = function() {
      };
      _jqplot2.default.LinearAxisRenderer.prototype.init = function(options2) {
        this.breakPoints = null;
        this.breakTickLabel = "&asymp;";
        this.drawBaseline = true;
        this.baselineWidth = null;
        this.baselineColor = null;
        this.forceTickAt0 = false;
        this.forceTickAt100 = false;
        this.tickInset = 0;
        this.minorTicks = 0;
        this.alignTicks = false;
        this._autoFormatString = "";
        this._overrideFormatString = false;
        this._scalefact = 1;
        _jquery2.default.extend(true, this, options2);
        if (this.breakPoints) {
          if (!_jquery2.default.isArray(this.breakPoints)) {
            this.breakPoints = null;
          } else if (this.breakPoints.length < 2 || this.breakPoints[1] <= this.breakPoints[0]) {
            this.breakPoints = null;
          }
        }
        if (this.numberTicks != null && this.numberTicks < 2) {
          this.numberTicks = 2;
        }
        this.resetDataBounds();
      };
      _jqplot2.default.LinearAxisRenderer.prototype.draw = function(ctx, plot) {
        if (this.show) {
          this.renderer.createTicks.call(this, plot);
          var dim = 0;
          var temp;
          if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
          }
          this._elem = (0, _jquery2.default)(document.createElement("div"));
          this._elem.addClass("jqplot-axis jqplot-" + this.name);
          this._elem.css("position", "absolute");
          if (this.name == "xaxis" || this.name == "x2axis") {
            this._elem.width(this._plotDimensions.width);
          } else {
            this._elem.height(this._plotDimensions.height);
          }
          this.labelOptions.axis = this.name;
          this._label = new this.labelRenderer(this.labelOptions);
          if (this._label.show) {
            var elem = this._label.draw(ctx, plot);
            elem.appendTo(this._elem);
            elem = null;
          }
          var t = this._ticks;
          var tick;
          for (var i2 = 0; i2 < t.length; i2++) {
            tick = t[i2];
            if (tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
              this._elem.append(tick.draw(ctx, plot));
            }
          }
          tick = null;
          t = null;
        }
        return this._elem;
      };
      _jqplot2.default.LinearAxisRenderer.prototype.reset = function() {
        this.min = this._options.min;
        this.max = this._options.max;
        this.tickInterval = this._options.tickInterval;
        this.numberTicks = this._options.numberTicks;
        this._autoFormatString = "";
        if (this._overrideFormatString && this.tickOptions && this.tickOptions.formatString) {
          this.tickOptions.formatString = "";
        }
      };
      _jqplot2.default.LinearAxisRenderer.prototype.set = function() {
        var dim = 0;
        var temp;
        var w = 0;
        var h = 0;
        var lshow = this._label == null ? false : this._label.show;
        if (this.show) {
          var t = this._ticks;
          var tick;
          for (var i2 = 0; i2 < t.length; i2++) {
            tick = t[i2];
            if (!tick._breakTick && tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
              if (this.name == "xaxis" || this.name == "x2axis") {
                temp = tick._elem.outerHeight(true);
              } else {
                temp = tick._elem.outerWidth(true);
              }
              if (temp > dim) {
                dim = temp;
              }
            }
          }
          tick = null;
          t = null;
          if (lshow) {
            w = this._label._elem.outerWidth(true);
            h = this._label._elem.outerHeight(true);
          }
          if (this.name == "xaxis") {
            dim = dim + h;
            this._elem.css({ "height": dim + "px", left: "0px", bottom: "0px" });
          } else if (this.name == "x2axis") {
            dim = dim + h;
            this._elem.css({ "height": dim + "px", left: "0px", top: "0px" });
          } else if (this.name == "yaxis") {
            dim = dim + w;
            this._elem.css({ "width": dim + "px", left: "0px", top: "0px" });
            if (lshow && this._label.constructor == _jqplot2.default.AxisLabelRenderer) {
              this._label._elem.css("width", w + "px");
            }
          } else {
            dim = dim + w;
            this._elem.css({ "width": dim + "px", right: "0px", top: "0px" });
            if (lshow && this._label.constructor == _jqplot2.default.AxisLabelRenderer) {
              this._label._elem.css("width", w + "px");
            }
          }
        }
      };
      _jqplot2.default.LinearAxisRenderer.prototype.createTicks = function(plot) {
        var ticks = this._ticks;
        var userTicks = this.ticks;
        var name = this.name;
        var db = this._dataBounds;
        var dim = this.name.charAt(0) === "x" ? this._plotDimensions.width : this._plotDimensions.height;
        var interval;
        var min, max;
        var pos1, pos2;
        var tt, i2;
        var userMin = this.min;
        var userMax = this.max;
        var userNT = this.numberTicks;
        var userTI = this.tickInterval;
        var threshold = 30;
        this._scalefact = (Math.max(dim, threshold + 1) - threshold) / 300;
        if (userTicks.length) {
          for (i2 = 0; i2 < userTicks.length; i2++) {
            var ut = userTicks[i2];
            var t = new this.tickRenderer(this.tickOptions);
            if (_jquery2.default.isArray(ut)) {
              t.value = ut[0];
              if (this.breakPoints) {
                if (ut[0] == this.breakPoints[0]) {
                  t.label = this.breakTickLabel;
                  t._breakTick = true;
                  t.showGridline = false;
                  t.showMark = false;
                } else if (ut[0] > this.breakPoints[0] && ut[0] <= this.breakPoints[1]) {
                  t.show = false;
                  t.showGridline = false;
                  t.label = ut[1];
                } else {
                  t.label = ut[1];
                }
              } else {
                t.label = ut[1];
              }
              t.setTick(ut[0], this.name);
              this._ticks.push(t);
            } else if (_jquery2.default.isPlainObject(ut)) {
              _jquery2.default.extend(true, t, ut);
              t.axis = this.name;
              this._ticks.push(t);
            } else {
              t.value = ut;
              if (this.breakPoints) {
                if (ut == this.breakPoints[0]) {
                  t.label = this.breakTickLabel;
                  t._breakTick = true;
                  t.showGridline = false;
                  t.showMark = false;
                } else if (ut > this.breakPoints[0] && ut <= this.breakPoints[1]) {
                  t.show = false;
                  t.showGridline = false;
                }
              }
              t.setTick(ut, this.name);
              this._ticks.push(t);
            }
          }
          this.numberTicks = userTicks.length;
          this.min = this._ticks[0].value;
          this.max = this._ticks[this.numberTicks - 1].value;
          this.tickInterval = (this.max - this.min) / (this.numberTicks - 1);
        } else {
          if (name == "xaxis" || name == "x2axis") {
            dim = this._plotDimensions.width;
          } else {
            dim = this._plotDimensions.height;
          }
          var _numberTicks = this.numberTicks;
          if (this.alignTicks) {
            if (this.name === "x2axis" && plot.axes.xaxis.show) {
              _numberTicks = plot.axes.xaxis.numberTicks;
            } else if (this.name.charAt(0) === "y" && this.name !== "yaxis" && this.name !== "yMidAxis" && plot.axes.yaxis.show) {
              _numberTicks = plot.axes.yaxis.numberTicks;
            }
          }
          min = this.min != null ? this.min : db.min;
          max = this.max != null ? this.max : db.max;
          var range = max - min;
          var rmin, rmax;
          var temp;
          if (this.tickOptions == null || !this.tickOptions.formatString) {
            this._overrideFormatString = true;
          }
          if (this.min == null || this.max == null && this.tickInterval == null && !this.autoscale) {
            if (this.forceTickAt0) {
              if (min > 0) {
                min = 0;
              }
              if (max < 0) {
                max = 0;
              }
            }
            if (this.forceTickAt100) {
              if (min > 100) {
                min = 100;
              }
              if (max < 100) {
                max = 100;
              }
            }
            var keepMin = false, keepMax = false;
            if (this.min != null) {
              keepMin = true;
            } else if (this.max != null) {
              keepMax = true;
            }
            var ret = _jqplot2.default.LinearTickGenerator(min, max, this._scalefact, _numberTicks, keepMin, keepMax);
            var tumin = this.min != null ? min : min + range * (this.padMin - 1);
            var tumax = this.max != null ? max : max - range * (this.padMax - 1);
            if (min < tumin || max > tumax) {
              tumin = this.min != null ? min : min - range * (this.padMin - 1);
              tumax = this.max != null ? max : max + range * (this.padMax - 1);
              ret = _jqplot2.default.LinearTickGenerator(tumin, tumax, this._scalefact, _numberTicks, keepMin, keepMax);
            }
            this.min = ret[0];
            this.max = ret[1];
            this.numberTicks = ret[2];
            this._autoFormatString = ret[3];
            this.tickInterval = ret[4];
          } else {
            if (min == max) {
              var adj = 0.05;
              if (min > 0) {
                adj = Math.max(Math.log(min) / Math.LN10, 0.05);
              }
              min -= adj;
              max += adj;
            }
            if (this.autoscale && this.min == null && this.max == null) {
              var rrange, ti, margin;
              var forceMinZero = false;
              var forceZeroLine = false;
              var intervals = { min: null, max: null, average: null, stddev: null };
              for (var i2 = 0; i2 < this._series.length; i2++) {
                var s = this._series[i2];
                var faname = s.fillAxis == "x" ? s._xaxis.name : s._yaxis.name;
                if (this.name == faname) {
                  var vals = s._plotValues[s.fillAxis];
                  var vmin = vals[0];
                  var vmax = vals[0];
                  for (var j = 1; j < vals.length; j++) {
                    if (vals[j] < vmin) {
                      vmin = vals[j];
                    } else if (vals[j] > vmax) {
                      vmax = vals[j];
                    }
                  }
                  var dp = (vmax - vmin) / vmax;
                  if (s.renderer.constructor == _jqplot2.default.BarRenderer) {
                    if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                      forceMinZero = true;
                    } else {
                      forceMinZero = false;
                      if (s.fill && s.fillToZero && vmin < 0 && vmax > 0) {
                        forceZeroLine = true;
                      } else {
                        forceZeroLine = false;
                      }
                    }
                  } else if (s.fill) {
                    if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                      forceMinZero = true;
                    } else if (vmin < 0 && vmax > 0 && s.fillToZero) {
                      forceMinZero = false;
                      forceZeroLine = true;
                    } else {
                      forceMinZero = false;
                      forceZeroLine = false;
                    }
                  } else if (vmin < 0) {
                    forceMinZero = false;
                  }
                }
              }
              if (forceMinZero) {
                this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing);
                this.min = 0;
                userMin = 0;
                ti = max / (this.numberTicks - 1);
                temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10)));
                if (ti / temp == parseInt(ti / temp, 10)) {
                  ti += temp;
                }
                this.tickInterval = Math.ceil(ti / temp) * temp;
                this.max = this.tickInterval * (this.numberTicks - 1);
              } else if (forceZeroLine) {
                this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing);
                var ntmin = Math.ceil(Math.abs(min) / range * (this.numberTicks - 1));
                var ntmax = this.numberTicks - 1 - ntmin;
                ti = Math.max(Math.abs(min / ntmin), Math.abs(max / ntmax));
                temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10)));
                this.tickInterval = Math.ceil(ti / temp) * temp;
                this.max = this.tickInterval * ntmax;
                this.min = -this.tickInterval * ntmin;
              } else {
                if (this.numberTicks == null) {
                  if (this.tickInterval) {
                    this.numberTicks = 3 + Math.ceil(range / this.tickInterval);
                  } else {
                    this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing);
                  }
                }
                if (this.tickInterval == null) {
                  ti = range / (this.numberTicks - 1);
                  if (ti < 1) {
                    temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10)));
                  } else {
                    temp = 1;
                  }
                  this.tickInterval = Math.ceil(ti * temp * this.pad) / temp;
                } else {
                  temp = 1 / this.tickInterval;
                }
                rrange = this.tickInterval * (this.numberTicks - 1);
                margin = (rrange - range) / 2;
                if (this.min == null) {
                  this.min = Math.floor(temp * (min - margin)) / temp;
                }
                if (this.max == null) {
                  this.max = this.min + rrange;
                }
              }
              var sf = _jqplot2.default.getSignificantFigures(this.tickInterval);
              var fstr;
              if (sf.digitsLeft >= sf.significantDigits) {
                fstr = "%d";
              } else {
                var temp = Math.max(0, 5 - sf.digitsLeft);
                temp = Math.min(temp, sf.digitsRight);
                fstr = "%." + temp + "f";
              }
              this._autoFormatString = fstr;
            } else {
              rmin = this.min != null ? this.min : min - range * (this.padMin - 1);
              rmax = this.max != null ? this.max : max + range * (this.padMax - 1);
              range = rmax - rmin;
              if (this.numberTicks == null) {
                if (this.tickInterval != null) {
                  this.numberTicks = Math.ceil((rmax - rmin) / this.tickInterval) + 1;
                } else if (dim > 100) {
                  this.numberTicks = parseInt(3 + (dim - 100) / 75, 10);
                } else {
                  this.numberTicks = 2;
                }
              }
              if (this.tickInterval == null) {
                this.tickInterval = range / (this.numberTicks - 1);
              }
              if (this.max == null) {
                rmax = rmin + this.tickInterval * (this.numberTicks - 1);
              }
              if (this.min == null) {
                rmin = rmax - this.tickInterval * (this.numberTicks - 1);
              }
              var sf = _jqplot2.default.getSignificantFigures(this.tickInterval);
              var fstr;
              if (sf.digitsLeft >= sf.significantDigits) {
                fstr = "%d";
              } else {
                var temp = Math.max(0, 5 - sf.digitsLeft);
                temp = Math.min(temp, sf.digitsRight);
                fstr = "%." + temp + "f";
              }
              this._autoFormatString = fstr;
              this.min = rmin;
              this.max = rmax;
            }
            if (this.renderer.constructor == _jqplot2.default.LinearAxisRenderer && this._autoFormatString == "") {
              range = this.max - this.min;
              var temptick = new this.tickRenderer(this.tickOptions);
              var fs = temptick.formatString || _jqplot2.default.config.defaultTickFormatString;
              var fs = fs.match(_jqplot2.default.sprintf.regex)[0];
              var precision = 0;
              if (fs) {
                if (fs.search(/[fFeEgGpP]/) > -1) {
                  var m = fs.match(/\%\.(\d{0,})?[eEfFgGpP]/);
                  if (m) {
                    precision = parseInt(m[1], 10);
                  } else {
                    precision = 6;
                  }
                } else if (fs.search(/[di]/) > -1) {
                  precision = 0;
                }
                var fact = Math.pow(10, -precision);
                if (this.tickInterval < fact) {
                  if (userNT == null && userTI == null) {
                    this.tickInterval = fact;
                    if (userMax == null && userMin == null) {
                      this.min = Math.floor(this._dataBounds.min / fact) * fact;
                      if (this.min == this._dataBounds.min) {
                        this.min = this._dataBounds.min - this.tickInterval;
                      }
                      this.max = Math.ceil(this._dataBounds.max / fact) * fact;
                      if (this.max == this._dataBounds.max) {
                        this.max = this._dataBounds.max + this.tickInterval;
                      }
                      var n = (this.max - this.min) / this.tickInterval;
                      n = n.toFixed(11);
                      n = Math.ceil(n);
                      this.numberTicks = n + 1;
                    } else if (userMax == null) {
                      var n = (this._dataBounds.max - this.min) / this.tickInterval;
                      n = n.toFixed(11);
                      this.numberTicks = Math.ceil(n) + 2;
                      this.max = this.min + this.tickInterval * (this.numberTicks - 1);
                    } else if (userMin == null) {
                      var n = (this.max - this._dataBounds.min) / this.tickInterval;
                      n = n.toFixed(11);
                      this.numberTicks = Math.ceil(n) + 2;
                      this.min = this.max - this.tickInterval * (this.numberTicks - 1);
                    } else {
                      this.numberTicks = Math.ceil((userMax - userMin) / this.tickInterval) + 1;
                      this.min = Math.floor(userMin * Math.pow(10, precision)) / Math.pow(10, precision);
                      this.max = Math.ceil(userMax * Math.pow(10, precision)) / Math.pow(10, precision);
                      this.numberTicks = Math.ceil((this.max - this.min) / this.tickInterval) + 1;
                    }
                  }
                }
              }
            }
          }
          if (this._overrideFormatString && this._autoFormatString != "") {
            this.tickOptions = this.tickOptions || {};
            this.tickOptions.formatString = this._autoFormatString;
          }
          var t, to;
          for (var i2 = 0; i2 < this.numberTicks; i2++) {
            tt = this.min + i2 * this.tickInterval;
            t = new this.tickRenderer(this.tickOptions);
            t.setTick(tt, this.name);
            this._ticks.push(t);
            if (i2 < this.numberTicks - 1) {
              for (var j = 0; j < this.minorTicks; j++) {
                tt += this.tickInterval / (this.minorTicks + 1);
                to = _jquery2.default.extend(true, {}, this.tickOptions, { name: this.name, value: tt, label: "", isMinorTick: true });
                t = new this.tickRenderer(to);
                this._ticks.push(t);
              }
            }
            t = null;
          }
        }
        if (this.tickInset) {
          this.min = this.min - this.tickInset * this.tickInterval;
          this.max = this.max + this.tickInset * this.tickInterval;
        }
        ticks = null;
      };
      _jqplot2.default.LinearAxisRenderer.prototype.resetTickValues = function(opts) {
        if (_jquery2.default.isArray(opts) && opts.length == this._ticks.length) {
          var t;
          for (var i2 = 0; i2 < opts.length; i2++) {
            t = this._ticks[i2];
            t.value = opts[i2];
            t.label = t.formatter(t.formatString, opts[i2]);
            t.label = t.prefix + t.label;
            t._elem.html(t.label);
          }
          t = null;
          this.min = _jqplot2.default.arrayMin(opts);
          this.max = _jqplot2.default.arrayMax(opts);
          this.pack();
        }
      };
      _jqplot2.default.LinearAxisRenderer.prototype.pack = function(pos, offsets) {
        pos = pos || {};
        offsets = offsets || this._offsets;
        var ticks = this._ticks;
        var max = this.max;
        var min = this.min;
        var offmax = offsets.max;
        var offmin = offsets.min;
        var lshow = this._label == null ? false : this._label.show;
        for (var p in pos) {
          this._elem.css(p, pos[p]);
        }
        this._offsets = offsets;
        var pixellength = offmax - offmin;
        var unitlength = max - min;
        if (this.breakPoints) {
          unitlength = unitlength - this.breakPoints[1] + this.breakPoints[0];
          this.p2u = function(p2) {
            return (p2 - offmin) * unitlength / pixellength + min;
          };
          this.u2p = function(u) {
            if (u > this.breakPoints[0] && u < this.breakPoints[1]) {
              u = this.breakPoints[0];
            }
            if (u <= this.breakPoints[0]) {
              return (u - min) * pixellength / unitlength + offmin;
            } else {
              return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength + offmin;
            }
          };
          if (this.name.charAt(0) == "x") {
            this.series_u2p = function(u) {
              if (u > this.breakPoints[0] && u < this.breakPoints[1]) {
                u = this.breakPoints[0];
              }
              if (u <= this.breakPoints[0]) {
                return (u - min) * pixellength / unitlength;
              } else {
                return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength;
              }
            };
            this.series_p2u = function(p2) {
              return p2 * unitlength / pixellength + min;
            };
          } else {
            this.series_u2p = function(u) {
              if (u > this.breakPoints[0] && u < this.breakPoints[1]) {
                u = this.breakPoints[0];
              }
              if (u >= this.breakPoints[1]) {
                return (u - max) * pixellength / unitlength;
              } else {
                return (u + this.breakPoints[1] - this.breakPoints[0] - max) * pixellength / unitlength;
              }
            };
            this.series_p2u = function(p2) {
              return p2 * unitlength / pixellength + max;
            };
          }
        } else {
          this.p2u = function(p2) {
            return (p2 - offmin) * unitlength / pixellength + min;
          };
          this.u2p = function(u) {
            return (u - min) * pixellength / unitlength + offmin;
          };
          if (this.name == "xaxis" || this.name == "x2axis") {
            this.series_u2p = function(u) {
              return (u - min) * pixellength / unitlength;
            };
            this.series_p2u = function(p2) {
              return p2 * unitlength / pixellength + min;
            };
          } else {
            this.series_u2p = function(u) {
              return (u - max) * pixellength / unitlength;
            };
            this.series_p2u = function(p2) {
              return p2 * unitlength / pixellength + max;
            };
          }
        }
        if (this.show) {
          if (this.name == "xaxis" || this.name == "x2axis") {
            for (var i2 = 0; i2 < ticks.length; i2++) {
              var t = ticks[i2];
              if (t.show && t.showLabel) {
                var shim;
                if (t.constructor == _jqplot2.default.CanvasAxisTickRenderer && t.angle) {
                  var temp = this.name == "xaxis" ? 1 : -1;
                  switch (t.labelPosition) {
                    case "auto":
                      if (temp * t.angle < 0) {
                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                      } else {
                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                      }
                      break;
                    case "end":
                      shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                      break;
                    case "start":
                      shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                      break;
                    case "middle":
                      shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                      break;
                    default:
                      shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                      break;
                  }
                } else {
                  shim = -t.getWidth() / 2;
                }
                var val = this.u2p(t.value) + shim + "px";
                t._elem.css("left", val);
                t.pack();
              }
            }
            if (lshow) {
              var w = this._label._elem.outerWidth(true);
              this._label._elem.css("left", offmin + pixellength / 2 - w / 2 + "px");
              if (this.name == "xaxis") {
                this._label._elem.css("bottom", "0px");
              } else {
                this._label._elem.css("top", "0px");
              }
              this._label.pack();
            }
          } else {
            for (var i2 = 0; i2 < ticks.length; i2++) {
              var t = ticks[i2];
              if (t.show && t.showLabel) {
                var shim;
                if (t.constructor == _jqplot2.default.CanvasAxisTickRenderer && t.angle) {
                  var temp = this.name == "yaxis" ? 1 : -1;
                  switch (t.labelPosition) {
                    case "auto":
                    case "end":
                      if (temp * t.angle < 0) {
                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                      } else {
                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                      }
                      break;
                    case "start":
                      if (t.angle > 0) {
                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                      } else {
                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                      }
                      break;
                    case "middle":
                      shim = -t.getHeight() / 2;
                      break;
                    default:
                      shim = -t.getHeight() / 2;
                      break;
                  }
                } else {
                  shim = -t.getHeight() / 2;
                }
                var val = this.u2p(t.value) + shim + "px";
                t._elem.css("top", val);
                t.pack();
              }
            }
            if (lshow) {
              var h = this._label._elem.outerHeight(true);
              this._label._elem.css("top", offmax - pixellength / 2 - h / 2 + "px");
              if (this.name == "yaxis") {
                this._label._elem.css("left", "0px");
              } else {
                this._label._elem.css("right", "0px");
              }
              this._label.pack();
            }
          }
        }
        ticks = null;
      };
    }
  });

  // node_modules/jqplot-exported/LinearTickGenerator.js
  var require_LinearTickGenerator = __commonJS({
    "node_modules/jqplot-exported/LinearTickGenerator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LinearTickGenerator = void 0;
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function bestFormatString(interval) {
        var fstr;
        interval = Math.abs(interval);
        if (interval >= 10) {
          fstr = "%d";
        } else if (interval > 1) {
          if (interval === parseInt(interval, 10)) {
            fstr = "%d";
          } else {
            fstr = "%.1f";
          }
        } else {
          var expv = -Math.floor(Math.log(interval) / Math.LN10);
          fstr = "%." + expv + "f";
        }
        return fstr;
      }
      function bestConstrainedInterval(min, max, nttarget) {
        var low = Math.floor(nttarget / 2);
        var hi = Math.ceil(nttarget * 1.5);
        var badness = Number.MAX_VALUE;
        var r = max - min;
        var temp;
        var sd;
        var bestNT;
        var gsf = _jqplot2.default.getSignificantFigures;
        var fsd;
        var fs;
        var currentNT;
        var bestPrec;
        for (var i2 = 0, l = hi - low + 1; i2 < l; i2++) {
          currentNT = low + i2;
          temp = r / (currentNT - 1);
          sd = gsf(temp);
          temp = Math.abs(nttarget - currentNT) + sd.digitsRight;
          if (temp < badness) {
            badness = temp;
            bestNT = currentNT;
            bestPrec = sd.digitsRight;
          } else if (temp === badness) {
            if (sd.digitsRight < bestPrec) {
              bestNT = currentNT;
              bestPrec = sd.digitsRight;
            }
          }
        }
        fsd = Math.max(bestPrec, Math.max(gsf(min).digitsRight, gsf(max).digitsRight));
        if (fsd === 0) {
          fs = "%d";
        } else {
          fs = "%." + fsd + "f";
        }
        temp = r / (bestNT - 1);
        return [min, max, bestNT, fs, temp];
      }
      function bestInterval(range, numberTicks) {
        numberTicks = numberTicks || 7;
        var minimum = range / (numberTicks - 1);
        var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.LN10));
        var residual = minimum / magnitude;
        var interval;
        if (magnitude < 1) {
          if (residual > 5) {
            interval = 10 * magnitude;
          } else if (residual > 2) {
            interval = 5 * magnitude;
          } else if (residual > 1) {
            interval = 2 * magnitude;
          } else {
            interval = magnitude;
          }
        } else {
          if (residual > 5) {
            interval = 10 * magnitude;
          } else if (residual > 4) {
            interval = 5 * magnitude;
          } else if (residual > 3) {
            interval = 4 * magnitude;
          } else if (residual > 2) {
            interval = 3 * magnitude;
          } else if (residual > 1) {
            interval = 2 * magnitude;
          } else {
            interval = magnitude;
          }
        }
        return interval;
      }
      function bestLinearInterval(range, scalefact) {
        scalefact = scalefact || 1;
        var expv = Math.floor(Math.log(range) / Math.LN10);
        var magnitude = Math.pow(10, expv);
        var f = range / magnitude;
        var fact;
        f = f / scalefact;
        if (f <= 0.38) {
          fact = 0.1;
        } else if (f <= 1.6) {
          fact = 0.2;
        } else if (f <= 4) {
          fact = 0.5;
        } else if (f <= 8) {
          fact = 1;
        } else if (f <= 16) {
          fact = 2;
        } else {
          fact = 5;
        }
        return fact * magnitude;
      }
      function bestLinearComponents(range, scalefact) {
        var expv = Math.floor(Math.log(range) / Math.LN10);
        var magnitude = Math.pow(10, expv);
        var f = range / magnitude;
        var interval;
        var fact;
        f = f / scalefact;
        if (f <= 0.38) {
          fact = 0.1;
        } else if (f <= 1.6) {
          fact = 0.2;
        } else if (f <= 4) {
          fact = 0.5;
        } else if (f <= 8) {
          fact = 1;
        } else if (f <= 16) {
          fact = 2;
        } else {
          fact = 5;
        }
        interval = fact * magnitude;
        return [interval, fact, magnitude];
      }
      var LinearTickGenerator = exports.LinearTickGenerator = _jqplot2.default.LinearTickGenerator = function(axis_min, axis_max, scalefact, numberTicks, keepMin, keepMax) {
        keepMin = keepMin === null ? false : keepMin;
        keepMax = keepMax === null || keepMin ? false : keepMax;
        if (axis_min === axis_max) {
          axis_max = axis_max ? 0 : 1;
        }
        scalefact = scalefact || 1;
        if (axis_max < axis_min) {
          var a = axis_max;
          axis_max = axis_min;
          axis_min = a;
        }
        var r = [];
        var ss = bestLinearInterval(axis_max - axis_min, scalefact);
        var gsf = _jqplot2.default.getSignificantFigures;
        if (numberTicks == null) {
          if (!keepMin && !keepMax) {
            r[0] = Math.floor(axis_min / ss) * ss;
            r[1] = Math.ceil(axis_max / ss) * ss;
            r[2] = Math.round((r[1] - r[0]) / ss + 1);
            r[3] = bestFormatString(ss);
            r[4] = ss;
          } else if (keepMin) {
            r[0] = axis_min;
            r[2] = Math.ceil((axis_max - axis_min) / ss + 1);
            r[1] = axis_min + (r[2] - 1) * ss;
            var digitsMin = gsf(axis_min).digitsRight;
            var digitsSS = gsf(ss).digitsRight;
            if (digitsMin < digitsSS) {
              r[3] = bestFormatString(ss);
            } else {
              r[3] = "%." + digitsMin + "f";
            }
            r[4] = ss;
          } else if (keepMax) {
            r[1] = axis_max;
            r[2] = Math.ceil((axis_max - axis_min) / ss + 1);
            r[0] = axis_max - (r[2] - 1) * ss;
            var digitsMax = gsf(axis_max).digitsRight;
            var digitsSS = gsf(ss).digitsRight;
            if (digitsMax < digitsSS) {
              r[3] = bestFormatString(ss);
            } else {
              r[3] = "%." + digitsMax + "f";
            }
            r[4] = ss;
          }
        } else {
          var tempr = [];
          tempr[0] = Math.floor(axis_min / ss) * ss;
          tempr[1] = Math.ceil(axis_max / ss) * ss;
          tempr[2] = Math.round((tempr[1] - tempr[0]) / ss + 1);
          tempr[3] = bestFormatString(ss);
          tempr[4] = ss;
          if (tempr[2] === numberTicks) {
            r = tempr;
          } else {
            var newti = bestInterval(tempr[1] - tempr[0], numberTicks);
            r[0] = tempr[0];
            r[2] = numberTicks;
            r[4] = newti;
            r[3] = bestFormatString(newti);
            r[1] = r[0] + (r[2] - 1) * r[4];
          }
        }
        return r;
      };
      _jqplot2.default.LinearTickGenerator.bestLinearInterval = bestLinearInterval;
      _jqplot2.default.LinearTickGenerator.bestInterval = bestInterval;
      _jqplot2.default.LinearTickGenerator.bestLinearComponents = bestLinearComponents;
      _jqplot2.default.LinearTickGenerator.bestConstrainedInterval = bestConstrainedInterval;
    }
  });

  // node_modules/jqplot-exported/MarkerRenderer.js
  var require_MarkerRenderer = __commonJS({
    "node_modules/jqplot-exported/MarkerRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MarkerRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var MarkerRenderer = exports.MarkerRenderer = _jqplot2.default.MarkerRenderer = function(options2) {
        this.show = true;
        this.style = "filledCircle";
        this.lineWidth = 2;
        this.size = 9;
        this.color = "#666666";
        this.shadow = true;
        this.shadowAngle = 45;
        this.shadowOffset = 1;
        this.shadowDepth = 3;
        this.shadowAlpha = "0.07";
        this.shadowRenderer = new _jqplot2.default.ShadowRenderer();
        this.shapeRenderer = new _jqplot2.default.ShapeRenderer();
        _jquery2.default.extend(true, this, options2);
      };
      function getShadowRendererOptions(opts) {
        var sdopt = { angle: opts.shadowAngle, offset: opts.shadowOffset, alpha: opts.shadowAlpha, lineWidth: opts.lineWidth, depth: opts.shadowDepth, closePath: true };
        if (opts.style.indexOf("filled") != -1) {
          sdopt.fill = true;
        }
        if (opts.style.indexOf("ircle") != -1) {
          sdopt.isarc = true;
          sdopt.closePath = false;
        }
        return _jquery2.default.extend(true, {}, sdopt);
      }
      function getShapeRendererOptions(opts) {
        var shopt = { fill: false, isarc: false, strokeStyle: opts.color, fillStyle: opts.color, lineWidth: opts.lineWidth, closePath: true };
        if (opts.style.indexOf("filled") != -1) {
          shopt.fill = true;
        }
        if (opts.style.indexOf("ircle") != -1) {
          shopt.isarc = true;
          shopt.closePath = false;
        }
        return _jquery2.default.extend(true, {}, shopt);
      }
      _jqplot2.default.MarkerRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.MarkerRenderer.prototype.drawDiamond = function(x, y, ctx, fill, options2) {
        var opts;
        if (options2 == null || _jquery2.default.isEmptyObject(options2)) {
          opts = this;
        } else {
          opts = _jquery2.default.extend(true, {}, this, options2);
        }
        var stretch = 1.2;
        var dx = this.size / 2 / stretch;
        var dy = this.size / 2 * stretch;
        var points = [[x - dx, y], [x, y + dy], [x + dx, y], [x, y - dy]];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.drawPlus = function(x, y, ctx, fill, options2) {
        var opts = _jquery2.default.extend(true, {}, this, options2, { closePath: false });
        var stretch = 1;
        var dx = opts.size / 2 * stretch;
        var dy = opts.size / 2 * stretch;
        var points1 = [[x, y - dy], [x, y + dy]];
        var points2 = [[x + dx, y], [x - dx, y]];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points1, getShadowRendererOptions(opts));
          this.shadowRenderer.draw(ctx, points2, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points1, opts);
        this.shapeRenderer.draw(ctx, points2, opts);
      };
      _jqplot2.default.MarkerRenderer.prototype.drawX = function(x, y, ctx, fill, options2) {
        var opts = _jquery2.default.extend(true, {}, this, options2, { closePath: false });
        var stretch = 1;
        var dx = opts.size / 2 * stretch;
        var dy = opts.size / 2 * stretch;
        var points1 = [[x - dx, y - dy], [x + dx, y + dy]];
        var points2 = [[x - dx, y + dy], [x + dx, y - dy]];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points1, getShadowRendererOptions(opts));
          this.shadowRenderer.draw(ctx, points2, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points1, getShapeRendererOptions(opts));
        this.shapeRenderer.draw(ctx, points2, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.drawDash = function(x, y, ctx, fill, options2) {
        var opts;
        if (options2 == null || _jquery2.default.isEmptyObject(options2)) {
          opts = this;
        } else {
          opts = _jquery2.default.extend(true, {}, this, options2);
        }
        var stretch = 1;
        var dx = this.size / 2 * stretch;
        var dy = this.size / 2 * stretch;
        var points = [[x - dx, y], [x + dx, y]];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.drawLine = function(p1, p2, ctx, fill, options2) {
        var opts;
        if (options2 == null || _jquery2.default.isEmptyObject(options2)) {
          opts = this;
        } else {
          opts = _jquery2.default.extend(true, {}, this, options2);
        }
        var points = [p1, p2];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.drawSquare = function(x, y, ctx, fill, options2) {
        var opts;
        if (options2 == null || _jquery2.default.isEmptyObject(options2)) {
          opts = this;
        } else {
          opts = _jquery2.default.extend(true, {}, this, options2);
        }
        var stretch = 1;
        var dx = this.size / 2 / stretch;
        var dy = this.size / 2 * stretch;
        var points = [[x - dx, y - dy], [x - dx, y + dy], [x + dx, y + dy], [x + dx, y - dy]];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.drawCircle = function(x, y, ctx, fill, options2) {
        var opts;
        if (options2 == null || _jquery2.default.isEmptyObject(options2)) {
          opts = this;
        } else {
          opts = _jquery2.default.extend(true, {}, this, options2);
        }
        var radius = this.size / 2;
        var end = 2 * Math.PI;
        var points = [x, y, radius, 0, end, true];
        if (opts.shadow) {
          this.shadowRenderer.draw(ctx, points, getShadowRendererOptions(opts));
        }
        this.shapeRenderer.draw(ctx, points, getShapeRendererOptions(opts));
      };
      _jqplot2.default.MarkerRenderer.prototype.draw = function(x, y, ctx, options2) {
        options2 = options2 || {};
        if (options2.show == null || options2.show != false) {
          if (options2.color && !options2.fillStyle) {
            options2.fillStyle = options2.color;
          }
          if (options2.color && !options2.strokeStyle) {
            options2.strokeStyle = options2.color;
          }
          var style = options2.style || this.style;
          switch (style) {
            case "diamond":
              this.drawDiamond(x, y, ctx, false, options2);
              break;
            case "filledDiamond":
              this.drawDiamond(x, y, ctx, true, options2);
              break;
            case "circle":
              this.drawCircle(x, y, ctx, false, options2);
              break;
            case "filledCircle":
              this.drawCircle(x, y, ctx, true, options2);
              break;
            case "square":
              this.drawSquare(x, y, ctx, false, options2);
              break;
            case "filledSquare":
              this.drawSquare(x, y, ctx, true, options2);
              break;
            case "x":
              this.drawX(x, y, ctx, true, options2);
              break;
            case "plus":
              this.drawPlus(x, y, ctx, true, options2);
              break;
            case "dash":
              this.drawDash(x, y, ctx, true, options2);
              break;
            case "line":
              this.drawLine(x, y, ctx, false, options2);
              break;
            default:
              this.drawDiamond(x, y, ctx, false, options2);
              break;
          }
        }
      };
    }
  });

  // node_modules/jqplot-exported/ShadowRenderer.js
  var require_ShadowRenderer = __commonJS({
    "node_modules/jqplot-exported/ShadowRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ShadowRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ShadowRenderer = exports.ShadowRenderer = _jqplot2.default.ShadowRenderer = function(options2) {
        this.angle = 45;
        this.offset = 1;
        this.alpha = 0.07;
        this.lineWidth = 1.5;
        this.lineJoin = "miter";
        this.lineCap = "round";
        this.closePath = false;
        this.fill = false;
        this.depth = 3;
        this.strokeStyle = "rgba(0,0,0,0.1)";
        this.isarc = false;
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.ShadowRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.ShadowRenderer.prototype.draw = function(ctx, points, options2) {
        ctx.save();
        var opts = options2 != null ? options2 : {};
        var fill = opts.fill != null ? opts.fill : this.fill;
        var fillRect = opts.fillRect != null ? opts.fillRect : this.fillRect;
        var closePath = opts.closePath != null ? opts.closePath : this.closePath;
        var offset = opts.offset != null ? opts.offset : this.offset;
        var alpha = opts.alpha != null ? opts.alpha : this.alpha;
        var depth = opts.depth != null ? opts.depth : this.depth;
        var isarc = opts.isarc != null ? opts.isarc : this.isarc;
        var linePattern = opts.linePattern != null ? opts.linePattern : this.linePattern;
        ctx.lineWidth = opts.lineWidth != null ? opts.lineWidth : this.lineWidth;
        ctx.lineJoin = opts.lineJoin != null ? opts.lineJoin : this.lineJoin;
        ctx.lineCap = opts.lineCap != null ? opts.lineCap : this.lineCap;
        ctx.strokeStyle = opts.strokeStyle || this.strokeStyle || "rgba(0,0,0," + alpha + ")";
        ctx.fillStyle = opts.fillStyle || this.fillStyle || "rgba(0,0,0," + alpha + ")";
        for (var j = 0; j < depth; j++) {
          var ctxPattern = _jqplot2.default.LinePattern(ctx, linePattern);
          ctx.translate(Math.cos(this.angle * Math.PI / 180) * offset, Math.sin(this.angle * Math.PI / 180) * offset);
          ctxPattern.beginPath();
          if (isarc) {
            ctx.arc(points[0], points[1], points[2], points[3], points[4], true);
          } else if (fillRect) {
            if (fillRect) {
              ctx.fillRect(points[0], points[1], points[2], points[3]);
            }
          } else if (points && points.length) {
            var move = true;
            for (var i2 = 0; i2 < points.length; i2++) {
              if (points[i2][0] != null && points[i2][1] != null) {
                if (move) {
                  ctxPattern.moveTo(points[i2][0], points[i2][1]);
                  move = false;
                } else {
                  ctxPattern.lineTo(points[i2][0], points[i2][1]);
                }
              } else {
                move = true;
              }
            }
          }
          if (closePath) {
            ctxPattern.closePath();
          }
          if (fill) {
            ctx.fill();
          } else {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
    }
  });

  // node_modules/jqplot-exported/ShapeRenderer.js
  var require_ShapeRenderer = __commonJS({
    "node_modules/jqplot-exported/ShapeRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ShapeRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ShapeRenderer = exports.ShapeRenderer = _jqplot2.default.ShapeRenderer = function(options2) {
        this.lineWidth = 1.5;
        this.linePattern = "solid";
        this.lineJoin = "miter";
        this.lineCap = "round";
        this.closePath = false;
        this.fill = false;
        this.isarc = false;
        this.fillRect = false;
        this.strokeRect = false;
        this.clearRect = false;
        this.strokeStyle = "#999999";
        this.fillStyle = "#999999";
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.ShapeRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.ShapeRenderer.prototype.draw = function(ctx, points, options2) {
        ctx.save();
        var opts = options2 != null ? options2 : {};
        var fill = opts.fill != null ? opts.fill : this.fill;
        var closePath = opts.closePath != null ? opts.closePath : this.closePath;
        var fillRect = opts.fillRect != null ? opts.fillRect : this.fillRect;
        var strokeRect = opts.strokeRect != null ? opts.strokeRect : this.strokeRect;
        var clearRect = opts.clearRect != null ? opts.clearRect : this.clearRect;
        var isarc = opts.isarc != null ? opts.isarc : this.isarc;
        var linePattern = opts.linePattern != null ? opts.linePattern : this.linePattern;
        var ctxPattern = _jqplot2.default.LinePattern(ctx, linePattern);
        ctx.lineWidth = opts.lineWidth || this.lineWidth;
        ctx.lineJoin = opts.lineJoin || this.lineJoin;
        ctx.lineCap = opts.lineCap || this.lineCap;
        ctx.strokeStyle = opts.strokeStyle || opts.color || this.strokeStyle;
        ctx.fillStyle = opts.fillStyle || this.fillStyle;
        ctx.beginPath();
        if (isarc) {
          ctx.arc(points[0], points[1], points[2], points[3], points[4], true);
          if (closePath) {
            ctx.closePath();
          }
          if (fill) {
            ctx.fill();
          } else {
            ctx.stroke();
          }
          ctx.restore();
          return;
        } else if (clearRect) {
          ctx.clearRect(points[0], points[1], points[2], points[3]);
          ctx.restore();
          return;
        } else if (fillRect || strokeRect) {
          if (fillRect) {
            ctx.fillRect(points[0], points[1], points[2], points[3]);
          }
          if (strokeRect) {
            ctx.strokeRect(points[0], points[1], points[2], points[3]);
            ctx.restore();
            return;
          }
        } else if (points && points.length) {
          var move = true;
          for (var i2 = 0; i2 < points.length; i2++) {
            if (points[i2][0] != null && points[i2][1] != null) {
              if (move) {
                ctxPattern.moveTo(points[i2][0], points[i2][1]);
                move = false;
              } else {
                ctxPattern.lineTo(points[i2][0], points[i2][1]);
              }
            } else {
              move = true;
            }
          }
          if (closePath) {
            ctxPattern.closePath();
          }
          if (fill) {
            ctx.fill();
          } else {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
    }
  });

  // node_modules/jqplot-exported/TableLegendRenderer.js
  var require_TableLegendRenderer = __commonJS({
    "node_modules/jqplot-exported/TableLegendRenderer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TableLegendRenderer = void 0;
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var TableLegendRenderer = exports.TableLegendRenderer = _jqplot2.default.TableLegendRenderer = function() {
      };
      _jqplot2.default.TableLegendRenderer.prototype.init = function(options2) {
        _jquery2.default.extend(true, this, options2);
      };
      _jqplot2.default.TableLegendRenderer.prototype.addrow = function(label, color, pad, reverse) {
        var rs = pad ? this.rowSpacing + "px" : "0px";
        var tr;
        var td;
        var elem;
        var div0;
        var div1;
        elem = document.createElement("tr");
        tr = (0, _jquery2.default)(elem);
        tr.addClass("jqplot-table-legend");
        elem = null;
        if (reverse) {
          tr.prependTo(this._elem);
        } else {
          tr.appendTo(this._elem);
        }
        if (this.showSwatches) {
          td = (0, _jquery2.default)(document.createElement("td"));
          td.addClass("jqplot-table-legend jqplot-table-legend-swatch");
          td.css({ textAlign: "center", paddingTop: rs });
          div0 = (0, _jquery2.default)(document.createElement("div"));
          div0.addClass("jqplot-table-legend-swatch-outline");
          div1 = (0, _jquery2.default)(document.createElement("div"));
          div1.addClass("jqplot-table-legend-swatch");
          div1.css({ backgroundColor: color, borderColor: color });
          tr.append(td.append(div0.append(div1)));
        }
        if (this.showLabels) {
          td = (0, _jquery2.default)(document.createElement("td"));
          td.addClass("jqplot-table-legend jqplot-table-legend-label");
          td.css("paddingTop", rs);
          tr.append(td);
          if (this.escapeHtml) {
            td.text(label);
          } else {
            td.html(label);
          }
        }
        td = null;
        div0 = null;
        div1 = null;
        tr = null;
        elem = null;
      };
      _jqplot2.default.TableLegendRenderer.prototype.draw = function() {
        if (this._elem) {
          this._elem.emptyForce();
          this._elem = null;
        }
        if (this.show) {
          var series = this._series;
          var elem = document.createElement("table");
          this._elem = (0, _jquery2.default)(elem);
          this._elem.addClass("jqplot-table-legend");
          var ss = { position: "absolute" };
          if (this.background) {
            ss["background"] = this.background;
          }
          if (this.border) {
            ss["border"] = this.border;
          }
          if (this.fontSize) {
            ss["fontSize"] = this.fontSize;
          }
          if (this.fontFamily) {
            ss["fontFamily"] = this.fontFamily;
          }
          if (this.textColor) {
            ss["textColor"] = this.textColor;
          }
          if (this.marginTop != null) {
            ss["marginTop"] = this.marginTop;
          }
          if (this.marginBottom != null) {
            ss["marginBottom"] = this.marginBottom;
          }
          if (this.marginLeft != null) {
            ss["marginLeft"] = this.marginLeft;
          }
          if (this.marginRight != null) {
            ss["marginRight"] = this.marginRight;
          }
          var pad = false, reverse = false, s;
          for (var i2 = 0; i2 < series.length; i2++) {
            s = series[i2];
            if (s._stack || s.renderer.constructor == _jqplot2.default.BezierCurveRenderer) {
              reverse = true;
            }
            if (s.show && s.showLabel) {
              var lt = this.labels[i2] || s.label.toString();
              if (lt) {
                var color = s.color;
                if (reverse && i2 < series.length - 1) {
                  pad = true;
                } else if (reverse && i2 == series.length - 1) {
                  pad = false;
                }
                this.renderer.addrow.call(this, lt, color, pad, reverse);
                pad = true;
              }
              for (var j = 0; j < _jqplot2.default.addLegendRowHooks.length; j++) {
                var item = _jqplot2.default.addLegendRowHooks[j].call(this, s);
                if (item) {
                  this.renderer.addrow.call(this, item.label, item.color, pad);
                  pad = true;
                }
              }
              lt = null;
            }
          }
        }
        return this._elem;
      };
      _jqplot2.default.TableLegendRenderer.prototype.pack = function(offsets) {
        if (this.show) {
          if (this.placement == "insideGrid") {
            switch (this.location) {
              case "nw":
                var a = offsets.left;
                var b = offsets.top;
                this._elem.css("left", a);
                this._elem.css("top", b);
                break;
              case "n":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                var b = offsets.top;
                this._elem.css("left", a);
                this._elem.css("top", b);
                break;
              case "ne":
                var a = offsets.right;
                var b = offsets.top;
                this._elem.css({ right: a, top: b });
                break;
              case "e":
                var a = offsets.right;
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ right: a, top: b });
                break;
              case "se":
                var a = offsets.right;
                var b = offsets.bottom;
                this._elem.css({ right: a, bottom: b });
                break;
              case "s":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                var b = offsets.bottom;
                this._elem.css({ left: a, bottom: b });
                break;
              case "sw":
                var a = offsets.left;
                var b = offsets.bottom;
                this._elem.css({ left: a, bottom: b });
                break;
              case "w":
                var a = offsets.left;
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ left: a, top: b });
                break;
              default:
                var a = offsets.right;
                var b = offsets.bottom;
                this._elem.css({ right: a, bottom: b });
                break;
            }
          } else if (this.placement == "outside") {
            switch (this.location) {
              case "nw":
                var a = this._plotDimensions.width - offsets.left;
                var b = offsets.top;
                this._elem.css("right", a);
                this._elem.css("top", b);
                break;
              case "n":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                var b = this._plotDimensions.height - offsets.top;
                this._elem.css("left", a);
                this._elem.css("bottom", b);
                break;
              case "ne":
                var a = this._plotDimensions.width - offsets.right;
                var b = offsets.top;
                this._elem.css({ left: a, top: b });
                break;
              case "e":
                var a = this._plotDimensions.width - offsets.right;
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ left: a, top: b });
                break;
              case "se":
                var a = this._plotDimensions.width - offsets.right;
                var b = offsets.bottom;
                this._elem.css({ left: a, bottom: b });
                break;
              case "s":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                var b = this._plotDimensions.height - offsets.bottom;
                this._elem.css({ left: a, top: b });
                break;
              case "sw":
                var a = this._plotDimensions.width - offsets.left;
                var b = offsets.bottom;
                this._elem.css({ right: a, bottom: b });
                break;
              case "w":
                var a = this._plotDimensions.width - offsets.left;
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ right: a, top: b });
                break;
              default:
                var a = offsets.right;
                var b = offsets.bottom;
                this._elem.css({ right: a, bottom: b });
                break;
            }
          } else {
            switch (this.location) {
              case "nw":
                this._elem.css({ left: 0, top: offsets.top });
                break;
              case "n":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                this._elem.css({ left: a, top: offsets.top });
                break;
              case "ne":
                this._elem.css({ right: 0, top: offsets.top });
                break;
              case "e":
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ right: offsets.right, top: b });
                break;
              case "se":
                this._elem.css({ right: offsets.right, bottom: offsets.bottom });
                break;
              case "s":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2;
                this._elem.css({ left: a, bottom: offsets.bottom });
                break;
              case "sw":
                this._elem.css({ left: offsets.left, bottom: offsets.bottom });
                break;
              case "w":
                var b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({ left: offsets.left, top: b });
                break;
              default:
                this._elem.css({ right: offsets.right, bottom: offsets.bottom });
                break;
            }
          }
        }
      };
    }
  });

  // node_modules/jqplot-exported/ThemeEngine.js
  var require_ThemeEngine = __commonJS({
    "node_modules/jqplot-exported/ThemeEngine.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Theme = exports.ThemeEngine = void 0;
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ThemeEngine = exports.ThemeEngine = _jqplot2.default.ThemeEngine = function() {
        this.themes = {};
        this.activeTheme = null;
      };
      _jqplot2.default.ThemeEngine.prototype.init = function() {
        var th = new _jqplot2.default.Theme({ _name: "Default" });
        var n, i2, nn;
        for (n in th.target) {
          if (n == "textColor") {
            th.target[n] = this.target.css("color");
          } else {
            th.target[n] = this.target.css(n);
          }
        }
        if (this.title.show && this.title._elem) {
          for (n in th.title) {
            if (n == "textColor") {
              th.title[n] = this.title._elem.css("color");
            } else {
              th.title[n] = this.title._elem.css(n);
            }
          }
        }
        for (n in th.grid) {
          th.grid[n] = this.grid[n];
        }
        if (th.grid.backgroundColor == null && this.grid.background != null) {
          th.grid.backgroundColor = this.grid.background;
        }
        if (this.legend.show && this.legend._elem) {
          for (n in th.legend) {
            if (n == "textColor") {
              th.legend[n] = this.legend._elem.css("color");
            } else {
              th.legend[n] = this.legend._elem.css(n);
            }
          }
        }
        var s;
        for (i2 = 0; i2 < this.series.length; i2++) {
          s = this.series[i2];
          if (s.renderer.constructor == _jqplot2.default.LineRenderer) {
            th.series.push(new LineSeriesProperties());
          } else if (s.renderer.constructor == _jqplot2.default.BarRenderer) {
            th.series.push(new BarSeriesProperties());
          } else if (s.renderer.constructor == _jqplot2.default.PieRenderer) {
            th.series.push(new PieSeriesProperties());
          } else if (s.renderer.constructor == _jqplot2.default.DonutRenderer) {
            th.series.push(new DonutSeriesProperties());
          } else if (s.renderer.constructor == _jqplot2.default.FunnelRenderer) {
            th.series.push(new FunnelSeriesProperties());
          } else if (s.renderer.constructor == _jqplot2.default.MeterGaugeRenderer) {
            th.series.push(new MeterSeriesProperties());
          } else {
            th.series.push({});
          }
          for (n in th.series[i2]) {
            th.series[i2][n] = s[n];
          }
        }
        var a, ax;
        for (n in this.axes) {
          ax = this.axes[n];
          a = th.axes[n] = new AxisProperties();
          a.borderColor = ax.borderColor;
          a.borderWidth = ax.borderWidth;
          if (ax._ticks && ax._ticks[0]) {
            for (nn in a.ticks) {
              if (ax._ticks[0].hasOwnProperty(nn)) {
                a.ticks[nn] = ax._ticks[0][nn];
              } else if (ax._ticks[0]._elem) {
                a.ticks[nn] = ax._ticks[0]._elem.css(nn);
              }
            }
          }
          if (ax._label && ax._label.show) {
            for (nn in a.label) {
              if (ax._label[nn]) {
                a.label[nn] = ax._label[nn];
              } else if (ax._label._elem) {
                if (nn == "textColor") {
                  a.label[nn] = ax._label._elem.css("color");
                } else {
                  a.label[nn] = ax._label._elem.css(nn);
                }
              }
            }
          }
        }
        this.themeEngine._add(th);
        this.themeEngine.activeTheme = this.themeEngine.themes[th._name];
      };
      _jqplot2.default.ThemeEngine.prototype.get = function(name) {
        if (!name) {
          return this.activeTheme;
        } else {
          return this.themes[name];
        }
      };
      function numericalOrder(a, b) {
        return a - b;
      }
      _jqplot2.default.ThemeEngine.prototype.getThemeNames = function() {
        var tn = [];
        for (var n in this.themes) {
          tn.push(n);
        }
        return tn.sort(numericalOrder);
      };
      _jqplot2.default.ThemeEngine.prototype.getThemes = function() {
        var tn = [];
        var themes = [];
        for (var n in this.themes) {
          tn.push(n);
        }
        tn.sort(numericalOrder);
        for (var i2 = 0; i2 < tn.length; i2++) {
          themes.push(this.themes[tn[i2]]);
        }
        return themes;
      };
      _jqplot2.default.ThemeEngine.prototype.activate = function(plot, name) {
        var redrawPlot = false;
        if (!name && this.activeTheme && this.activeTheme._name) {
          name = this.activeTheme._name;
        }
        if (!this.themes.hasOwnProperty(name)) {
          throw new Error("No theme of that name");
        } else {
          var th = this.themes[name];
          this.activeTheme = th;
          var val, checkBorderColor = false, checkBorderWidth = false;
          var arr = ["xaxis", "x2axis", "yaxis", "y2axis"];
          for (i2 = 0; i2 < arr.length; i2++) {
            var ax = arr[i2];
            if (th.axesStyles.borderColor != null) {
              plot.axes[ax].borderColor = th.axesStyles.borderColor;
            }
            if (th.axesStyles.borderWidth != null) {
              plot.axes[ax].borderWidth = th.axesStyles.borderWidth;
            }
          }
          for (var axname in plot.axes) {
            var axis = plot.axes[axname];
            if (axis.show) {
              var thaxis = th.axes[axname] || {};
              var thaxstyle = th.axesStyles;
              var thax = _jqplot2.default.extend(true, {}, thaxis, thaxstyle);
              val = th.axesStyles.borderColor != null ? th.axesStyles.borderColor : thax.borderColor;
              if (thax.borderColor != null) {
                axis.borderColor = thax.borderColor;
                redrawPlot = true;
              }
              val = th.axesStyles.borderWidth != null ? th.axesStyles.borderWidth : thax.borderWidth;
              if (thax.borderWidth != null) {
                axis.borderWidth = thax.borderWidth;
                redrawPlot = true;
              }
              if (axis._ticks && axis._ticks[0]) {
                for (var nn in thax.ticks) {
                  val = thax.ticks[nn];
                  if (val != null) {
                    axis.tickOptions[nn] = val;
                    axis._ticks = [];
                    redrawPlot = true;
                  }
                }
              }
              if (axis._label && axis._label.show) {
                for (var nn in thax.label) {
                  val = thax.label[nn];
                  if (val != null) {
                    axis.labelOptions[nn] = val;
                    redrawPlot = true;
                  }
                }
              }
            }
          }
          for (var n in th.grid) {
            if (th.grid[n] != null) {
              plot.grid[n] = th.grid[n];
            }
          }
          if (!redrawPlot) {
            plot.grid.draw();
          }
          if (plot.legend.show) {
            for (n in th.legend) {
              if (th.legend[n] != null) {
                plot.legend[n] = th.legend[n];
              }
            }
          }
          if (plot.title.show) {
            for (n in th.title) {
              if (th.title[n] != null) {
                plot.title[n] = th.title[n];
              }
            }
          }
          var i2;
          for (i2 = 0; i2 < th.series.length; i2++) {
            var opts = {};
            var redrawSeries = false;
            for (n in th.series[i2]) {
              val = th.seriesStyles[n] != null ? th.seriesStyles[n] : th.series[i2][n];
              if (val != null) {
                opts[n] = val;
                if (n == "color") {
                  plot.series[i2].renderer.shapeRenderer.fillStyle = val;
                  plot.series[i2].renderer.shapeRenderer.strokeStyle = val;
                  plot.series[i2][n] = val;
                } else if (n == "lineWidth" || n == "linePattern") {
                  plot.series[i2].renderer.shapeRenderer[n] = val;
                  plot.series[i2][n] = val;
                } else if (n == "markerOptions") {
                  merge(plot.series[i2].markerOptions, val);
                  merge(plot.series[i2].markerRenderer, val);
                } else {
                  plot.series[i2][n] = val;
                }
                redrawPlot = true;
              }
            }
          }
          if (redrawPlot) {
            plot.target.empty();
            plot.draw();
          }
          for (n in th.target) {
            if (th.target[n] != null) {
              plot.target.css(n, th.target[n]);
            }
          }
        }
      };
      _jqplot2.default.ThemeEngine.prototype._add = function(theme, name) {
        if (name) {
          theme._name = name;
        }
        if (!theme._name) {
          theme._name = Date.parse(new Date());
        }
        if (!this.themes.hasOwnProperty(theme._name)) {
          this.themes[theme._name] = theme;
        } else {
          throw new Error("jqplot.ThemeEngine Error: Theme already in use");
        }
      };
      _jqplot2.default.ThemeEngine.prototype.remove = function(name) {
        if (name == "Default") {
          return false;
        }
        return delete this.themes[name];
      };
      _jqplot2.default.ThemeEngine.prototype.newTheme = function(name, obj) {
        if ((typeof name === "undefined" ? "undefined" : _typeof(name)) == "object") {
          obj = obj || name;
          name = null;
        }
        if (obj && obj._name) {
          name = obj._name;
        } else {
          name = name || Date.parse(new Date());
        }
        var th = this.copy(this.themes["Default"]._name, name);
        _jqplot2.default.extend(th, obj);
        return th;
      };
      function clone(obj) {
        if (obj == null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) != "object") {
          return obj;
        }
        var temp = new obj.constructor();
        for (var key in obj) {
          temp[key] = clone(obj[key]);
        }
        return temp;
      }
      _jqplot2.default.clone = clone;
      function merge(obj1, obj2) {
        if (obj2 == null || (typeof obj2 === "undefined" ? "undefined" : _typeof(obj2)) != "object") {
          return;
        }
        for (var key in obj2) {
          if (key == "highlightColors") {
            obj1[key] = clone(obj2[key]);
          }
          if (obj2[key] != null && _typeof(obj2[key]) == "object") {
            if (!obj1.hasOwnProperty(key)) {
              obj1[key] = {};
            }
            merge(obj1[key], obj2[key]);
          } else {
            obj1[key] = obj2[key];
          }
        }
      }
      _jqplot2.default.merge = merge;
      _jqplot2.default.extend = function() {
        var target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false, options2;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i2 = 2;
        }
        if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !toString.call(target) === "[object Function]") {
          target = {};
        }
        for (; i2 < length; i2++) {
          if ((options2 = arguments[i2]) != null) {
            for (var name in options2) {
              var src = target[name], copy = options2[name];
              if (target === copy) {
                continue;
              }
              if (deep && copy && (typeof copy === "undefined" ? "undefined" : _typeof(copy)) === "object" && !copy.nodeType) {
                target[name] = _jqplot2.default.extend(
                  deep,
                  src || (copy.length != null ? [] : {}),
                  copy
                );
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      _jqplot2.default.ThemeEngine.prototype.rename = function(oldName, newName) {
        if (oldName == "Default" || newName == "Default") {
          throw new Error("jqplot.ThemeEngine Error: Cannot rename from/to Default");
        }
        if (this.themes.hasOwnProperty(newName)) {
          throw new Error("jqplot.ThemeEngine Error: New name already in use.");
        } else if (this.themes.hasOwnProperty(oldName)) {
          var th = this.copy(oldName, newName);
          this.remove(oldName);
          return th;
        }
        throw new Error("jqplot.ThemeEngine Error: Old name or new name invalid");
      };
      _jqplot2.default.ThemeEngine.prototype.copy = function(sourceName, targetName, obj) {
        if (targetName == "Default") {
          throw new Error("jqplot.ThemeEngine Error: Cannot copy over Default theme");
        }
        if (!this.themes.hasOwnProperty(sourceName)) {
          var s = "jqplot.ThemeEngine Error: Source name invalid";
          throw new Error(s);
        }
        if (this.themes.hasOwnProperty(targetName)) {
          var s = "jqplot.ThemeEngine Error: Target name invalid";
          throw new Error(s);
        } else {
          var th = clone(this.themes[sourceName]);
          th._name = targetName;
          _jqplot2.default.extend(true, th, obj);
          this._add(th);
          return th;
        }
      };
      var Theme = exports.Theme = _jqplot2.default.Theme = function(name, obj) {
        if ((typeof name === "undefined" ? "undefined" : _typeof(name)) == "object") {
          obj = obj || name;
          name = null;
        }
        name = name || Date.parse(new Date());
        this._name = name;
        this.target = {
          backgroundColor: null
        };
        this.legend = {
          textColor: null,
          fontFamily: null,
          fontSize: null,
          border: null,
          background: null
        };
        this.title = {
          textColor: null,
          fontFamily: null,
          fontSize: null,
          textAlign: null
        };
        this.seriesStyles = {};
        this.series = [];
        this.grid = {
          drawGridlines: null,
          gridLineColor: null,
          gridLineWidth: null,
          backgroundColor: null,
          borderColor: null,
          borderWidth: null,
          shadow: null
        };
        this.axesStyles = { label: {}, ticks: {} };
        this.axes = {};
        if (typeof obj == "string") {
          this._name = obj;
        } else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
          _jqplot2.default.extend(true, this, obj);
        }
      };
      var AxisProperties = function AxisProperties2() {
        this.borderColor = null;
        this.borderWidth = null;
        this.ticks = new AxisTicks();
        this.label = new AxisLabel();
      };
      var AxisTicks = function AxisTicks2() {
        this.show = null;
        this.showGridline = null;
        this.showLabel = null;
        this.showMark = null;
        this.size = null;
        this.textColor = null;
        this.whiteSpace = null;
        this.fontSize = null;
        this.fontFamily = null;
      };
      var AxisLabel = function AxisLabel2() {
        this.textColor = null;
        this.whiteSpace = null;
        this.fontSize = null;
        this.fontFamily = null;
        this.fontWeight = null;
      };
      var LineSeriesProperties = function LineSeriesProperties2() {
        this.color = null;
        this.lineWidth = null;
        this.linePattern = null;
        this.shadow = null;
        this.fillColor = null;
        this.showMarker = null;
        this.markerOptions = new MarkerOptions();
      };
      var MarkerOptions = function MarkerOptions2() {
        this.show = null;
        this.style = null;
        this.lineWidth = null;
        this.size = null;
        this.color = null;
        this.shadow = null;
      };
      var BarSeriesProperties = function BarSeriesProperties2() {
        this.color = null;
        this.seriesColors = null;
        this.lineWidth = null;
        this.shadow = null;
        this.barPadding = null;
        this.barMargin = null;
        this.barWidth = null;
        this.highlightColors = null;
      };
      var PieSeriesProperties = function PieSeriesProperties2() {
        this.seriesColors = null;
        this.padding = null;
        this.sliceMargin = null;
        this.fill = null;
        this.shadow = null;
        this.startAngle = null;
        this.lineWidth = null;
        this.highlightColors = null;
      };
      var DonutSeriesProperties = function DonutSeriesProperties2() {
        this.seriesColors = null;
        this.padding = null;
        this.sliceMargin = null;
        this.fill = null;
        this.shadow = null;
        this.startAngle = null;
        this.lineWidth = null;
        this.innerDiameter = null;
        this.thickness = null;
        this.ringMargin = null;
        this.highlightColors = null;
      };
      var FunnelSeriesProperties = function FunnelSeriesProperties2() {
        this.color = null;
        this.lineWidth = null;
        this.shadow = null;
        this.padding = null;
        this.sectionMargin = null;
        this.seriesColors = null;
        this.highlightColors = null;
      };
      var MeterSeriesProperties = function MeterSeriesProperties2() {
        this.padding = null;
        this.backgroundColor = null;
        this.ringColor = null;
        this.tickColor = null;
        this.ringWidth = null;
        this.intervalColors = null;
        this.intervalInnerRadius = null;
        this.intervalOuterRadius = null;
        this.hubRadius = null;
        this.needleThickness = null;
        this.needlePad = null;
      };
    }
  });

  // node_modules/jqplot-exported/jqplot.toImage.js
  var require_jqplot_toImage = __commonJS({
    "node_modules/jqplot-exported/jqplot.toImage.js"() {
      "use strict";
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      _jquery2.default.fn.jqplotChildText = function() {
        return (0, _jquery2.default)(this).contents().filter(function() {
          return this.nodeType == 3;
        }).text();
      };
      _jquery2.default.fn.jqplotGetComputedFontStyle = function() {
        var css = window.getComputedStyle ? window.getComputedStyle(this[0], "") : this[0].currentStyle;
        var attrs = css["font-style"] ? ["font-style", "font-weight", "font-size", "font-family"] : ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
        var style = [];
        for (var i2 = 0; i2 < attrs.length; ++i2) {
          var attr = String(css[attrs[i2]]);
          if (attr && attr != "normal") {
            style.push(attr);
          }
        }
        return style.join(" ");
      };
      _jquery2.default.fn.jqplotToImageCanvas = function(options2) {
        options2 = options2 || {};
        var x_offset = options2.x_offset == null ? 0 : options2.x_offset;
        var y_offset = options2.y_offset == null ? 0 : options2.y_offset;
        var backgroundColor = options2.backgroundColor == null ? "rgb(255,255,255)" : options2.backgroundColor;
        if ((0, _jquery2.default)(this).width() == 0 || (0, _jquery2.default)(this).height() == 0) {
          return null;
        }
        if (_jqplot2.default.use_excanvas) {
          return null;
        }
        var newCanvas = document.createElement("canvas");
        var h = (0, _jquery2.default)(this).outerHeight(true);
        var w = (0, _jquery2.default)(this).outerWidth(true);
        var offs = (0, _jquery2.default)(this).offset();
        var plotleft = offs.left;
        var plottop = offs.top;
        var transx = 0, transy = 0;
        var clses = ["jqplot-table-legend", "jqplot-xaxis-tick", "jqplot-x2axis-tick", "jqplot-yaxis-tick", "jqplot-y2axis-tick", "jqplot-y3axis-tick", "jqplot-y4axis-tick", "jqplot-y5axis-tick", "jqplot-y6axis-tick", "jqplot-y7axis-tick", "jqplot-y8axis-tick", "jqplot-y9axis-tick", "jqplot-xaxis-label", "jqplot-x2axis-label", "jqplot-yaxis-label", "jqplot-y2axis-label", "jqplot-y3axis-label", "jqplot-y4axis-label", "jqplot-y5axis-label", "jqplot-y6axis-label", "jqplot-y7axis-label", "jqplot-y8axis-label", "jqplot-y9axis-label"];
        var temptop, templeft, tempbottom, tempright;
        for (var i2 = 0; i2 < clses.length; i2++) {
          (0, _jquery2.default)(this).find("." + clses[i2]).each(function() {
            temptop = (0, _jquery2.default)(this).offset().top - plottop;
            templeft = (0, _jquery2.default)(this).offset().left - plotleft;
            tempright = templeft + (0, _jquery2.default)(this).outerWidth(true) + transx;
            tempbottom = temptop + (0, _jquery2.default)(this).outerHeight(true) + transy;
            if (templeft < -transx) {
              w = w - transx - templeft;
              transx = -templeft;
            }
            if (temptop < -transy) {
              h = h - transy - temptop;
              transy = -temptop;
            }
            if (tempright > w) {
              w = tempright;
            }
            if (tempbottom > h) {
              h = tempbottom;
            }
          });
        }
        newCanvas.width = w + Number(x_offset);
        newCanvas.height = h + Number(y_offset);
        var newContext = newCanvas.getContext("2d");
        newContext.save();
        newContext.fillStyle = backgroundColor;
        newContext.fillRect(0, 0, newCanvas.width, newCanvas.height);
        newContext.restore();
        newContext.translate(transx, transy);
        newContext.textAlign = "left";
        newContext.textBaseline = "top";
        function getLineheight(el) {
          var lineheight = parseInt((0, _jquery2.default)(el).css("line-height"), 10);
          if (isNaN(lineheight)) {
            lineheight = parseInt((0, _jquery2.default)(el).css("font-size"), 10) * 1.2;
          }
          return lineheight;
        }
        function writeWrappedText(el, context, text, left, top, canvasWidth) {
          var lineheight = getLineheight(el);
          var tagwidth = (0, _jquery2.default)(el).innerWidth();
          var tagheight = (0, _jquery2.default)(el).innerHeight();
          var words = text.split(/\s+/);
          var wl = words.length;
          var w2 = "";
          var breaks = [];
          var temptop2 = top;
          var templeft2 = left;
          for (var i3 = 0; i3 < wl; i3++) {
            w2 += words[i3];
            if (context.measureText(w2).width > tagwidth && w2.length > words[i3].length) {
              breaks.push(i3);
              w2 = "";
              i3--;
            }
          }
          if (breaks.length === 0) {
            if ((0, _jquery2.default)(el).css("textAlign") === "center") {
              templeft2 = left + (canvasWidth - context.measureText(w2).width) / 2 - transx;
            }
            context.fillText(text, templeft2, top);
          } else {
            w2 = words.slice(0, breaks[0]).join(" ");
            if ((0, _jquery2.default)(el).css("textAlign") === "center") {
              templeft2 = left + (canvasWidth - context.measureText(w2).width) / 2 - transx;
            }
            context.fillText(w2, templeft2, temptop2);
            temptop2 += lineheight;
            for (var i3 = 1, l = breaks.length; i3 < l; i3++) {
              w2 = words.slice(breaks[i3 - 1], breaks[i3]).join(" ");
              if ((0, _jquery2.default)(el).css("textAlign") === "center") {
                templeft2 = left + (canvasWidth - context.measureText(w2).width) / 2 - transx;
              }
              context.fillText(w2, templeft2, temptop2);
              temptop2 += lineheight;
            }
            w2 = words.slice(breaks[i3 - 1], words.length).join(" ");
            if ((0, _jquery2.default)(el).css("textAlign") === "center") {
              templeft2 = left + (canvasWidth - context.measureText(w2).width) / 2 - transx;
            }
            context.fillText(w2, templeft2, temptop2);
          }
        }
        function _jqpToImage(el, x_offset2, y_offset2) {
          var tagname = el.tagName.toLowerCase();
          var p = (0, _jquery2.default)(el).position();
          var css = window.getComputedStyle ? window.getComputedStyle(el, "") : el.currentStyle;
          var left = x_offset2 + p.left + parseInt(css.marginLeft, 10) + parseInt(css.borderLeftWidth, 10) + parseInt(css.paddingLeft, 10);
          var top = y_offset2 + p.top + parseInt(css.marginTop, 10) + parseInt(css.borderTopWidth, 10) + parseInt(css.paddingTop, 10);
          var w2 = newCanvas.width;
          if ((tagname == "div" || tagname == "span") && !(0, _jquery2.default)(el).hasClass("jqplot-highlighter-tooltip") && !(0, _jquery2.default)(el).hasClass("jqplot-canvasOverlay-tooltip")) {
            (0, _jquery2.default)(el).children().each(function() {
              _jqpToImage(this, left, top);
            });
            var text = (0, _jquery2.default)(el).jqplotChildText();
            if (text) {
              newContext.font = (0, _jquery2.default)(el).jqplotGetComputedFontStyle();
              newContext.fillStyle = (0, _jquery2.default)(el).css("color");
              writeWrappedText(el, newContext, text, left, top, w2);
            }
          } else if (tagname === "table" && (0, _jquery2.default)(el).hasClass("jqplot-table-legend")) {
            newContext.strokeStyle = (0, _jquery2.default)(el).css("border-top-color");
            newContext.fillStyle = (0, _jquery2.default)(el).css("background-color");
            newContext.fillRect(left, top, (0, _jquery2.default)(el).innerWidth(), (0, _jquery2.default)(el).innerHeight());
            if (parseInt((0, _jquery2.default)(el).css("border-top-width"), 10) > 0) {
              newContext.strokeRect(left, top, (0, _jquery2.default)(el).innerWidth(), (0, _jquery2.default)(el).innerHeight());
            }
            (0, _jquery2.default)(el).find("div.jqplot-table-legend-swatch-outline").each(function() {
              var elem2 = (0, _jquery2.default)(this);
              newContext.strokeStyle = elem2.css("border-top-color");
              var l = left + elem2.position().left;
              var t = top + elem2.position().top;
              newContext.strokeRect(l, t, elem2.innerWidth(), elem2.innerHeight());
              l += parseInt(elem2.css("padding-left"), 10);
              t += parseInt(elem2.css("padding-top"), 10);
              var h2 = elem2.innerHeight() - 2 * parseInt(elem2.css("padding-top"), 10);
              var w3 = elem2.innerWidth() - 2 * parseInt(elem2.css("padding-left"), 10);
              var swatch = elem2.children("div.jqplot-table-legend-swatch");
              newContext.fillStyle = swatch.css("background-color");
              newContext.fillRect(l, t, w3, h2);
            });
            (0, _jquery2.default)(el).find("td.jqplot-table-legend-label").each(function() {
              var elem2 = (0, _jquery2.default)(this);
              var l = left + elem2.position().left;
              var t = top + elem2.position().top + parseInt(elem2.css("padding-top"), 10);
              newContext.font = elem2.jqplotGetComputedFontStyle();
              newContext.fillStyle = elem2.css("color");
              writeWrappedText(elem2, newContext, elem2.text(), l, t, w2);
            });
            var elem = null;
          } else if (tagname == "canvas") {
            newContext.drawImage(el, left, top);
          }
        }
        (0, _jquery2.default)(this).children().each(function() {
          _jqpToImage(this, x_offset, y_offset);
        });
        return newCanvas;
      };
      _jquery2.default.fn.jqplotToImageStr = function(options2) {
        var imgCanvas = (0, _jquery2.default)(this).jqplotToImageCanvas(options2);
        if (imgCanvas) {
          return imgCanvas.toDataURL("image/png");
        } else {
          return null;
        }
      };
      _jquery2.default.fn.jqplotToImageElem = function(options2) {
        var elem = document.createElement("img");
        var str2 = (0, _jquery2.default)(this).jqplotToImageStr(options2);
        elem.src = str2;
        return elem;
      };
      _jquery2.default.fn.jqplotToImageElemStr = function(options2) {
        var str2 = "<img src=" + (0, _jquery2.default)(this).jqplotToImageStr(options2) + " />";
        return str2;
      };
      _jquery2.default.fn.jqplotSaveImage = function() {
        var imgData = (0, _jquery2.default)(this).jqplotToImageStr({});
        if (imgData) {
          window.location.href = imgData.replace("image/png", "image/octet-stream");
        }
      };
      _jquery2.default.fn.jqplotViewImage = function() {
        var imgStr = (0, _jquery2.default)(this).jqplotToImageElemStr({});
        var imgData = (0, _jquery2.default)(this).jqplotToImageStr({});
        if (imgStr) {
          var w = window.open("");
          w.document.open("image/png");
          w.document.write(imgStr);
          w.document.close();
          w = null;
        }
      };
    }
  });

  // node_modules/jqplot-exported/jsdate.js
  var require_jsdate = __commonJS({
    "node_modules/jqplot-exported/jsdate.js"(exports, module) {
      "use strict";
      var jsDate = function jsDate2() {
        this.syntax = jsDate2.config.syntax;
        this._type = "jsDate";
        this.proxy = new Date();
        this.options = {};
        this.locale = jsDate2.regional.getLocale();
        this.formatString = "";
        this.defaultCentury = jsDate2.config.defaultCentury;
        switch (arguments.length) {
          case 0:
            break;
          case 1:
            if (get_type(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") {
              var opts = this.options = arguments[0];
              this.syntax = opts.syntax || this.syntax;
              this.defaultCentury = opts.defaultCentury || this.defaultCentury;
              this.proxy = jsDate2.createDate(opts.date);
            } else {
              this.proxy = jsDate2.createDate(arguments[0]);
            }
            break;
          default:
            var a = [];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              a.push(arguments[i2]);
            }
            this.proxy = new Date();
            this.proxy.setFullYear.apply(this.proxy, a.slice(0, 3));
            if (a.slice(3).length) {
              this.proxy.setHours.apply(this.proxy, a.slice(3));
            }
            break;
        }
      };
      jsDate.config = {
        defaultLocale: "en",
        syntax: "perl",
        defaultCentury: 1900
      };
      jsDate.prototype.add = function(number, unit2) {
        var factor = multipliers[unit2] || multipliers.day;
        if (typeof factor == "number") {
          this.proxy.setTime(this.proxy.getTime() + factor * number);
        } else {
          factor.add(this, number);
        }
        return this;
      };
      jsDate.prototype.clone = function() {
        return new jsDate(this.proxy.getTime());
      };
      jsDate.prototype.getUtcOffset = function() {
        return this.proxy.getTimezoneOffset() * 6e4;
      };
      jsDate.prototype.diff = function(dateObj, unit2, allowDecimal) {
        dateObj = new jsDate(dateObj);
        if (dateObj === null) {
          return null;
        }
        var factor = multipliers[unit2] || multipliers.day;
        if (typeof factor == "number") {
          var unitDiff = (this.proxy.getTime() - dateObj.proxy.getTime()) / factor;
        } else {
          var unitDiff = factor.diff(this.proxy, dateObj.proxy);
        }
        return allowDecimal ? unitDiff : Math[unitDiff > 0 ? "floor" : "ceil"](unitDiff);
      };
      jsDate.prototype.getAbbrDayName = function() {
        return jsDate.regional[this.locale]["dayNamesShort"][this.proxy.getDay()];
      };
      jsDate.prototype.getAbbrMonthName = function() {
        return jsDate.regional[this.locale]["monthNamesShort"][this.proxy.getMonth()];
      };
      jsDate.prototype.getAMPM = function() {
        return this.proxy.getHours() >= 12 ? "PM" : "AM";
      };
      jsDate.prototype.getAmPm = function() {
        return this.proxy.getHours() >= 12 ? "pm" : "am";
      };
      jsDate.prototype.getCentury = function() {
        return parseInt(this.proxy.getFullYear() / 100, 10);
      };
      jsDate.prototype.getDate = function() {
        return this.proxy.getDate();
      };
      jsDate.prototype.getDay = function() {
        return this.proxy.getDay();
      };
      jsDate.prototype.getDayOfWeek = function() {
        var dow = this.proxy.getDay();
        return dow === 0 ? 7 : dow;
      };
      jsDate.prototype.getDayOfYear = function() {
        var d2 = this.proxy;
        var ms = d2 - new Date("" + d2.getFullYear() + "/1/1 GMT");
        ms += d2.getTimezoneOffset() * 6e4;
        d2 = null;
        return parseInt(ms / 6e4 / 60 / 24, 10) + 1;
      };
      jsDate.prototype.getDayName = function() {
        return jsDate.regional[this.locale]["dayNames"][this.proxy.getDay()];
      };
      jsDate.prototype.getFullWeekOfYear = function() {
        var d2 = this.proxy;
        var doy = this.getDayOfYear();
        var rdow = 6 - d2.getDay();
        var woy = parseInt((doy + rdow) / 7, 10);
        return woy;
      };
      jsDate.prototype.getFullYear = function() {
        return this.proxy.getFullYear();
      };
      jsDate.prototype.getGmtOffset = function() {
        var hours = this.proxy.getTimezoneOffset() / 60;
        var prefix = hours < 0 ? "+" : "-";
        hours = Math.abs(hours);
        return prefix + addZeros(Math.floor(hours), 2) + ":" + addZeros(hours % 1 * 60, 2);
      };
      jsDate.prototype.getHours = function() {
        return this.proxy.getHours();
      };
      jsDate.prototype.getHours12 = function() {
        var hours = this.proxy.getHours();
        return hours > 12 ? hours - 12 : hours == 0 ? 12 : hours;
      };
      jsDate.prototype.getIsoWeek = function() {
        var d2 = this.proxy;
        var woy = this.getWeekOfYear();
        var dow1_1 = new Date("" + d2.getFullYear() + "/1/1").getDay();
        var idow = woy + (dow1_1 > 4 || dow1_1 <= 1 ? 0 : 1);
        if (idow == 53 && new Date("" + d2.getFullYear() + "/12/31").getDay() < 4) {
          idow = 1;
        } else if (idow === 0) {
          d2 = new jsDate(new Date("" + (d2.getFullYear() - 1) + "/12/31"));
          idow = d2.getIsoWeek();
        }
        d2 = null;
        return idow;
      };
      jsDate.prototype.getMilliseconds = function() {
        return this.proxy.getMilliseconds();
      };
      jsDate.prototype.getMinutes = function() {
        return this.proxy.getMinutes();
      };
      jsDate.prototype.getMonth = function() {
        return this.proxy.getMonth();
      };
      jsDate.prototype.getMonthName = function() {
        return jsDate.regional[this.locale]["monthNames"][this.proxy.getMonth()];
      };
      jsDate.prototype.getMonthNumber = function() {
        return this.proxy.getMonth() + 1;
      };
      jsDate.prototype.getSeconds = function() {
        return this.proxy.getSeconds();
      };
      jsDate.prototype.getShortYear = function() {
        return this.proxy.getYear() % 100;
      };
      jsDate.prototype.getTime = function() {
        return this.proxy.getTime();
      };
      jsDate.prototype.getTimezoneAbbr = function() {
        return this.proxy.toString().replace(/^.*\(([^)]+)\)$/, "$1");
      };
      jsDate.prototype.getTimezoneName = function() {
        var match = /(?:\((.+)\)$| ([A-Z]{3}) )/.exec(this.toString());
        return match[1] || match[2] || "GMT" + this.getGmtOffset();
      };
      jsDate.prototype.getTimezoneOffset = function() {
        return this.proxy.getTimezoneOffset();
      };
      jsDate.prototype.getWeekOfYear = function() {
        var doy = this.getDayOfYear();
        var rdow = 7 - this.getDayOfWeek();
        var woy = parseInt((doy + rdow) / 7, 10);
        return woy;
      };
      jsDate.prototype.getUnix = function() {
        return Math.round(this.proxy.getTime() / 1e3, 0);
      };
      jsDate.prototype.getYear = function() {
        return this.proxy.getYear();
      };
      jsDate.prototype.next = function(unit2) {
        unit2 = unit2 || "day";
        return this.clone().add(1, unit2);
      };
      jsDate.prototype.set = function() {
        switch (arguments.length) {
          case 0:
            this.proxy = new Date();
            break;
          case 1:
            if (get_type(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") {
              var opts = this.options = arguments[0];
              this.syntax = opts.syntax || this.syntax;
              this.defaultCentury = opts.defaultCentury || this.defaultCentury;
              this.proxy = jsDate.createDate(opts.date);
            } else {
              this.proxy = jsDate.createDate(arguments[0]);
            }
            break;
          default:
            var a = [];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              a.push(arguments[i2]);
            }
            this.proxy = new Date();
            this.proxy.setFullYear.apply(this.proxy, a.slice(0, 3));
            if (a.slice(3).length) {
              this.proxy.setHours.apply(this.proxy, a.slice(3));
            }
            break;
        }
        return this;
      };
      jsDate.prototype.setDate = function(n) {
        this.proxy.setDate(n);
        return this;
      };
      jsDate.prototype.setFullYear = function() {
        this.proxy.setFullYear.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.setHours = function() {
        this.proxy.setHours.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.setMilliseconds = function(n) {
        this.proxy.setMilliseconds(n);
        return this;
      };
      jsDate.prototype.setMinutes = function() {
        this.proxy.setMinutes.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.setMonth = function() {
        this.proxy.setMonth.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.setSeconds = function() {
        this.proxy.setSeconds.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.setTime = function(n) {
        this.proxy.setTime(n);
        return this;
      };
      jsDate.prototype.setYear = function() {
        this.proxy.setYear.apply(this.proxy, arguments);
        return this;
      };
      jsDate.prototype.strftime = function(formatString) {
        formatString = formatString || this.formatString || jsDate.regional[this.locale]["formatString"];
        return jsDate.strftime(this, formatString, this.syntax);
      };
      jsDate.prototype.toString = function() {
        return this.proxy.toString();
      };
      jsDate.prototype.toYmdInt = function() {
        return this.proxy.getFullYear() * 1e4 + this.getMonthNumber() * 100 + this.proxy.getDate();
      };
      jsDate.regional = {
        "en": {
          monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "fr": {
          monthNames: ["Janvier", "F\xE9vrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Ao\xFBt", "Septembre", "Octobre", "Novembre", "D\xE9cembre"],
          monthNamesShort: ["Jan", "F\xE9v", "Mar", "Avr", "Mai", "Jun", "Jul", "Ao\xFB", "Sep", "Oct", "Nov", "D\xE9c"],
          dayNames: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
          dayNamesShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "de": {
          monthNames: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
          monthNamesShort: ["Jan", "Feb", "M\xE4r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          dayNames: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
          dayNamesShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "es": {
          monthNames: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
          monthNamesShort: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
          dayNames: ["Domingo", "Lunes", "Martes", "Mi&eacute;rcoles", "Jueves", "Viernes", "S&aacute;bado"],
          dayNamesShort: ["Dom", "Lun", "Mar", "Mi&eacute;", "Juv", "Vie", "S&aacute;b"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "ru": {
          monthNames: ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"],
          monthNamesShort: ["\u042F\u043D\u0432", "\u0424\u0435\u0432", "\u041C\u0430\u0440", "\u0410\u043F\u0440", "\u041C\u0430\u0439", "\u0418\u044E\u043D", "\u0418\u044E\u043B", "\u0410\u0432\u0433", "\u0421\u0435\u043D", "\u041E\u043A\u0442", "\u041D\u043E\u044F", "\u0414\u0435\u043A"],
          dayNames: ["\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0432\u0442\u043E\u0440\u043D\u0438\u043A", "\u0441\u0440\u0435\u0434\u0430", "\u0447\u0435\u0442\u0432\u0435\u0440\u0433", "\u043F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0441\u0443\u0431\u0431\u043E\u0442\u0430"],
          dayNamesShort: ["\u0432\u0441\u043A", "\u043F\u043D\u0434", "\u0432\u0442\u0440", "\u0441\u0440\u0434", "\u0447\u0442\u0432", "\u043F\u0442\u043D", "\u0441\u0431\u0442"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "ar": {
          monthNames: ["\u0643\u0627\u0646\u0648\u0646 \u0627\u0644\u062B\u0627\u0646\u064A", "\u0634\u0628\u0627\u0637", "\u0622\u0630\u0627\u0631", "\u0646\u064A\u0633\u0627\u0646", "\u0622\u0630\u0627\u0631", "\u062D\u0632\u064A\u0631\u0627\u0646", "\u062A\u0645\u0648\u0632", "\u0622\u0628", "\u0623\u064A\u0644\u0648\u0644", "\u062A\u0634\u0631\u064A\u0646 \u0627\u0644\u0623\u0648\u0644", "\u062A\u0634\u0631\u064A\u0646 \u0627\u0644\u062B\u0627\u0646\u064A", "\u0643\u0627\u0646\u0648\u0646 \u0627\u0644\u0623\u0648\u0644"],
          monthNamesShort: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          dayNames: ["\u0627\u0644\u0633\u0628\u062A", "\u0627\u0644\u0623\u062D\u062F", "\u0627\u0644\u0627\u062B\u0646\u064A\u0646", "\u0627\u0644\u062B\u0644\u0627\u062B\u0627\u0621", "\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621", "\u0627\u0644\u062E\u0645\u064A\u0633", "\u0627\u0644\u062C\u0645\u0639\u0629"],
          dayNamesShort: ["\u0633\u0628\u062A", "\u0623\u062D\u062F", "\u0627\u062B\u0646\u064A\u0646", "\u062B\u0644\u0627\u062B\u0627\u0621", "\u0623\u0631\u0628\u0639\u0627\u0621", "\u062E\u0645\u064A\u0633", "\u062C\u0645\u0639\u0629"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "pt": {
          monthNames: ["Janeiro", "Fevereiro", "Mar&ccedil;o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
          monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
          dayNames: ["Domingo", "Segunda-feira", "Ter&ccedil;a-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S&aacute;bado"],
          dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "pt-BR": {
          monthNames: ["Janeiro", "Fevereiro", "Mar&ccedil;o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
          monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
          dayNames: ["Domingo", "Segunda-feira", "Ter&ccedil;a-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S&aacute;bado"],
          dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "pl": {
          monthNames: ["Stycze\u0144", "Luty", "Marzec", "Kwiecie\u0144", "Maj", "Czerwiec", "Lipiec", "Sierpie\u0144", "Wrzesie\u0144", "Pa\u017Adziernik", "Listopad", "Grudzie\u0144"],
          monthNamesShort: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa\u017A", "Lis", "Gru"],
          dayNames: ["Niedziela", "Poniedzia\u0142ek", "Wtorek", "\u015Aroda", "Czwartek", "Pi\u0105tek", "Sobota"],
          dayNamesShort: ["Ni", "Pn", "Wt", "\u015Ar", "Cz", "Pt", "Sb"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "nl": {
          monthNames: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "July", "Augustus", "September", "Oktober", "November", "December"],
          monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
          dayNames: ","["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"],
          dayNamesShort: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "sv": {
          monthNames: ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"],
          monthNamesShort: ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
          dayNames: ["s\xF6ndag", "m\xE5ndag", "tisdag", "onsdag", "torsdag", "fredag", "l\xF6rdag"],
          dayNamesShort: ["s\xF6n", "m\xE5n", "tis", "ons", "tor", "fre", "l\xF6r"],
          formatString: "%Y-%m-%d %H:%M:%S"
        },
        "it": {
          monthNames: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
          monthNamesShort: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
          dayNames: ["Domenica", "Lunedi", "Martedi", "Mercoledi", "Giovedi", "Venerdi", "Sabato"],
          dayNamesShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          formatString: "%d-%m-%Y %H:%M:%S"
        }
      };
      jsDate.regional["en-US"] = jsDate.regional["en-GB"] = jsDate.regional["en"];
      jsDate.regional.getLocale = function() {
        var l = jsDate.config.defaultLocale;
        if (document && document.getElementsByTagName("html") && document.getElementsByTagName("html")[0].lang) {
          l = document.getElementsByTagName("html")[0].lang;
          if (!jsDate.regional.hasOwnProperty(l)) {
            l = jsDate.config.defaultLocale;
          }
        }
        return l;
      };
      var day = 24 * 60 * 60 * 1e3;
      var addZeros = function addZeros2(num, digits) {
        num = String(num);
        var i2 = digits - num.length;
        var s = String(Math.pow(10, i2)).slice(1);
        return s.concat(num);
      };
      var multipliers = {
        millisecond: 1,
        second: 1e3,
        minute: 60 * 1e3,
        hour: 60 * 60 * 1e3,
        day,
        week: 7 * day,
        month: {
          add: function add(d2, number) {
            multipliers.year.add(d2, Math[number > 0 ? "floor" : "ceil"](number / 12));
            var prevMonth = d2.getMonth() + number % 12;
            if (prevMonth == 12) {
              prevMonth = 0;
              d2.setYear(d2.getFullYear() + 1);
            } else if (prevMonth == -1) {
              prevMonth = 11;
              d2.setYear(d2.getFullYear() - 1);
            }
            d2.setMonth(prevMonth);
          },
          diff: function diff(d1, d2) {
            var diffYears = d1.getFullYear() - d2.getFullYear();
            var diffMonths = d1.getMonth() - d2.getMonth() + diffYears * 12;
            var diffDays = d1.getDate() - d2.getDate();
            return diffMonths + diffDays / 30;
          }
        },
        year: {
          add: function add(d2, number) {
            d2.setYear(d2.getFullYear() + Math[number > 0 ? "floor" : "ceil"](number));
          },
          diff: function diff(d1, d2) {
            return multipliers.month.diff(d1, d2) / 12;
          }
        }
      };
      for (unit in multipliers) {
        if (unit.substring(unit.length - 1) != "s") {
          multipliers[unit + "s"] = multipliers[unit];
        }
      }
      var unit;
      var format = function format2(d2, code, syntax) {
        if (jsDate.formats[syntax]["shortcuts"][code]) {
          return jsDate.strftime(d2, jsDate.formats[syntax]["shortcuts"][code], syntax);
        } else {
          var getter = (jsDate.formats[syntax]["codes"][code] || "").split(".");
          var nbr = d2["get" + getter[0]] ? d2["get" + getter[0]]() : "";
          if (getter[1]) {
            nbr = addZeros(nbr, getter[1]);
          }
          return nbr;
        }
      };
      jsDate.strftime = function(d2, formatString, syntax, locale) {
        var syn = "perl";
        var loc = jsDate.regional.getLocale();
        if (syntax && jsDate.formats.hasOwnProperty(syntax)) {
          syn = syntax;
        } else if (syntax && jsDate.regional.hasOwnProperty(syntax)) {
          loc = syntax;
        }
        if (locale && jsDate.formats.hasOwnProperty(locale)) {
          syn = locale;
        } else if (locale && jsDate.regional.hasOwnProperty(locale)) {
          loc = locale;
        }
        if (get_type(d2) != "[object Object]" || d2._type != "jsDate") {
          d2 = new jsDate(d2);
          d2.locale = loc;
        }
        if (!formatString) {
          formatString = d2.formatString || jsDate.regional[loc]["formatString"];
        }
        var source = formatString || "%Y-%m-%d", result = "", match;
        while (source.length > 0) {
          if (match = source.match(jsDate.formats[syn].codes.matcher)) {
            result += source.slice(0, match.index);
            result += (match[1] || "") + format(d2, match[2], syn);
            source = source.slice(match.index + match[0].length);
          } else {
            result += source;
            source = "";
          }
        }
        return result;
      };
      jsDate.formats = {
        ISO: "%Y-%m-%dT%H:%M:%S.%N%G",
        SQL: "%Y-%m-%d %H:%M:%S"
      };
      jsDate.formats.perl = {
        codes: {
          matcher: /()%(#?(%|[a-z]))/i,
          Y: "FullYear",
          y: "ShortYear.2",
          m: "MonthNumber.2",
          "#m": "MonthNumber",
          B: "MonthName",
          b: "AbbrMonthName",
          d: "Date.2",
          "#d": "Date",
          e: "Date",
          A: "DayName",
          a: "AbbrDayName",
          w: "Day",
          H: "Hours.2",
          "#H": "Hours",
          I: "Hours12.2",
          "#I": "Hours12",
          p: "AMPM",
          M: "Minutes.2",
          "#M": "Minutes",
          S: "Seconds.2",
          "#S": "Seconds",
          s: "Unix",
          N: "Milliseconds.3",
          "#N": "Milliseconds",
          O: "TimezoneOffset",
          Z: "TimezoneName",
          G: "GmtOffset"
        },
        shortcuts: {
          F: "%Y-%m-%d",
          T: "%H:%M:%S",
          X: "%H:%M:%S",
          x: "%m/%d/%y",
          D: "%m/%d/%y",
          "#c": "%a %b %e %H:%M:%S %Y",
          v: "%e-%b-%Y",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          t: "	",
          n: "\n",
          "%": "%"
        }
      };
      jsDate.formats.php = {
        codes: {
          matcher: /()%((%|[a-z]))/i,
          a: "AbbrDayName",
          A: "DayName",
          d: "Date.2",
          e: "Date",
          j: "DayOfYear.3",
          u: "DayOfWeek",
          w: "Day",
          U: "FullWeekOfYear.2",
          V: "IsoWeek.2",
          W: "WeekOfYear.2",
          b: "AbbrMonthName",
          B: "MonthName",
          m: "MonthNumber.2",
          h: "AbbrMonthName",
          C: "Century.2",
          y: "ShortYear.2",
          Y: "FullYear",
          H: "Hours.2",
          I: "Hours12.2",
          l: "Hours12",
          p: "AMPM",
          P: "AmPm",
          M: "Minutes.2",
          S: "Seconds.2",
          s: "Unix",
          O: "TimezoneOffset",
          z: "GmtOffset",
          Z: "TimezoneAbbr"
        },
        shortcuts: {
          D: "%m/%d/%y",
          F: "%Y-%m-%d",
          T: "%H:%M:%S",
          X: "%H:%M:%S",
          x: "%m/%d/%y",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          t: "	",
          n: "\n",
          "%": "%"
        }
      };
      jsDate.createDate = function(date) {
        if (date == null) {
          return new Date();
        }
        if (date instanceof Date) {
          return date;
        }
        if (typeof date == "number") {
          return new Date(date);
        }
        var parsable = String(date).replace(/^\s*(.+)\s*$/g, "$1");
        parsable = parsable.replace(/^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,4})/, "$1/$2/$3");
        parsable = parsable.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{4})/i, "$1 $2 $3");
        var match = parsable.match(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i);
        if (match && match.length > 3) {
          var m3 = parseFloat(match[3]);
          var ny = jsDate.config.defaultCentury + m3;
          ny = String(ny);
          parsable = parsable.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i, match[1] + " " + match[2] + " " + ny);
        }
        match = parsable.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})[^0-9]/);
        function h1(parsable2, match2) {
          var m1 = parseFloat(match2[1]);
          var m2 = parseFloat(match2[2]);
          var m32 = parseFloat(match2[3]);
          var cent = jsDate.config.defaultCentury;
          var ny2, nd, nm, str2;
          if (m1 > 31) {
            nd = m32;
            nm = m2;
            ny2 = cent + m1;
          } else {
            nd = m2;
            nm = m1;
            ny2 = cent + m32;
          }
          str2 = nm + "/" + nd + "/" + ny2;
          return parsable2.replace(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})/, str2);
        }
        if (match && match.length > 3) {
          parsable = h1(parsable, match);
        }
        var match = parsable.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})$/);
        if (match && match.length > 3) {
          parsable = h1(parsable, match);
        }
        var i2 = 0;
        var length = jsDate.matchers.length;
        var pattern, ms, current = parsable, obj;
        while (i2 < length) {
          ms = Date.parse(current);
          if (!isNaN(ms)) {
            return new Date(ms);
          }
          pattern = jsDate.matchers[i2];
          if (typeof pattern == "function") {
            obj = pattern.call(jsDate, current);
            if (obj instanceof Date) {
              return obj;
            }
          } else {
            current = parsable.replace(pattern[0], pattern[1]);
          }
          i2++;
        }
        return NaN;
      };
      jsDate.daysInMonth = function(year, month) {
        if (month == 2) {
          return new Date(year, 1, 29).getDate() == 29 ? 29 : 28;
        }
        return [void 0, 31, void 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
      };
      jsDate.matchers = [
        [/(3[01]|[0-2]\d)\s*\.\s*(1[0-2]|0\d)\s*\.\s*([1-9]\d{3})/, "$2/$1/$3"],
        [/([1-9]\d{3})\s*-\s*(1[0-2]|0\d)\s*-\s*(3[01]|[0-2]\d)/, "$2/$3/$1"],
        function(str2) {
          var match = str2.match(/^(?:(.+)\s+)?([012]?\d)(?:\s*\:\s*(\d\d))?(?:\s*\:\s*(\d\d(\.\d*)?))?\s*(am|pm)?\s*$/i);
          if (match) {
            if (match[1]) {
              var d2 = this.createDate(match[1]);
              if (isNaN(d2)) {
                return;
              }
            } else {
              var d2 = new Date();
              d2.setMilliseconds(0);
            }
            var hour = parseFloat(match[2]);
            if (match[6]) {
              hour = match[6].toLowerCase() == "am" ? hour == 12 ? 0 : hour : hour == 12 ? 12 : hour + 12;
            }
            d2.setHours(hour, parseInt(match[3] || 0, 10), parseInt(match[4] || 0, 10), (parseFloat(match[5] || 0) || 0) * 1e3);
            return d2;
          } else {
            return str2;
          }
        },
        function(str2) {
          var match = str2.match(/^(?:(.+))[T|\s+]([012]\d)(?:\:(\d\d))(?:\:(\d\d))(?:\.\d+)([\+\-]\d\d\:\d\d)$/i);
          if (match) {
            if (match[1]) {
              var d2 = this.createDate(match[1]);
              if (isNaN(d2)) {
                return;
              }
            } else {
              var d2 = new Date();
              d2.setMilliseconds(0);
            }
            var hour = parseFloat(match[2]);
            d2.setHours(hour, parseInt(match[3], 10), parseInt(match[4], 10), parseFloat(match[5]) * 1e3);
            return d2;
          } else {
            return str2;
          }
        },
        function(str2) {
          var match = str2.match(/^([0-3]?\d)\s*[-\/.\s]{1}\s*([a-zA-Z]{3,9})\s*[-\/.\s]{1}\s*([0-3]?\d)$/);
          if (match) {
            var d2 = new Date();
            var cent = jsDate.config.defaultCentury;
            var m1 = parseFloat(match[1]);
            var m3 = parseFloat(match[3]);
            var ny, nd, nm;
            if (m1 > 31) {
              nd = m3;
              ny = cent + m1;
            } else {
              nd = m1;
              ny = cent + m3;
            }
            var nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()]["monthNamesShort"]);
            if (nm == -1) {
              nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()]["monthNames"]);
            }
            d2.setFullYear(ny, nm, nd);
            d2.setHours(0, 0, 0, 0);
            return d2;
          } else {
            return str2;
          }
        }
      ];
      function inArray(elem, array) {
        if (array.indexOf) {
          return array.indexOf(elem);
        }
        for (var i2 = 0, length = array.length; i2 < length; i2++) {
          if (array[i2] === elem) {
            return i2;
          }
        }
        return -1;
      }
      function get_type(thing) {
        if (thing === null)
          return "[object Null]";
        return Object.prototype.toString.call(thing);
      }
      module.exports = jsDate;
    }
  });

  // node_modules/jqplot-exported/jqplot.sprintf.js
  var require_jqplot_sprintf = __commonJS({
    "node_modules/jqplot-exported/jqplot.sprintf.js"() {
      "use strict";
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      _jqplot2.default.sprintf = function() {
        function pad(str2, len, chr, leftJustify) {
          var padding = str2.length >= len ? "" : Array(1 + len - str2.length >>> 0).join(chr);
          return leftJustify ? str2 + padding : padding + str2;
        }
        function thousand_separate(value) {
          var value_str = new String(value);
          for (var i3 = 10; i3 > 0; i3--) {
            if (value_str == (value_str = value_str.replace(/^(\d+)(\d{3})/, "$1" + _jqplot2.default.sprintf.thousandsSeparator + "$2")))
              break;
          }
          return value_str;
        }
        function justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace) {
          var diff = minWidth - value.length;
          if (diff > 0) {
            var spchar = " ";
            if (htmlSpace) {
              spchar = "&nbsp;";
            }
            if (leftJustify || !zeroPad) {
              value = pad(value, minWidth, spchar, leftJustify);
            } else {
              value = value.slice(0, prefix.length) + pad("", diff, "0", true) + value.slice(prefix.length);
            }
          }
          return value;
        }
        function formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
          var number = value >>> 0;
          prefix = prefix && number && { "2": "0b", "8": "0", "16": "0x" }[base] || "";
          value = prefix + pad(number.toString(base), precision || 0, "0", false);
          return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
        }
        function formatString(value, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
          if (precision != null) {
            value = value.slice(0, precision);
          }
          return justify(value, "", leftJustify, minWidth, zeroPad, htmlSpace);
        }
        var a = arguments, i2 = 0, format = a[i2++];
        return format.replace(_jqplot2.default.sprintf.regex, function(substring, valueIndex, flags, minWidth, _, precision, type) {
          if (substring == "%%") {
            return "%";
          }
          var leftJustify = false, positivePrefix = "", zeroPad = false, prefixBaseX = false, htmlSpace = false, thousandSeparation = false;
          for (var j = 0; flags && j < flags.length; j++) {
            switch (flags.charAt(j)) {
              case " ":
                positivePrefix = " ";
                break;
              case "+":
                positivePrefix = "+";
                break;
              case "-":
                leftJustify = true;
                break;
              case "0":
                zeroPad = true;
                break;
              case "#":
                prefixBaseX = true;
                break;
              case "&":
                htmlSpace = true;
                break;
              case "'":
                thousandSeparation = true;
                break;
            }
          }
          if (!minWidth) {
            minWidth = 0;
          } else if (minWidth == "*") {
            minWidth = +a[i2++];
          } else if (minWidth.charAt(0) == "*") {
            minWidth = +a[minWidth.slice(1, -1)];
          } else {
            minWidth = +minWidth;
          }
          if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
          }
          if (!isFinite(minWidth)) {
            throw new Error("jqplot.sprintf: (minimum-)width must be finite");
          }
          if (!precision) {
            precision = "fFeE".indexOf(type) > -1 ? 6 : type == "d" ? 0 : void 0;
          } else if (precision == "*") {
            precision = +a[i2++];
          } else if (precision.charAt(0) == "*") {
            precision = +a[precision.slice(1, -1)];
          } else {
            precision = +precision;
          }
          var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i2++];
          switch (type) {
            case "s": {
              if (value == null) {
                return "";
              }
              return formatString(String(value), leftJustify, minWidth, precision, zeroPad, htmlSpace);
            }
            case "c":
              return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case "b":
              return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case "o":
              return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case "x":
              return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case "X":
              return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace).toUpperCase();
            case "u":
              return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case "i": {
              var number = parseInt(+value, 10);
              if (isNaN(number)) {
                return "";
              }
              var prefix = number < 0 ? "-" : positivePrefix;
              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))) : String(Math.abs(number));
              value = prefix + pad(number_str, precision, "0", false);
              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
            }
            case "d": {
              var number = Math.round(+value);
              if (isNaN(number)) {
                return "";
              }
              var prefix = number < 0 ? "-" : positivePrefix;
              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))) : String(Math.abs(number));
              value = prefix + pad(number_str, precision, "0", false);
              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
            }
            case "e":
            case "E":
            case "f":
            case "F":
            case "g":
            case "G": {
              var number = +value;
              if (isNaN(number)) {
                return "";
              }
              var prefix = number < 0 ? "-" : positivePrefix;
              var method = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(type.toLowerCase())];
              var textTransform = ["toString", "toUpperCase"]["eEfFgG".indexOf(type) % 2];
              var number_str = Math.abs(number)[method](precision);
              var parts = number_str.toString().split(".");
              parts[0] = thousandSeparation ? thousand_separate(parts[0]) : parts[0];
              number_str = parts.join(_jqplot2.default.sprintf.decimalMark);
              value = prefix + number_str;
              var justified = justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();
              return justified;
            }
            case "p":
            case "P": {
              var number = +value;
              if (isNaN(number)) {
                return "";
              }
              var prefix = number < 0 ? "-" : positivePrefix;
              var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);
              var sd = parts[0].indexOf(".") != -1 ? parts[0].length - 1 : String(number).length;
              var zeros = parts[1] < 0 ? -parts[1] - 1 : 0;
              if (Math.abs(number) < 1) {
                if (sd + zeros <= precision) {
                  value = prefix + Math.abs(number).toPrecision(sd);
                } else {
                  if (sd <= precision - 1) {
                    value = prefix + Math.abs(number).toExponential(sd - 1);
                  } else {
                    value = prefix + Math.abs(number).toExponential(precision - 1);
                  }
                }
              } else {
                var prec = sd <= precision ? sd : precision;
                value = prefix + Math.abs(number).toPrecision(prec);
              }
              var textTransform = ["toString", "toUpperCase"]["pP".indexOf(type) % 2];
              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();
            }
            case "n":
              return "";
            default:
              return substring;
          }
        });
      };
      _jqplot2.default.sprintf.thousandsSeparator = ",";
      _jqplot2.default.sprintf.decimalMark = ".";
      _jqplot2.default.sprintf.regex = /%%|%(\d+\$)?([-+#0&\' ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([nAscboxXuidfegpEGP])/g;
      _jqplot2.default.getSignificantFigures = function(number) {
        var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);
        var sd = parts[0].indexOf(".") != -1 ? parts[0].length - 1 : parts[0].length;
        var zeros = parts[1] < 0 ? -parts[1] - 1 : 0;
        var expn = parseInt(parts[1], 10);
        var dleft = expn + 1 > 0 ? expn + 1 : 0;
        var dright = sd <= dleft ? 0 : sd - expn - 1;
        return { significantDigits: sd, digitsLeft: dleft, digitsRight: dright, zeros, exponent: expn };
      };
      _jqplot2.default.getPrecision = function(number) {
        return _jqplot2.default.getSignificantFigures(number).digitsRight;
      };
    }
  });

  // node_modules/jqplot-exported/jqplot.effects.core.js
  var require_jqplot_effects_core = __commonJS({
    "node_modules/jqplot-exported/jqplot.effects.core.js"() {
      "use strict";
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var backCompat = _jquery2.default.uiBackCompat !== false;
      _jqplot2.default.effects = {
        effect: {}
      };
      var dataSpace = "jqplot.storage.";
      _jquery2.default.extend(_jqplot2.default.effects, {
        version: "1.9pre",
        save: function save(element, set) {
          for (var i2 = 0; i2 < set.length; i2++) {
            if (set[i2] !== null) {
              element.data(dataSpace + set[i2], element[0].style[set[i2]]);
            }
          }
        },
        restore: function restore(element, set) {
          for (var i2 = 0; i2 < set.length; i2++) {
            if (set[i2] !== null) {
              element.css(set[i2], element.data(dataSpace + set[i2]));
            }
          }
        },
        setMode: function setMode(el, mode) {
          if (mode === "toggle") {
            mode = el.is(":hidden") ? "show" : "hide";
          }
          return mode;
        },
        createWrapper: function createWrapper(element) {
          if (element.parent().is(".ui-effects-wrapper")) {
            return element.parent();
          }
          var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            "float": element.css("float")
          }, wrapper = (0, _jquery2.default)("<div></div>").addClass("ui-effects-wrapper").css({
            fontSize: "100%",
            background: "transparent",
            border: "none",
            margin: 0,
            padding: 0
          }), size = {
            width: element.width(),
            height: element.height()
          }, active = document.activeElement;
          element.wrap(wrapper);
          if (element[0] === active || _jquery2.default.contains(element[0], active)) {
            (0, _jquery2.default)(active).focus();
          }
          wrapper = element.parent();
          if (element.css("position") === "static") {
            wrapper.css({ position: "relative" });
            element.css({ position: "relative" });
          } else {
            _jquery2.default.extend(props, {
              position: element.css("position"),
              zIndex: element.css("z-index")
            });
            _jquery2.default.each(["top", "left", "bottom", "right"], function(i2, pos) {
              props[pos] = element.css(pos);
              if (isNaN(parseInt(props[pos], 10))) {
                props[pos] = "auto";
              }
            });
            element.css({
              position: "relative",
              top: 0,
              left: 0,
              right: "auto",
              bottom: "auto"
            });
          }
          element.css(size);
          return wrapper.css(props).show();
        },
        removeWrapper: function removeWrapper(element) {
          var active = document.activeElement;
          if (element.parent().is(".ui-effects-wrapper")) {
            element.parent().replaceWith(element);
            if (element[0] === active || _jquery2.default.contains(element[0], active)) {
              (0, _jquery2.default)(active).focus();
            }
          }
          return element;
        }
      });
      function _normalizeArguments(effect, options2, speed, callback) {
        if (_jquery2.default.isPlainObject(effect)) {
          return effect;
        }
        effect = { effect };
        if (options2 === void 0) {
          options2 = {};
        }
        if (_jquery2.default.isFunction(options2)) {
          callback = options2;
          speed = null;
          options2 = {};
        }
        if (_jquery2.default.type(options2) === "number" || _jquery2.default.fx.speeds[options2]) {
          callback = speed;
          speed = options2;
          options2 = {};
        }
        if (_jquery2.default.isFunction(speed)) {
          callback = speed;
          speed = null;
        }
        if (options2) {
          _jquery2.default.extend(effect, options2);
        }
        speed = speed || options2.duration;
        effect.duration = _jquery2.default.fx.off ? 0 : typeof speed === "number" ? speed : speed in _jquery2.default.fx.speeds ? _jquery2.default.fx.speeds[speed] : _jquery2.default.fx.speeds._default;
        effect.complete = callback || options2.complete;
        return effect;
      }
      _jquery2.default.fn.extend({
        jqplotEffect: function jqplotEffect(effect, options2, speed, callback) {
          var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = _jqplot2.default.effects.effect[args.effect], oldEffectMethod = !effectMethod && backCompat && _jqplot2.default.effects[args.effect];
          if (_jquery2.default.fx.off || !(effectMethod || oldEffectMethod)) {
            if (mode) {
              return this[mode](args.duration, args.complete);
            } else {
              return this.each(function() {
                if (args.complete) {
                  args.complete.call(this);
                }
              });
            }
          }
          function run(next) {
            var elem = (0, _jquery2.default)(this), complete = args.complete, mode2 = args.mode;
            function done() {
              if (_jquery2.default.isFunction(complete)) {
                complete.call(elem[0]);
              }
              if (_jquery2.default.isFunction(next)) {
                next();
              }
            }
            if (elem.is(":hidden") ? mode2 === "hide" : mode2 === "show") {
              done();
            } else {
              effectMethod.call(elem[0], args, done);
            }
          }
          if (effectMethod) {
            return queue === false ? this.each(run) : this.queue(queue || "fx", run);
          } else {
            return oldEffectMethod.call(this, {
              options: args,
              duration: args.duration,
              callback: args.complete,
              mode: args.mode
            });
          }
        }
      });
    }
  });

  // node_modules/jqplot-exported/jqplot.effects.blind.js
  var require_jqplot_effects_blind = __commonJS({
    "node_modules/jqplot-exported/jqplot.effects.blind.js"() {
      "use strict";
      var _jquery = require_jquery2();
      var _jquery2 = _interopRequireDefault(_jquery);
      var _jqplot = require_jqplot_core();
      var _jqplot2 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var rvertical = /up|down|vertical/;
      var rpositivemotion = /up|left|vertical|horizontal/;
      _jqplot2.default.effects.effect.blind = function(o, done) {
        var el = (0, _jquery2.default)(this), props = ["position", "top", "bottom", "left", "right", "height", "width"], mode = _jqplot2.default.effects.setMode(el, o.mode || "hide"), direction = o.direction || "up", vertical = rvertical.test(direction), ref = vertical ? "height" : "width", ref2 = vertical ? "top" : "left", motion = rpositivemotion.test(direction), animation = {}, show = mode === "show", wrapper, distance, top;
        if (el.parent().is(".ui-effects-wrapper")) {
          _jqplot2.default.effects.save(el.parent(), props);
        } else {
          _jqplot2.default.effects.save(el, props);
        }
        el.show();
        top = parseInt(el.css("top"), 10);
        wrapper = _jqplot2.default.effects.createWrapper(el).css({
          overflow: "hidden"
        });
        distance = vertical ? wrapper[ref]() + top : wrapper[ref]();
        animation[ref] = show ? String(distance) : "0";
        if (!motion) {
          el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "").css({ position: "absolute" });
          animation[ref2] = show ? "0" : String(distance);
        }
        if (show) {
          wrapper.css(ref, 0);
          if (!motion) {
            wrapper.css(ref2, distance);
          }
        }
        wrapper.animate(animation, {
          duration: o.duration,
          easing: o.easing,
          queue: false,
          complete: function complete() {
            if (mode === "hide") {
              el.hide();
            }
            _jqplot2.default.effects.restore(el, props);
            _jqplot2.default.effects.removeWrapper(el);
            done();
          }
        });
      };
    }
  });

  // node_modules/jqplot-exported/jqplot.css
  var require_ = __commonJS({
    "node_modules/jqplot-exported/jqplot.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/jqplot-exported/jqplot.js
  var require_jqplot = __commonJS({
    "node_modules/jqplot-exported/jqplot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _jqplot = require_jqplot_core();
      Object.keys(_jqplot).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jqplot[key];
          }
        });
      });
      var _AxisLabelRenderer = require_AxisLabelRenderer();
      Object.keys(_AxisLabelRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _AxisLabelRenderer[key];
          }
        });
      });
      var _AxisTickRenderer = require_AxisTickRenderer();
      Object.keys(_AxisTickRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _AxisTickRenderer[key];
          }
        });
      });
      var _CanvasGridRenderer = require_CanvasGridRenderer();
      Object.keys(_CanvasGridRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _CanvasGridRenderer[key];
          }
        });
      });
      var _DivTitleRenderer = require_DivTitleRenderer();
      Object.keys(_DivTitleRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DivTitleRenderer[key];
          }
        });
      });
      var _LinePattern = require_LinePattern();
      Object.keys(_LinePattern).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _LinePattern[key];
          }
        });
      });
      var _LineRenderer = require_LineRenderer();
      Object.keys(_LineRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _LineRenderer[key];
          }
        });
      });
      var _LinearAxisRenderer = require_LinearAxisRenderer();
      Object.keys(_LinearAxisRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _LinearAxisRenderer[key];
          }
        });
      });
      var _LinearTickGenerator = require_LinearTickGenerator();
      Object.keys(_LinearTickGenerator).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _LinearTickGenerator[key];
          }
        });
      });
      var _MarkerRenderer = require_MarkerRenderer();
      Object.keys(_MarkerRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _MarkerRenderer[key];
          }
        });
      });
      var _ShadowRenderer = require_ShadowRenderer();
      Object.keys(_ShadowRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _ShadowRenderer[key];
          }
        });
      });
      var _ShapeRenderer = require_ShapeRenderer();
      Object.keys(_ShapeRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _ShapeRenderer[key];
          }
        });
      });
      var _TableLegendRenderer = require_TableLegendRenderer();
      Object.keys(_TableLegendRenderer).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _TableLegendRenderer[key];
          }
        });
      });
      var _ThemeEngine = require_ThemeEngine();
      Object.keys(_ThemeEngine).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _ThemeEngine[key];
          }
        });
      });
      var _jqplot2 = require_jqplot_toImage();
      Object.keys(_jqplot2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jqplot2[key];
          }
        });
      });
      var _jsdate = require_jsdate();
      Object.keys(_jsdate).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jsdate[key];
          }
        });
      });
      var _jqplot3 = require_jqplot_sprintf();
      Object.keys(_jqplot3).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jqplot3[key];
          }
        });
      });
      var _jqplotEffects = require_jqplot_effects_core();
      Object.keys(_jqplotEffects).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jqplotEffects[key];
          }
        });
      });
      var _jqplotEffects2 = require_jqplot_effects_blind();
      Object.keys(_jqplotEffects2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jqplotEffects2[key];
          }
        });
      });
      require_();
      var _jqplot4 = _interopRequireDefault(_jqplot);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      exports.default = _jqplot4.default;
    }
  });

  // js/Visiomatic.js
  var Visiomatic_exports = {};
  __export(Visiomatic_exports, {
    catalog: () => catalog_exports,
    control: () => control_exports,
    crs: () => crs_exports,
    layer: () => layer_exports,
    util: () => util_exports,
    vector: () => vector_exports
  });

  // js/catalog/index.js
  var catalog_exports = {};
  __export(catalog_exports, {
    Catalog: () => Catalog,
    catalogs: () => catalogs_exports
  });

  // js/catalog/Catalog.js
  var import_leaflet = __toESM(require_leaflet_src());
  var Catalog = import_leaflet.Class.extend({
    options: {
      name: "A catalog",
      attribution: "",
      color: "yellow",
      properties: ["mag"],
      propertyMask: void 0,
      units: [""],
      magLim: 20,
      magIndex: 0,
      regionType: "box",
      service: "Vizier@CDS",
      className: "logo-catalog-vizier",
      serviceURL: "https://vizier.unistra.fr/viz-bin",
      catalogURL: "/",
      objectURL: "/",
      authenticate: "false",
      nmax: 1e4,
      draw: void 0
    },
    initialize: function(options2) {
      import_leaflet.Util.setOptions(this, options2);
      for (var key in this.options) {
        if (this.options[key] !== void 0) {
          this[key] = this.options[key];
        }
      }
      this.url = this.serviceURL + this.catalogURL;
      if (this.objectURL) {
        this.objURL = this.serviceURL + this.objectURL;
      }
    },
    _csvToGeoJSON: function(str2) {
      var badreg = new RegExp("#|--|objName|string|^$"), lines = str2.split("\n"), geo = { type: "FeatureCollection", features: [] };
      for (var i2 in lines) {
        var line = lines[i2];
        if (badreg.test(line) === false) {
          var feature = {
            type: "Feature",
            id: "",
            properties: {
              items: []
            },
            geometry: {
              type: "Point",
              coordinates: [0, 0]
            }
          }, geometry = feature.geometry, properties = feature.properties;
          var cell = line.split(/[,;\t]/);
          feature.id = cell[0];
          geometry.coordinates[0] = parseFloat(cell[1]);
          geometry.coordinates[1] = parseFloat(cell[2]);
          var items = cell.slice(3), item;
          for (var j in items) {
            properties.items.push(this.readProperty(items[j]));
          }
          geo.features.push(feature);
        }
      }
      return geo;
    },
    readProperty: function(item) {
      var fitem = parseFloat(item);
      return isNaN(fitem) ? "--" : fitem;
    },
    toGeoJSON: function(str2) {
      return this._csvToGeoJSON(str2);
    },
    popup: function(feature) {
      var str2 = "<div>";
      if (this.objURL) {
        str2 += 'ID: <a href="' + import_leaflet.Util.template(this.objURL, (0, import_leaflet.extend)({
          ra: feature.geometry.coordinates[0].toFixed(6),
          dec: feature.geometry.coordinates[1].toFixed(6)
        })) + '" target="_blank">' + feature.id + "</a></div>";
      } else {
        str2 += "ID: " + feature.id + "</div>";
      }
      str2 += '<TABLE style="margin:auto;"><TBODY style="vertical-align:top;text-align:left;">';
      for (var i2 in this.properties) {
        if (this.propertyMask === void 0 || this.propertyMask[i2] === true) {
          str2 += "<TR><TD>" + this.properties[i2] + ":</TD><TD>" + feature.properties.items[i2].toString() + " ";
          if (this.units[i2]) {
            str2 += this.units[i2];
          }
          str2 += "</TD></TR>";
        }
      }
      str2 += "</TBODY></TABLE>";
      return str2;
    },
    draw: function(feature, latlng) {
      var refmag = feature.properties.items[this.magIndex];
      return (0, import_leaflet.circleMarker)(latlng, {
        radius: refmag ? this.magLim + 5 - refmag : 8
      });
    },
    filter: function(feature) {
      return true;
    }
  });

  // js/catalog/catalogs.js
  var catalogs_exports = {};
  __export(catalogs_exports, {
    abell: () => abell,
    allWISE: () => allWISE,
    first: () => first,
    gaiaDR3: () => gaiaDR3,
    galexAIS: () => galexAIS,
    gleam: () => gleam,
    nvss: () => nvss,
    panstarrs1: () => panstarrs1,
    ppmXL: () => ppmXL,
    sdss: () => sdss,
    tgss: () => tgss,
    twomass: () => twomass,
    urat1: () => urat1
  });
  var import_leaflet4 = __toESM(require_leaflet_src());

  // js/vector/index.js
  var vector_exports = {};
  __export(vector_exports, {
    Ellipse: () => Ellipse,
    EllipseMarker: () => EllipseMarker,
    ellipse: () => ellipse,
    ellipseMarker: () => ellipseMarker
  });

  // js/vector/Ellipse.js
  var import_leaflet3 = __toESM(require_leaflet_src());

  // js/vector/EllipseMarker.js
  var import_leaflet2 = __toESM(require_leaflet_src());
  var EllipseMarker = import_leaflet2.Path.extend({
    CANVAS: true,
    SVG: false,
    options: {
      majAxis: 10,
      minAxis: 10,
      posAngle: 0,
      fill: true
    },
    initialize: function(latlng, options2) {
      import_leaflet2.Util.setOptions(this, options2);
      this._majAxis = this.options.majAxis;
      this._minAxis = this.options.majAxis;
      this._posAngle = this.options.posAngle;
      this._latlng = (0, import_leaflet2.latLng)(latlng);
      const deg = Math.PI / 180, cpa = Math.cos(this._posAngle * deg), spa = Math.sin(this._posAngle * deg), cpa2 = cpa * cpa, spa2 = spa * spa, a2 = this._majAxis * this._majAxis, b2 = this._minAxis * this._minAxis;
      let mx2 = a2 * cpa2 + b2 * spa2, my2 = a2 * spa2 + b2 * cpa2, mxy = (a2 - b2) * cpa * spa, c2 = mx2 * my2 - mxy * mxy;
      this._limX = Math.sqrt(mx2);
      this._limY = Math.sqrt(my2);
      if (c2 <= 0) {
        mx2 += 1;
        my2 += 1;
        c2 = mx2 * my2 - mxy * mxy;
      }
      this._cXX = my2 / c2;
      this._cYY = mx2 / c2;
      this._cXY = -2 * mxy / c2;
    },
    setLatLng: function(latlng) {
      this._latlng = (0, import_leaflet2.latLng)(latlng);
      this.redraw();
      return this.fire("move", { latlng: this._latlng });
    },
    getLatLng: function() {
      return this._latlng;
    },
    setParams: function(ellipseParams) {
      this.options.majAxis = this._majAxis = ellipseParams.majAxis;
      this.options.minAxis = this._minAxis = ellipseParams.minAxis;
      this.options.posAngle = this._posAngle = ellipseParams.posAngle;
      return this.redraw();
    },
    getParams: function() {
      const ellipseParams = {
        majAxis: this._majAxis,
        minAxis: this._minAxis,
        posAngle: this._posAngle
      };
      return ellipseParams;
    },
    _project: function() {
      this._point = this._map.latLngToLayerPoint(this._latlng);
      this._updateBounds();
    },
    _updateBounds: function() {
      const w = this._clickTolerance(), p = [this._limX + w, this._limY + w];
      this._pxBounds = new import_leaflet2.Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function() {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function() {
      this._renderer._updateEllipse(this);
    },
    _empty: function() {
      return this._majAxis && !this._renderer._bounds.intersects(this._pxBounds);
    },
    _containsPoint: function(p) {
      const dp = p.subtract(this._point), ct = this._clickTolerance(), dx = Math.abs(dp.x) - ct, dy = Math.abs(dp.y) - ct;
      return this._cXX * (dx > 0 ? dx * dx : 0) + this._cYY * (dy > 0 ? dy * dy : 0) + this._cXY * (dp.x * dp.y) <= 1;
    }
  });
  var ellipseMarker = function(latlng, options2) {
    return new EllipseMarker(latlng, options2);
  };
  import_leaflet2.Canvas.include({
    _updateEllipse: function(layer) {
      if (layer._empty()) {
        return;
      }
      var p = layer._point, ctx = this._ctx, r = layer._minAxis, s = layer._majAxis / layer._minAxis;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(layer._posAngle * Math.PI / 180);
      ctx.scale(1, s);
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2, false);
      ctx.restore();
      this._fillStroke(ctx, layer);
    }
  });
  import_leaflet2.SVG.include({
    _updateEllipse: function(layer) {
      const deg = Math.PI / 180, p = layer._point, r = layer._minAxis, r2 = layer._majAxis, dx = r * Math.cos(layer._posAngle * deg), dy = r * Math.sin(layer._posAngle * deg), arc = "a" + r + "," + r2 + " " + layer._posAngle + " 1,0 ";
      const d2 = layer._empty() ? "M0 0" : "M" + (p.x - dx) + "," + (p.y - dy) + arc + dx * 2 + "," + dy * 2 + " " + arc + -dx * 2 + "," + -dy * 2 + " ";
      this._setPath(layer, d2);
    }
  });

  // js/vector/Ellipse.js
  var Ellipse = EllipseMarker.extend({
    options: {
      fill: true
    },
    initialize: function(latlng, options2) {
      import_leaflet3.Util.setOptions(this, options2);
      const deg = Math.PI / 180, cpa = Math.cos(this.options.posAngle * deg), spa = Math.sin(this.options.posAngle * deg), cpa2 = cpa * cpa, spa2 = spa * spa, a2 = this.options.majAxis * this.options.majAxis, b2 = this.options.minAxis * this.options.minAxis;
      this._latlng = (0, import_leaflet3.latLng)(latlng);
      this._mLat2 = a2 * cpa2 + b2 * spa2;
      this._mLng2 = a2 * spa2 + b2 * cpa2;
      this._mLatLng = (a2 - b2) * cpa * spa;
    },
    getBounds: function() {
      const half = [this._limX, this._limY];
      return new import_leaflet3.LatLngBounds(
        this._map.layerPointToLatLng(this._point.subtract(half)),
        this._map.layerPointToLatLng(this._point.add(half))
      );
    },
    _project: function() {
      const map2 = this._map, crs = map2.options.crs;
      this._point = map2.latLngToLayerPoint(this._latlng);
      if (!this._majAxis1) {
        const lng = this._latlng.lng, lat = this._latlng.lat, deg = Math.PI / 180, clat = Math.cos(lat * deg), dl = lat < 90 ? 1e-3 : -1e-3, point7 = crs.project(this._latlng), dpointdlat = crs.project((0, import_leaflet3.latLng)(lat + dl, lng)).subtract(point7), dpointdlng = crs.project(
          (0, import_leaflet3.latLng)(
            lat,
            lng + dl * 1 / (clat > dl ? clat : dl)
          )
        ).subtract(point7), c11 = dpointdlat.x / dl, c12 = dpointdlng.x / dl, c21 = dpointdlat.y / dl, c22 = dpointdlng.y / dl;
        let mx2 = c11 * c11 * this._mLat2 + c12 * c12 * this._mLng2 + 2 * c11 * c12 * this._mLatLng, my2 = c21 * c21 * this._mLat2 + c22 * c22 * this._mLng2 + 2 * c21 * c22 * this._mLatLng, mxy = c11 * c21 * this._mLat2 + c12 * c22 * this._mLng2 + (c11 * c22 + c12 * c21) * this._mLatLng, a1 = 0.5 * (mx2 + my2), a2 = Math.sqrt(0.25 * (mx2 - my2) * (mx2 - my2) + mxy * mxy), a3 = mx2 * my2 - mxy * mxy;
        this._majAxis = this._majAxis1 = Math.sqrt(a1 + a2);
        this._minAxis = this._minAxis1 = a1 > a2 ? Math.sqrt(a1 - a2) : 0;
        this._posAngle = 0.5 * Math.atan2(2 * mxy, mx2 - my2) / deg;
        this._limX = this._limX1 = Math.sqrt(mx2);
        this._limY = this._limY1 = Math.sqrt(my2);
        if (a3 <= 0) {
          mx2 += 1;
          my2 += 1;
          a3 = mx2 * my2 - mxy * mxy;
        }
        this._cXX1 = my2 / a3;
        this._cYY1 = mx2 / a3;
        this._cXY1 = -2 * mxy / a3;
      }
      const scale2 = crs.scale(map2._zoom), invscale2 = 1 / (scale2 * scale2);
      this._majAxis = this._majAxis1 * scale2;
      this._minAxis = this._minAxis1 * scale2;
      this._limX = this._limX1 * scale2;
      this._limY = this._limY1 * scale2;
      this._cXX = this._cXX1 * invscale2;
      this._cYY = this._cYY1 * invscale2;
      this._cXY = this._cXY1 * invscale2;
      this._updateBounds();
    }
  });
  var ellipse = function(latlng, options2) {
    return new Ellipse(latlng, options2);
  };

  // js/catalog/catalogs.js
  var abell = new Catalog({
    service: "Vizier@CDS",
    name: "Abell clusters",
    className: "logo-catalog-vizier",
    attribution: "Rich Clusters of Galaxies (Abell et al. 1989) ",
    color: "orange",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VII/110A&-out=ACO,_RAJ2000,_DEJ2000,m10,Rich,Dclass&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=m10",
    properties: ["m<sub>10</sub>", "Richness", "D<sub>class</sub>"],
    units: ["", "", ""],
    objectURL: "/VizieR-5?-source=VII/110A&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var allWISE = new Catalog({
    service: "Vizier@CDS",
    name: "AllWISE",
    attribution: "AllWISE Data Release (Cutri et al. 2013)",
    color: "red",
    magLim: 18,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/328/allwise&-out=AllWISE,_RAJ2000,_DEJ2000,W1mag,W2mag,W3mag,W4mag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=W1mag",
    properties: [
      "W1<sub>mag</sub> (3.4\xB5m)",
      "W2<sub>mag</sub> (4.6\xB5m)",
      "W3<sub>mag</sub> (12\xB5m)",
      "W4<sub>mag</sub> (22\xB5m)"
    ],
    units: ["", "", "", ""],
    objectURL: "/VizieR-5?-source=II/328/allwise&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var first = new Catalog({
    service: "Vizier@CDS",
    name: "FIRST",
    className: "logo-catalog-vizier",
    attribution: "The FIRST Survey Catalog (Helfand et al. 2015)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/92/first14&-out=FIRST,_RAJ2000,_DEJ2000,Fpeak,fMaj,fMin,fPA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Fpeak",
    properties: ["F<sub>peak</sub>(1.4GHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=VIII/92/first14&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var gaiaDR3 = new Catalog({
    service: "Vizier@CDS",
    name: "Gaia DR3",
    className: "logo-catalog-vizier",
    attribution: "Third Gaia Data Release (2022)",
    color: "green",
    magLim: 21,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/355/gaiadr3&-out=Source,RA_ICRS,DE_ICRS,Gmag,BPmag,RPmag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Gmag",
    properties: [
      "G",
      "B<sub>P</sub>",
      "R<sub>P</sub>",
      "&#956;<sub>&#593;</sub> cos &#948;",
      "&#956;<sub>&#948;</sub>"
    ],
    units: ["", "", "", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/355/gaiadr3&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var galexAIS = new Catalog({
    service: "Vizier@CDS",
    name: "GALEX AIS",
    className: "logo-catalog-vizier",
    attribution: "GALEX catalogs of UV sources: All-sky Imaging Survey (Bianchi et al. 2011)",
    color: "magenta",
    magLim: 21,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/312/ais&-out=objid,_RAJ2000,_DEJ2000,FUV,NUV&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=FUV",
    properties: ["FUV<sub>AB</sub>", "NUV<sub>AB</sub>"],
    units: ["", ""],
    objectURL: "/VizieR-5?-source=II/312/ais&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var gleam = new Catalog({
    service: "Vizier@CDS",
    name: "GLEAM",
    className: "logo-catalog-vizier",
    attribution: "GaLactic and Extragalactic All-sky Murchison Wide Field Array (GLEAM) low-frequency extragalactic catalogue (Hurley-Walker et al. 2017)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/100/gleamegc&-out=GLEAM,RAJ2000,DEJ2000,Fintwide,awide,bwide,pawide&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Fintwide",
    properties: ["F<sub>int</sub>(170-231MHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["Jy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=-source=VIII/100/gleamegc&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 3600,
        minAxis: feature.properties.items[2] / 3600,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var nvss = new Catalog({
    service: "Vizier@CDS",
    name: "NVSS",
    className: "logo-catalog-vizier",
    attribution: "1.4GHz NRAO VLA Sky Survey (NVSS) (Condon et al. 1998)",
    color: "magenta",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/65/NVSS&-out=NVSS,_RAJ2000,_DEJ2000,S1.4,MajAxis,MinAxis,PA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-S1.4",
    properties: ["S<sub>1.4GHz</sub>", "Major axis", "Minor axis", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=VIII/65/NVSS&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var panstarrs1 = new Catalog({
    service: "Vizier@CDS",
    name: "PanSTARRS 1",
    className: "logo-catalog-vizier",
    attribution: "Pan-STARRS release 1 (PS1) Survey (Chambers et al. 2016)",
    color: "yellow",
    magLim: 24,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/349&-out=objID,RAJ2000,DEJ2000,gKmag,rKmag,iKmag,zKmag,yKmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=rmag",
    properties: ["g", "r", "i", "z", "y"],
    units: ["", "", "", "", ""],
    objectURL: "/VizieR-5?-source=II/349/ps1&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var ppmXL = new Catalog({
    service: "Vizier@CDS",
    name: "PPMXL",
    className: "logo-catalog-vizier",
    attribution: "PPM-Extended, positions and proper motions (Roeser et al. 2008)",
    color: "green",
    magLim: 20,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/317&-out=PPMXL,RAJ2000,DEJ2000,Jmag,Hmag,Kmag,b1mag,b2mag,r1mag,r2mag,imag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Jmag",
    properties: [
      "J",
      "H",
      "K",
      "b<sub>1</sub>",
      "b<sub>2</sub>",
      "r<sub>1</sub>",
      "r<sub>2</sub>",
      "i",
      "&#956;<sub>&#593;</sub> cos &#948;",
      "&#956;<sub>&#948;</sub>"
    ],
    units: ["", "", "", "", "", "", "", "", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/317&-c={ra},{dec},eq=J2000&-c.rs=0.01"
  });
  var sdss = new Catalog({
    service: "Vizier@CDS",
    name: "SDSS release 12",
    className: "logo-catalog-vizier",
    attribution: "SDSS Photometric Catalog, Release 12 (Alam et al. 2015)",
    color: "yellow",
    magLim: 25,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=V/147&-out=SDSS12,RA_ICRS,DE_ICRS,umag,gmag,rmag,imag,zmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=rmag",
    properties: ["u", "g", "r", "i", "z"],
    units: ["", "", "", "", ""],
    objectURL: "/VizieR-5?-source=V/147/sdss12&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var tgss = new Catalog({
    service: "Vizier@CDS",
    name: "TGSS",
    className: "logo-catalog-vizier",
    attribution: "The GMRT 150 MHz all-sky radio survey. TGSS ADR1 (Intema et al. 2017)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=J/A%2bA/598/A78/table3&-out=TGSSADR,RAJ2000,DEJ2000,Stotal,Maj,Min,PA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Stotal",
    properties: ["F<sub>peak</sub>(150MHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-3?-source=-source=J/A%2bA/598/A78/table3&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var twomass = new Catalog({
    service: "Vizier@CDS",
    name: "2MASS",
    className: "logo-catalog-vizier",
    attribution: "2MASS All-Sky Catalog of Point Sources (Cutri et al. 2003)",
    color: "red",
    magLim: 17,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/246&-out=2MASS,RAJ2000,DEJ2000,Jmag,Hmag,Kmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Jmag",
    properties: ["J", "H", "K"],
    units: ["", "", ""],
    objectURL: "/VizieR-5?-source=II/246&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var urat1 = new Catalog({
    service: "Vizier@CDS",
    name: "URAT1",
    className: "logo-catalog-vizier",
    attribution: "The first U.S. Naval Observatory Astrometric Robotic Telescope Catalog (Zacharias et al. 2015)",
    color: "yellow",
    magLim: 17,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/329&-out=URAT1,RAJ2000,DEJ2000,f.mag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=f.mag",
    properties: ["f<sub>mag</sub>", "&#956;<sub>&#593;</sub> cos &#948;", "&#956;<sub>&#948;</sub>"],
    units: ["", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/329&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });

  // js/control/index.js
  var control_exports = {};
  __export(control_exports, {
    CatalogUI: () => CatalogUI,
    ChannelUI: () => ChannelUI,
    Coords: () => Coords,
    DocUI: () => DocUI,
    ExtraMap: () => ExtraMap,
    FullScreen: () => FullScreen,
    ImageUI: () => ImageUI,
    ProfileUI: () => ProfileUI,
    RegionUI: () => RegionUI,
    Reticle: () => Reticle,
    Scale: () => Scale,
    Sidebar: () => Sidebar,
    SnapshotUI: () => SnapshotUI,
    catalogUI: () => catalogUI,
    channelUI: () => channelUI,
    coords: () => coords,
    docUI: () => docUI,
    extraMap: () => extraMap,
    fullScreen: () => fullScreen,
    imageUI: () => imageUI,
    profileUI: () => profileUI,
    regionUI: () => regionUI,
    reticle: () => reticle,
    scale: () => scale,
    sidebar: () => sidebar,
    snapshotUI: () => snapshotUI
  });

  // js/control/logo.js
  var import_leaflet5 = __toESM(require_leaflet_src());
  import_leaflet5.Control.Attribution.include({
    _update: function() {
      if (!this._map) {
        return;
      }
      const attribs = [];
      for (var i2 in this._attributions) {
        if (this._attributions[i2]) {
          attribs.push(i2);
        }
      }
      const prefixAndAttribs = [];
      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }
      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(", "));
      }
      this._container.innerHTML = prefixAndAttribs.join(" &#169; ");
    }
  });
  import_leaflet5.Map.addInitHook(function() {
    if (this.options.visiomaticLogo !== false && this.options.attributionControl) {
      this.attributionControl.setPrefix(
        '<a id="logo-visiomatic" class="leaflet-control-attribution-logo"href="http://visiomatic.org">&nbsp;</a>'
      );
    }
  });

  // js/control/CatalogUI.js
  var import_leaflet11 = __toESM(require_leaflet_src());

  // js/util/index.js
  var util_exports = {};
  __export(util_exports, {
    RGB: () => RGB,
    VUtil: () => VUtil,
    rgb: () => rgb
  });

  // js/util/RGB.js
  var import_leaflet6 = __toESM(require_leaflet_src());
  var RGB = function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  };
  RGB.prototype = {
    clone: function() {
      return new RGB(this.r, this.g, this.b);
    },
    toStr: function() {
      let r = Math.round(this.r * 255), g = Math.round(this.g * 255), b = Math.round(this.b * 255);
      if (r < 0) {
        r = 0;
      } else if (r > 255) {
        r = 255;
      }
      if (g < 0) {
        g = 0;
      } else if (g > 255) {
        g = 255;
      }
      if (b < 0) {
        b = 0;
      } else if (b > 255) {
        b = 255;
      }
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    isOn: function() {
      return this.r > 0 || this.g > 0 || this.b > 0 ? true : false;
    }
  };
  var rgb = function(r, g, b) {
    if (r instanceof RGB) {
      return r;
    }
    if (typeof r === "string") {
      const bigint = parseInt("0x" + r.slice(1), 16);
      return new RGB(
        (bigint >> 16 & 255) / 255,
        (bigint >> 8 & 255) / 255,
        (bigint & 255) / 255
      );
    }
    if (import_leaflet6.Util.isArray(r)) {
      return new RGB(r[0], r[1], r[2]);
    }
    if (r === void 0 || r === null) {
      return r;
    }
    return new RGB(r, g, b);
  };

  // js/util/VUtil.js
  var import_leaflet7 = __toESM(require_leaflet_src());
  var VUtil = {
    REG_PDEC: "(\\d+\\.\\d*)",
    REG_FLOAT: "([-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)",
    requestURL: function(url, purpose, action, context, timeout) {
      var httpRequest;
      if (window.XMLHttpRequest) {
        httpRequest = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        try {
          httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
          try {
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e2) {
          }
        }
      }
      if (!httpRequest) {
        alert("Giving up: Cannot create an XMLHTTP instance for " + purpose);
        return false;
      }
      if (timeout) {
        httpRequest.timeout = timeout * 1e3;
        httpRequest.ontimeout = function() {
          alert("Time out while " + purpose);
        };
      }
      httpRequest.open("GET", url);
      if (context && context.options.credentials) {
        httpRequest.withCredentials = true;
      }
      if (context && context.options.authenticate === "csrftoken") {
        httpRequest.setRequestHeader("X-CSRFToken", this.getCookie("csrftoken"));
      }
      if (action) {
        httpRequest.onreadystatechange = function() {
          action(context, httpRequest);
        };
      }
      httpRequest.send();
    },
    parseURL: function(url) {
      const dict = {};
      url.replace(
        new RegExp("([^?=&]+)(=([^&]*))?", "g"),
        function($0, $1, $2, $3) {
          dict[$1] = $3;
        }
      );
      return dict;
    },
    updateURL: function(url, keyword, value) {
      const re = new RegExp("([?&])" + keyword + "=.*?(&|$)", "i"), separator = url.indexOf("?") !== -1 ? "&" : "?";
      return url.match(re) ? url.replace(re, "$1" + keyword + "=" + value + "$2") : url + separator + keyword + "=" + value;
    },
    checkDomain: function(url) {
      if (url.indexOf("//") === 0) {
        url = location.protocol + url;
      }
      return url.toLowerCase().replace(/([a-z])?:\/\//, "$1").split("/")[0];
    },
    isExternal: function(url) {
      return (url.indexOf(":") > -1 || url.indexOf("//") > -1) && this.checkDomain(location.href) !== this.checkDomain(url);
    },
    getCookie: function(cname) {
      const name = cname + "=", ca = document.cookie.split(";");
      for (var i2 = 0; i2 < ca.length; i2++) {
        var c2 = ca[i2];
        while (c2.charAt(0) === " ") {
          c2 = c2.substring(1);
        }
        if (c2.indexOf(name) === 0) {
          return c2.substring(name.length, c2.length);
        }
      }
      return "";
    },
    copyToClipboard: function(text) {
      if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
        const textarea = document.createElement("textarea");
        textarea.textContent = text;
        textarea.style.position = "fixed";
        document.body.appendChild(textarea);
        textarea.select();
        try {
          return document.execCommand("copy");
        } catch (ex) {
          console.warn("Copy to clipboard failed.", ex);
          return false;
        } finally {
          document.body.removeChild(textarea);
        }
      }
    },
    flashElement: function(elem) {
      import_leaflet7.DomUtil.addClass(elem, "leaflet-control-flash");
      setTimeout(function() {
        import_leaflet7.DomUtil.removeClass(elem, "leaflet-control-flash");
      }, 400);
    },
    readFITSKey: function(keyword, str2) {
      const key = keyword.trim().toUpperCase().substr(0, 8), nspace = 8 - key.length, keyreg = new RegExp(key + (nspace > 0 ? "\\ {" + nspace.toString() + "}" : "") + "=\\ *(?:'((?:\\ *[^'\\ ]+)*)\\ *'|([-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?))"), match = keyreg.exec(str2);
      if (!match) {
        return null;
      } else if (match[1]) {
        return match[1];
      } else {
        return match[2];
      }
    }
  };

  // js/control/UI.js
  var import_jquery = __toESM(require_jquery());
  var import_spectrum_colorpicker = __toESM(require_spectrum());
  var import_leaflet10 = __toESM(require_leaflet_src());

  // js/control/widget/FlipSwitch.js
  var import_leaflet8 = __toESM(require_leaflet_src());
  var FlipSwitch = import_leaflet8.Evented.extend({
    options: {
      title: "Click to switch",
      checked: false,
      className: "leaflet-flipswitch"
    },
    initialize: function(parent, options2) {
      options2 = import_leaflet8.Util.setOptions(this, options2);
      const _this = this, className = options2.className, button = import_leaflet8.DomUtil.create("div", className, parent), input = this._input = L.DomUtil.create("input", className, button), label = import_leaflet8.DomUtil.create("label", className, button);
      input.type = "checkbox";
      input.name = options2.className;
      input.checked = options2.checked;
      label.htmlFor = input.id = options2.id;
      if (options2.title) {
        label.title = options2.title;
      }
      import_leaflet8.DomUtil.create("span", className + "-inner", label);
      import_leaflet8.DomUtil.create("span", className + "-button", label);
      import_leaflet8.DomEvent.disableClickPropagation(button).disableScrollPropagation(button);
      import_leaflet8.DomEvent.on(input, "change", function() {
        this.fire("change");
      }, this);
      return button;
    },
    value: function(val) {
      if (val === void 0) {
        return this._input.checked;
      } else {
        this._input.checked = val ? true : false;
        return this;
      }
    }
  });

  // js/control/widget/Spinbox.js
  var import_leaflet9 = __toESM(require_leaflet_src());
  var Spinbox = import_leaflet9.Evented.extend({
    options: {
      title: "Enter value",
      dmin: void 0,
      dmax: void 0,
      step: void 0,
      initValue: void 0,
      repButton: true,
      clickEvent: "click",
      instantUpdate: false,
      className: "leaflet-spinbox"
    },
    initialize: function(parent, options2) {
      options2 = import_leaflet9.Util.setOptions(this, options2);
      const _this = this, drag = this._drag = {
        startEvent: "touchstart mousedown",
        stopEvent: "touchend mouseup mouseout touchcancel",
        move: false,
        start: false,
        end: false,
        pos: false,
        target: false,
        delta: false,
        tmp: false,
        cnt: 0,
        step: options2.step,
        prec: this._prec(options2.step)
      }, wrap = this._wrap = import_leaflet9.DomUtil.create(
        "div",
        options2.className,
        parent
      ), input = this._input = import_leaflet9.DomUtil.create(
        "input",
        options2.className + "-input",
        wrap
      ), down = this._down = import_leaflet9.DomUtil.create(
        "div",
        options2.className + "-down",
        wrap
      ), up = this._up = import_leaflet9.DomUtil.create(
        "div",
        options2.className + "-up",
        wrap
      );
      input.type = "number";
      input.step = 0.1;
      import_leaflet9.DomEvent.disableClickPropagation(wrap).disableScrollPropagation(wrap);
      if (input.disabled === true) {
        options2.disabled = true;
      }
      if (options2.dmin === void 0) {
        options2.dmin = -Number.MAX_VALUE;
      }
      if (options2.dmax === void 0) {
        options2.dmax = Number.MAX_VALUE;
      }
      if (options2.step === void 0) {
        options2.step = 1;
      }
      if (options2.initValue === void 0) {
        options2.initValue = (options2.dmin + options2.dmax) / 2;
      }
      this.value(options2.initValue);
      input.title = options2.title;
      down.title = "Decrease number by " + options2.step;
      up.title = "Increase number by " + options2.step;
      import_leaflet9.DomEvent.on(this._input, "change", function() {
        this.fire("change");
      }, this);
      if (options2.repButton === false) {
        import_leaflet9.DomEvent.on(down, options2.clickEvent, function(e) {
          e.preventDefault();
          this._offset(e.currentTarget, -1);
        }, this);
        import_leaflet9.DomEvent.on(up, options2.clickEvent, function(e) {
          e.preventDefault();
          this._offset(e.currentTarget, 1);
        }, this);
      } else {
        import_leaflet9.DomEvent.on(down, drag.startEvent, function(e) {
          input.blur();
          drag.move = true;
          drag.cnt = 0;
          drag.step = options2.step;
          drag.prec = this._prec(drag.step);
          drag.delta = -1;
          this._offset(e.currentTarget, -1);
          if (!this.runButton) {
            drag.target = e.currentTarget;
            this.runButton = setTimeout(function() {
              _this._sboxRun();
            }, 500);
          }
        }, this);
        import_leaflet9.DomEvent.on(up, drag.startEvent, function(e) {
          input.blur();
          drag.move = true;
          drag.cnt = 0;
          drag.step = options2.step;
          drag.prec = this._prec(drag.step);
          drag.delta = 1;
          this._offset(e.currentTarget, 1);
          if (!this.runButton) {
            drag.target = e.currentTarget;
            this.runButton = setTimeout(function() {
              _this._sboxRun();
            }, 500);
          }
        }, this);
        import_leaflet9.DomEvent.on(down, drag.stopEvent, function(e) {
          if (drag.move) {
            e.preventDefault();
            clearTimeout(this.runButton);
            this.runButton = false;
            drag.move = false;
            if (options2.instantUpdate === false) {
              this.fire("change");
            }
          }
        }, this);
        import_leaflet9.DomEvent.on(up, drag.stopEvent, function(e) {
          if (drag.move) {
            e.preventDefault();
            clearTimeout(this.runButton);
            this.runButton = false;
            drag.move = false;
            if (options2.instantUpdate === false) {
              this.fire("change");
            }
          }
        }, this);
      }
      if (options2.disabled) {
        this.disable();
      }
      return wrap;
    },
    value: function(val) {
      if (val === void 0) {
        return parseFloat(this._input.value);
      } else {
        this._input.value = val;
        return this;
      }
    },
    step: function(val) {
      if (val === void 0) {
        return this.options.step;
      } else {
        this.options.step = val;
        return this;
      }
    },
    disable: function() {
      const cname = "disabled";
      this._input.disabled = true;
      this._input.blur();
      import_leaflet9.DomUtil.addClass(this._wrap, cname);
      import_leaflet9.DomUtil.addClass(this._down, cname);
      import_leaflet9.DomUtil.addClass(this._up, cname);
      this.options.disabled = true;
    },
    enable: function() {
      const cname = "disabled";
      this._input.disabled = false;
      import_leaflet9.DomUtil.removeClass(this._wrap, cname);
      import_leaflet9.DomUtil.removeClass(this._down, cname);
      import_leaflet9.DomUtil.removeClass(this._up, cname);
      this.options.disabled = false;
    },
    _sboxRun: function() {
      const _this = this, options2 = this.options, drag = this._drag;
      let timer = 150;
      if (drag.cnt === 20) {
        timer = 50;
        drag.step = 10 * options2.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 40) {
        timer = 10;
        drag.step = 100 * options2.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 60) {
        drag.step = 1e3 * options2.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 80) {
        drag.step = 1e4 * options2.step;
        drag.prec = this._prec(drag.step);
      }
      drag.didRun = true;
      this._offset(this, drag.delta);
      drag.cnt++;
      this.runButton = setTimeout(function() {
        _this._sboxRun();
      }, timer);
    },
    _prec: function(step) {
      const dprec = -0.4342944 * Math.log(step);
      return dprec > 0 ? Math.ceil(dprec) : 0;
    },
    _offset: function(obj, direction) {
      const options2 = this.options, input = this._input, drag = this._drag;
      if (!this.disabled) {
        if (direction < 1) {
          var tmp = (parseFloat(input.value) - drag.step).toFixed(
            drag.prec
          );
          if (tmp >= options2.dmin) {
            input.value = tmp;
            if (options2.instantUpdate === true) {
              this.fire("change");
            }
          }
        } else {
          var tmp = (parseFloat(input.value) + drag.step).toFixed(
            drag.prec
          );
          if (tmp <= options2.dmax) {
            input.value = tmp;
            if (options2.instantUpdate === true) {
              this.fire("change");
            }
          }
        }
      }
    }
  });

  // js/control/UI.js
  window.$ = window.jQuery = import_jquery.default;
  var UI = import_leaflet10.Control.extend({
    options: {
      title: "a control related to VisiOmatic",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(baseLayers, options2) {
      import_leaflet10.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-image";
      this._layers = baseLayers;
    },
    addTo: function(dest) {
      if (dest._sidebar) {
        this._sidebar = dest;
        this._map = dest._map;
        this._dialog = import_leaflet10.DomUtil.create("div", this._className + "-dialog");
        dest.addTab(
          this._id,
          this._className,
          this.options.title,
          this._dialog,
          this._sideClass
        );
        this._map.on("layeradd", this._checkVisiomatic, this);
        return dest;
      } else {
        return import_leaflet10.Control.prototype.addTo.call(this, dest);
      }
    },
    onAdd: function(map2) {
      const className = this._className, id = this._id, container = this._container = import_leaflet10.DomUtil.create(
        "div",
        className + " leaflet-bar"
      );
      container.setAttribute("aria-haspopup", true);
      import_leaflet10.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
      this._dialog = import_leaflet10.DomUtil.create("div", className + "-dialog", container);
      if (this.options.collapsed) {
        if (!import_leaflet10.Browser.android) {
          import_leaflet10.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
        }
        const toggle = this._toggle = import_leaflet10.DomUtil.create(
          "a",
          className + "-toggle leaflet-bar",
          container
        );
        toggle.href = "#";
        toggle.id = id + "-toggle";
        toggle.title = this.options.title;
        if (import_leaflet10.Browser.touch) {
          import_leaflet10.DomEvent.on(toggle, "click", import_leaflet10.DomEvent.stop, this).on(toggle, "click", this._expand, this);
        } else {
          import_leaflet10.DomEvent.on(toggle, "focus", this._expand, this);
        }
        this._map.on("click", this._collapse, this);
      } else {
        this._expand();
      }
      this._map.on("layeradd", this._checkVisiomatic, this);
      return this._container;
    },
    _checkVisiomatic: function(e) {
      const layer = e.layer;
      if (!layer || !layer.visioDefault) {
        return;
      }
      this._layer = layer;
      if (this._reloadFlag) {
        layer.once("load", this._resetDialog, this);
      } else {
        this._initDialog();
        this._reloadFlag = true;
      }
    },
    _initDialog: function() {
    },
    _resetDialog: function() {
      this._dialog.innerHTML = "";
      this._initDialog();
    },
    _addDialogBox: function(id) {
      const box = import_leaflet10.DomUtil.create(
        "div",
        this._className + "-box",
        this._dialog
      );
      if (id) {
        box.id = id;
      }
      return box;
    },
    _addDialogLine: function(label, dialogBox) {
      const line = import_leaflet10.DomUtil.create(
        "div",
        this._className + "-line",
        dialogBox
      ), text = import_leaflet10.DomUtil.create("div", this._className + "-label", line);
      text.innerHTML = label;
      return line;
    },
    _addDialogElement: function(line) {
      return import_leaflet10.DomUtil.create("div", this._className + "-element", line);
    },
    _expand: function() {
      import_leaflet10.DomUtil.addClass(this._container, this._className + "-expanded");
    },
    _collapse: function() {
      this._container.className = this._container.className.replace(
        " " + this._className + "-expanded",
        ""
      );
    },
    getActiveBaseLayer: function() {
      return this._activeBaseLayer;
    },
    _findActiveBaseLayer: function() {
      const layers = this._layers;
      this._prelayer = void 0;
      for (var l in layers) {
        var layer = layers[l];
        if (!layer.overlay) {
          if (!layer._map) {
            this._prelayer = layer;
          } else if (this._map.hasLayer(layer) && layer.visioDefault) {
            return layer;
          }
        }
      }
      return void 0;
    },
    _addButton: function(className, parent, subClassName = void 0, title = void 0, fn = void 0) {
      const button = import_leaflet10.DomUtil.create("a", className, parent);
      button.target = "_blank";
      if (subClassName) {
        button.id = className + "-" + subClassName;
      }
      if (fn) {
        import_leaflet10.DomEvent.on(button, "click touch", fn, this);
      }
      if (title) {
        button.title = title;
      }
      return button;
    },
    _addRadioButton: function(className, parent, value, checked, title = void 0, fn = void 0) {
      const button = import_leaflet10.DomUtil.create("input", className, parent);
      button.type = "radio";
      button.name = className;
      button.value = value;
      button.checked = checked;
      if (fn) {
        import_leaflet10.DomEvent.on(button, "click touch", function() {
          fn(value);
        }, this);
      }
      const label = import_leaflet10.DomUtil.create("label", className, parent);
      label.htmlFor = button.id = className + "-" + value;
      if (title) {
        label.title = title;
      }
      return button;
    },
    _addSelectMenu: function(className, parent, items, disabled = void 0, selected = void 0, title = void 0, fn = void 0) {
      const div = import_leaflet10.DomUtil.create("div", className, parent), select = import_leaflet10.DomUtil.create("select", className, div), choose = document.createElement("option"), opt = select.opt = [];
      choose.text = "choose";
      choose.disabled = true;
      if (!selected || selected < 0) {
        choose.selected = true;
      }
      select.add(choose, null);
      for (var i2 in items) {
        var index = parseInt(i2, 10);
        opt[index] = document.createElement("option");
        opt[index].text = items[index];
        opt[index].value = index;
        if (disabled && disabled[index]) {
          opt[index].disabled = true;
        } else if (index === selected) {
          opt[index].selected = true;
        }
        select.add(opt[index], null);
      }
      if (this._container && !import_leaflet10.Browser.android && this.options.collapsed) {
        import_leaflet10.DomEvent.on(select, "mousedown", function() {
          import_leaflet10.DomEvent.off(
            this._container,
            "mouseout",
            this._collapse,
            this
          );
          this.collapsedOff = true;
        }, this);
        import_leaflet10.DomEvent.on(this._container, "mouseover", function() {
          if (this.collapsedOff) {
            import_leaflet10.DomEvent.on(
              this._container,
              "mouseout",
              this._collapse,
              this
            );
            this.collapsedOff = false;
          }
        }, this);
      }
      if (fn) {
        import_leaflet10.DomEvent.on(select, "change keyup", fn, this);
      }
      if (title) {
        div.title = title;
      }
      return select;
    },
    _addColorPicker: function(className, parent, subClassName, defaultColor, storageKey, title = void 0, fn = void 0) {
      const _this = this, colpick = import_leaflet10.DomUtil.create("input", className, parent);
      colpick.type = "color";
      colpick.value = defaultColor;
      colpick.id = className + "-" + subClassName;
      $(document).ready(function() {
        $(colpick).spectrum({
          showInput: true,
          appendTo: "#" + _this._id,
          showPaletteOnly: true,
          togglePaletteOnly: true,
          localStorageKey: storageKey,
          change: function(color) {
            colpick.value = color.toHexString();
          }
        }).on("show.spectrum", function() {
          if (_this._container) {
            import_leaflet10.DomEvent.off(_this._container, "mouseout", _this._collapse);
          }
        });
        if (fn) {
          $(colpick).on("change", fn);
        }
        if (title) {
          $("#" + colpick.id + "+.sp-replacer").prop("title", title);
        }
      });
      return colpick;
    },
    _addSwitchInput: function(layer, attr, box, label, title = void 0, checked) {
      const line = this._addDialogLine(label, box), elem = this._addDialogElement(line), flip = elem.flip = new FlipSwitch(elem, {
        checked,
        title
      });
      flip.on("change", function() {
        this._onInputChange(layer, attr, flip.value());
      }, this);
      return elem;
    },
    _addNumericalInput: function(layer, attr, box, label, title = void 0, initValue, step, min = void 0, max = void 0, fn = void 0) {
      const line = this._addDialogLine(label, box), elem = this._addDialogElement(line), spinbox = elem.spinbox = new Spinbox(elem, {
        step,
        dmin: min,
        dmax: max,
        initValue,
        title
      });
      spinbox.on("change", function() {
        VUtil.flashElement(spinbox._input);
        this._onInputChange(layer, attr, spinbox.value(), fn);
      }, this);
      return elem;
    },
    _updateInput: function(elem, value) {
      if (elem.spinbox) {
        elem.spinbox.value(value);
      } else if (elem.flip) {
        elem.flip.value(value);
      }
    },
    _spinboxStep: function(min, max) {
      const step = parseFloat((Math.abs(max === min ? max : max - min) * 1e-3).toPrecision(1));
      return step === 0 ? 1 : step;
    },
    _onInputChange: function(layer, attr, value, fn = void 0) {
      const attrarr = attr.split(/\[|\]/);
      if (attrarr[1]) {
        layer.visio[attrarr[0]][parseInt(attrarr[1], 10)] = value;
      } else {
        layer.visio[attrarr[0]] = value;
      }
      if (fn) {
        fn(layer);
      }
      layer.redraw();
    },
    _updateLayerList: function() {
      if (!this._dialog) {
        return this;
      }
      if (this._layerList) {
        import_leaflet10.DomUtil.empty(this._layerList);
      } else {
        this._layerList = import_leaflet10.DomUtil.create(
          "div",
          "visiomatic-control-layerlist",
          this._dialog
        );
      }
      for (var i2 in this._layers) {
        this._addLayerItem(this._layers[i2]);
      }
      return this;
    },
    _addLayerItem: function(obj) {
      const _this = this, layerItem = import_leaflet10.DomUtil.create("div", "visiomatic-control-layer"), inputdiv = import_leaflet10.DomUtil.create(
        "div",
        "visiomatic-control-layerswitch",
        layerItem
      );
      if (obj.layer.notReady) {
        import_leaflet10.DomUtil.create("div", "visiomatic-control-activity", inputdiv);
      } else {
        const checked = this._map.hasLayer(obj.layer), newInput = document.createElement("input");
        newInput.type = "checkbox";
        newInput.className = "visiomatic-control-selector";
        newInput.defaultChecked = checked;
        newInput.layerId = import_leaflet10.Util.stamp(obj.layer);
        import_leaflet10.DomEvent.on(newInput, "click", function() {
          const inputs = this._layerList.getElementsByTagName("input"), inputsLen = inputs.length;
          this._handlingClick = true;
          for (i = 0; i < inputsLen; i++) {
            var input = inputs[i];
            if (!("layerId" in input)) {
              continue;
            }
            var obj2 = this._layers[input.layerId];
            if (input.checked && !this._map.hasLayer(obj2.layer)) {
              obj2.layer.addTo(this._map);
            } else if (!input.checked && this._map.hasLayer(obj2.layer)) {
              this._map.removeLayer(obj2.layer);
            }
          }
          this._handlingClick = false;
        }, this);
        inputdiv.appendChild(newInput);
      }
      const layerName = import_leaflet10.DomUtil.create(
        "div",
        "visiomatic-control-layername",
        layerItem
      );
      layerName.innerHTML = " " + obj.name;
      layerName.style.textShadow = "0px 0px 5px " + obj.layer.nameColor;
      this._addButton(
        "visiomatic-control-trash",
        layerItem,
        void 0,
        "Delete layer",
        function() {
          _this.removeLayer(obj.layer);
          if (!obj.notReady) {
            _this._map.removeLayer(obj.layer);
          }
        }
      );
      this._layerList.appendChild(layerItem);
      return layerItem;
    },
    addLayer: function(layer, name, index) {
      layer.on("add remove", this._onLayerChange, this);
      const id = import_leaflet10.Util.stamp(layer);
      this._layers[id] = {
        layer,
        name,
        index
      };
      return this._updateLayerList();
    },
    removeLayer: function(layer) {
      layer.off("add remove", this._onLayerChange, this);
      layer.fire("trash", { index: this._layers[import_leaflet10.Util.stamp(layer)].index });
      layer.off("trash");
      delete this._layers[import_leaflet10.Util.stamp(layer)];
      return this._updateLayerList();
    },
    _onLayerChange: function(e) {
      if (!this._handlingClick) {
        this._updateLayerList();
      }
      const obj = this._layers[import_leaflet10.Util.stamp(e.target)], type = e.type === "add" ? "overlayadd" : "overlayremove";
      this._map.fire(type, obj);
    }
  });

  // js/control/CatalogUI.js
  var CatalogUI = UI.extend({
    defaultCatalogs: [
      gaiaDR3,
      twomass,
      sdss,
      panstarrs1
    ],
    options: {
      title: "Catalog overlays",
      nativeCelSys: true,
      color: "#FFFF00",
      timeOut: 30,
      authenticate: false,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(catalogs, options2) {
      import_leaflet11.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-catalog";
      this._layers = {};
      this._handlingClick = false;
      this._sideClass = "catalog";
      this._catalogs = catalogs ? catalogs : this.defaultCatalogs;
    },
    _initDialog: function() {
      const className = this._className, catalogs = this._catalogs, box = this._addDialogBox(), line = this._addDialogLine("", box), elem = this._addDialogElement(line), colpick = this._addColorPicker(
        className + "-color",
        elem,
        "catalog",
        this.options.color,
        "visiomaticCatalog",
        "Click to set catalog color"
      );
      const catselect = this._addSelectMenu(
        this._className + "-select",
        elem,
        catalogs.map(
          function(catalog) {
            return catalog.name;
          }
        ),
        void 0,
        -1,
        "Select Catalog",
        function() {
          let className2 = catalogs[catselect.selectedIndex - 1].className;
          if (className2 === void 0) {
            className2 = "";
          }
          import_leaflet11.DomUtil.setClass(
            catselect,
            this._className + "-select " + className2
          );
          return;
        }
      );
      import_leaflet11.DomEvent.on(catselect, "change keyup", function() {
        const catalog = catalogs[catselect.selectedIndex - 1];
        catselect.title = catalog.attribution + " from " + catalog.service;
      }, this);
      const elem2 = this._addDialogElement(line);
      this._addButton(
        className + "-button",
        elem2,
        "catalog",
        "Query catalog",
        function() {
          const index = catselect.selectedIndex - 1;
          if (index >= 0) {
            const catalog = catalogs[index];
            catalog.color = colpick.value;
            catselect.selectedIndex = 0;
            catselect.title = "Select Catalog";
            import_leaflet11.DomUtil.setClass(catselect, this._className + "-select ");
            this._getCatalog(catalog, this.options.timeOut);
          }
        }
      );
    },
    _resetDialog: function() {
    },
    _getCatalog: function(catalog, timeout) {
      const _this = this, map2 = this._map, wcs2 = map2.options.crs, sysflag = !wcs2.equatorialFlag && !this.options.nativeCelSys, center = sysflag ? wcs2.celSysToEq(map2.getCenter()) : map2.getCenter(), b = map2.getPixelBounds(), z = map2.getZoom(), templayer = new import_leaflet11.LayerGroup(null);
      templayer.notReady = true;
      this.addLayer(templayer, catalog.name);
      if (catalog.authenticate) {
        this.options.authenticate = catalog.authenticate;
      } else {
        this.options.authenticate = false;
      }
      const lngfac = Math.abs(Math.cos(center.lat * Math.PI / 180)), c2 = sysflag ? [
        wcs2.celSysToEq(map2.unproject(b.min, z)),
        wcs2.celSysToEq(map2.unproject((0, import_leaflet11.point)(b.min.x, b.max.y), z)),
        wcs2.celSysToEq(map2.unproject(b.max, z)),
        wcs2.celSysToEq(map2.unproject((0, import_leaflet11.point)(b.max.x, b.min.y), z))
      ] : [
        map2.unproject(b.min, z),
        map2.unproject((0, import_leaflet11.point)(b.min.x, b.max.y), z),
        map2.unproject(b.max, z),
        map2.unproject((0, import_leaflet11.point)(b.max.x, b.min.y), z)
      ];
      var sys;
      if (!wcs2.equatorialFlag && this.options.nativeCelSys) {
        switch (wcs2.celSysCode) {
          case "ecliptic":
            sys = "E2000.0";
            break;
          case "galactic":
            sys = "G";
            break;
          case "supergalactic":
            sys = "S";
            break;
          default:
            sys = "J2000.0";
            break;
        }
      } else {
        sys = "J2000.0";
      }
      if (catalog.regionType === "box") {
        let dlng = (Math.max(
          wcs2._deltaLng(c2[0], center),
          wcs2._deltaLng(c2[1], center),
          wcs2._deltaLng(c2[2], center),
          wcs2._deltaLng(c2[3], center)
        ) - Math.min(
          wcs2._deltaLng(c2[0], center),
          wcs2._deltaLng(c2[1], center),
          wcs2._deltaLng(c2[2], center),
          wcs2._deltaLng(c2[3], center)
        )) * lngfac, dlat = Math.max(c2[0].lat, c2[1].lat, c2[2].lat, c2[3].lat) - Math.min(c2[0].lat, c2[1].lat, c2[2].lat, c2[3].lat);
        if (dlat < 1e-4) {
          dlat = 1e-4;
        }
        if (dlng < 1e-4) {
          dlng = 1e-4;
        }
        VUtil.requestURL(
          import_leaflet11.Util.template(catalog.url, import_leaflet11.Util.extend({
            sys,
            lng: center.lng.toFixed(6),
            lat: center.lat.toFixed(6),
            dlng: dlng.toFixed(4),
            dlat: dlat.toFixed(4),
            nmax: catalog.nmax + 1,
            maglim: catalog.maglim
          })),
          "getting " + catalog.service + " data",
          function(self2, httpRequest) {
            _this._loadCatalog(
              catalog,
              templayer,
              self2,
              httpRequest
            );
          },
          this,
          timeout
        );
      } else {
        const dr = Math.max(
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center)
        );
        VUtil.requestURL(
          import_leaflet11.Util.template(catalog.url, import_leaflet11.Util.extend({
            sys,
            lng: center.lng.toFixed(6),
            lat: center.lat.toFixed(6),
            dr: dr.toFixed(4),
            drm: (dr * 60).toFixed(4),
            nmax: catalog.nmax + 1
          })),
          "querying " + catalog.service + " data",
          function(self2, httpRequest) {
            _this._loadCatalog(
              catalog,
              templayer,
              self2,
              httpRequest
            );
          },
          this,
          this.options.timeOut
        );
      }
    },
    _loadCatalog: function(catalog, templayer, self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const wcs2 = self2._map.options.crs, response = httpRequest.responseText, geo = catalog.toGeoJSON(response), geocatalog = (0, import_leaflet11.geoJson)(geo, {
            onEachFeature: function(feature, layer) {
              if (feature.properties && feature.properties.items) {
                layer.bindPopup(catalog.popup(feature));
              }
            },
            coordsToLatLng: function(coords2) {
              if (wcs2.equatorialFlag) {
                return new L.LatLng(
                  coords2[1],
                  coords2[0],
                  coords2[2]
                );
              } else {
                const latLng11 = wcs2.eqToCelSys(
                  L.latLng(coords2[1], coords2[0])
                );
                return new L.LatLng(
                  latLng11.lat,
                  latLng11.lng,
                  coords2[2]
                );
              }
            },
            filter: function(feature) {
              return catalog.filter(feature);
            },
            pointToLayer: function(feature, latlng) {
              return catalog.draw(feature, latlng);
            },
            style: function(feature) {
              return { color: catalog.color, weight: 2 };
            }
          });
          let excessflag = false;
          geocatalog.nameColor = catalog.color;
          geocatalog.addTo(self2._map);
          this.removeLayer(templayer);
          if (geo.features.length > catalog.nmax) {
            geo.features.pop();
            excessflag = true;
          }
          this.addLayer(geocatalog, catalog.name + " (" + geo.features.length.toString() + (excessflag ? "+ entries)" : " entries)"));
          if (excessflag) {
            alert(
              "Selected area is too large: " + catalog.name + " sample has been truncated to the brightest " + catalog.nmax + " sources."
            );
          }
        } else {
          if (httpRequest.status !== 0) {
            alert("Error " + httpRequest.status + " while querying " + catalog.service + ".");
          }
          this.removeLayer(templayer);
        }
      }
    }
  });
  var catalogUI = function(catalogs, options2) {
    return new CatalogUI(catalogs, options2);
  };

  // js/control/ChannelUI.js
  var import_jquery2 = __toESM(require_jquery());
  var import_leaflet12 = __toESM(require_leaflet_src());
  window.$ = window.jQuery = import_jquery2.default;
  var ChannelUI = UI.extend({
    options: {
      title: "Channel mixing",
      mixingMode: void 0,
      cMap: "grey",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options2) {
      import_leaflet12.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-channel";
      this._sideClass = "channel";
      this._settings = [];
      this._initsettings = [];
    },
    saveSettings: function(layer, settings, mode) {
      if (!settings[mode]) {
        settings[mode] = {};
      }
      const visio = layer.visio, setting = settings[mode];
      setting.channel = visio.channel;
      setting.cMap = visio.cMap;
      setting.rgb = [];
      for (let c2 in visio.rgb) {
        setting.rgb[c2] = visio.rgb[c2].clone();
      }
    },
    loadSettings: function(layer, settings, mode, keepChannel) {
      const setting = settings[mode];
      if (!setting) {
        return;
      }
      const visio = layer.visio, vrgb = visio.rgb, srgb = setting.rgb;
      if (!keepChannel) {
        visio.channel = setting.channel;
      }
      visio.cMap = setting.cMap;
      for (let c2 in srgb) {
        vrgb[c2] = srgb[c2].clone();
      }
    },
    _initDialog: function() {
      const _this = this, layer = this._layer, className = this._className, dialog = this._dialog;
      this.saveSettings(layer, this._initsettings, "mono");
      this.saveSettings(layer, this._initsettings, "color");
      this.saveSettings(layer, this._settings, "mono");
      this.saveSettings(layer, this._settings, "color");
      this._mode = this.options.mixingMode ? this.options.mixingMode : layer.visio.mixingMode;
      const box = this._addDialogBox(), modeline = this._addDialogLine("Mode:", box), modelem = this._addDialogElement(modeline), modeinput = import_leaflet12.DomUtil.create("div", className + "-radios", modelem);
      this._addRadioButton(
        className + "-radio",
        modeinput,
        "mono",
        this._mode === "mono",
        "Select mono-channel palettized mode",
        function() {
          _this.saveSettings(layer, _this._settings, _this._mode);
          for (let elem = box.lastChild; elem !== modeline; elem = box.lastChild) {
            box.removeChild(elem);
          }
          for (let elem = dialog.lastChild; elem !== box; elem = dialog.lastChild) {
            dialog.removeChild(elem);
          }
          _this._channelList = void 0;
          _this.loadSettings(layer, _this._settings, "mono");
          _this._initMonoDialog(layer, box);
          _this._mode = "mono";
        }
      );
      this._addRadioButton(
        className + "-radio",
        modeinput,
        "color",
        this._mode !== "mono",
        "Select color mixing mode",
        function() {
          _this.saveSettings(layer, _this._settings, _this._mode);
          for (let elem = box.lastChild; elem !== modeline; elem = box.lastChild) {
            box.removeChild(elem);
          }
          for (let elem = dialog.lastChild; elem !== box; elem = dialog.lastChild) {
            dialog.removeChild(elem);
          }
          _this.loadSettings(layer, _this._settings, "color");
          _this._channelList = void 0;
          _this._initColorDialog(layer, box);
          _this._mode = "color";
        }
      );
      if (_this._mode === "mono") {
        _this._initMonoDialog(layer, box);
      } else {
        _this._initColorDialog(layer, box);
      }
    },
    _initMonoDialog: function(layer, box) {
      const _this = this, channels = layer.visio.channelLabels, className = this._className;
      const line = this._addDialogLine("Channel:", box), elem = this._addDialogElement(line);
      layer.updateMono();
      this._chanSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        layer.visio.channelLabels,
        void 0,
        layer.visio.channel,
        "Select image channel",
        function() {
          layer.visio.channel = parseInt(
            this._chanSelect.selectedIndex - 1,
            10
          );
          this._updateChannel(layer, layer.visio.channel);
          layer.redraw();
        }
      );
      const line2 = this._addDialogLine("LUT:", box), elem2 = this._addDialogElement(line2);
      const cmapinput = import_leaflet12.DomUtil.create("div", className + "-cmaps", elem2), cbutton = [], cmaps = ["grey", "jet", "cold", "hot"], _changeMap = function(value) {
        _this._onInputChange(layer, "cMap", value);
      };
      for (let c2 in cmaps) {
        cbutton[c2] = this._addRadioButton(
          "leaflet-cmap",
          cmapinput,
          cmaps[c2],
          cmaps[c2] === this.options.cMap,
          '"' + cmaps[c2].charAt(0).toUpperCase() + cmaps[c2].substr(1) + '" color-map',
          _changeMap
        );
      }
      this._addMinMax(layer, layer.visio.channel, box);
      layer.redraw();
    },
    _initColorDialog: function(layer, box) {
      const _this = this, visio = layer.visio, className = this._className, line = this._addDialogLine("Channel:", box), elem = this._addDialogElement(line), colpick = this._chanColPick = this._addColorPicker(
        className + "-color",
        elem,
        "channel",
        visio.rgb[visio.channel].toStr(),
        "visiomaticChannel",
        "Click to set channel color",
        function() {
          const chan = visio.channel, hex = $(colpick).val();
          _this._updateMix(layer, chan, rgb(hex));
          _this.collapsedOff = true;
        }
      );
      this._onInputChange(layer, "cMap", "grey");
      layer.updateMix();
      this._chanSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        visio.channelLabels,
        void 0,
        visio.channel,
        "Select image channel",
        function() {
          visio.channel = this._chanSelect.selectedIndex - 1;
          this._updateChannel(layer, visio.channel, colpick);
        }
      );
      this._addMinMax(layer, visio.channel, box);
      const line2 = this._addDialogLine("Colors:", box), elem2 = this._addDialogElement(line2);
      this._addButton(
        className + "-button",
        elem2,
        "colormix-reset",
        "Reset color mix",
        function() {
          _this.loadSettings(layer, _this._initsettings, "color", true);
          layer.updateMix();
          this._updateColPick(layer);
          this._updateChannelList(layer);
          layer.redraw();
        }
      );
      this._addButton(
        className + "-button",
        elem2,
        "colormix-auto",
        "Re-color active channels",
        function() {
          const nchan = visio.nChannel, vrgb = visio.rgb, defcol = layer.visioDefault.channelColors;
          let nchanon = 0;
          for (const c2 in vrgb) {
            nchanon++;
          }
          if (nchanon >= defcol.length) {
            nchanon = defcol.length - 1;
          }
          let cc = 0;
          for (const c2 in vrgb) {
            if (cc < nchanon) {
              vrgb[c2] = rgb(defcol[nchanon][cc++]);
            }
          }
          layer.updateMix();
          this._updateColPick(layer);
          this._updateChannelList(layer);
          layer.redraw();
        }
      );
      _this._updateChannelList(layer);
      layer.redraw();
    },
    _addMinMax: function(layer, channel, box) {
      const visio = layer.visio, step = this._spinboxStep(
        visio.minValue[channel],
        visio.maxValue[channel]
      );
      this._minElem = this._addNumericalInput(
        layer,
        "minValue[" + channel + "]",
        box,
        "Min:",
        "Lower clipping limit in " + visio.channelUnits[channel],
        visio.minValue[channel],
        step
      );
      this._maxElem = this._addNumericalInput(
        layer,
        "maxValue[" + channel + "]",
        box,
        "Max:",
        "Upper clipping limit in " + visio.channelUnits[channel],
        visio.maxValue[channel],
        step
      );
    },
    _updateChannel: function(layer, channel, colorElem = void 0) {
      const _this = this, visio = layer.visio, step = this._spinboxStep(
        visio.minValue[channel],
        visio.maxValue[channel]
      );
      _this._chanSelect.selectedIndex = channel + 1;
      if (colorElem) {
        $(colorElem).spectrum("set", visio.rgb[channel].toStr());
        $(colorElem).val(visio.rgb[channel].toStr()).off("change").on("change", function() {
          _this._updateMix(layer, channel, rgb($(colorElem).val()));
        });
      }
      this._minElem.spinbox.value(visio.minValue[channel]).step(step).off("change").on("change", function() {
        _this._onInputChange(
          layer,
          "minValue[" + channel + "]",
          _this._minElem.spinbox.value()
        );
      }, this);
      this._maxElem.spinbox.value(visio.maxValue[channel]).step(step).off("change").on("change", function() {
        _this._onInputChange(
          layer,
          "maxValue[" + channel + "]",
          _this._maxElem.spinbox.value()
        );
      }, this);
    },
    _updateMix: function(layer, channel, channel_rgb) {
      layer.rgbToMix(channel, channel_rgb);
      this._updateChannelList(layer);
      layer.redraw();
    },
    _updateChannelList: function(layer) {
      const visio = layer.visio, chanLabels = visio.channelLabels;
      let chanList = this._channelList, chanElems = this._channelElems, trashElems = this._trashElems;
      if (chanList) {
        import_leaflet12.DomUtil.empty(this._channelList);
      } else {
        chanList = this._channelList = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chanlist",
          this._dialog
        );
      }
      chanElems = this._channelElems = [];
      trashElems = this._trashElems = [];
      for (c in visio.rgb) {
        var chan = parseInt(c, 10), vrgb = visio.rgb[chan], chanElem = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-channel",
          chanList
        ), color = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chancolor",
          chanElem
        );
        color.style.backgroundColor = vrgb.toStr();
        this._activateChanElem(color, layer, chan);
        var label = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chanlabel",
          chanElem
        );
        label.innerHTML = chanLabels[c];
        this._activateChanElem(label, layer, chan);
        var trashElem = this._addButton(
          "visiomatic-control-trash",
          chanElem,
          void 0,
          "Delete channel"
        );
        this._activateTrashElem(trashElem, layer, chan);
        chanElems.push(chanElem);
        trashElems.push(trashElem);
      }
    },
    _updateColPick: function(layer) {
      const visio = layer.visio;
      $(this._chanColPick).spectrum("set", visio.rgb[visio.channel].toStr());
      $(this._chanColPick).val(visio.rgb[visio.channel].toStr());
    },
    _activateTrashElem: function(trashElem, layer, channel) {
      import_leaflet12.DomEvent.on(trashElem, "click touch", function() {
        this._updateMix(layer, channel, false);
        if (layer === this._layer && channel === layer.visio.channel) {
          this._updateColPick(layer);
        }
      }, this);
    },
    _activateChanElem: function(chanElem, layer, channel) {
      import_leaflet12.DomEvent.on(chanElem, "click touch", function() {
        layer.visio.channel = channel;
        this._updateChannel(layer, channel, this._chanColPick);
      }, this);
    }
  });
  var channelUI = function(options2) {
    return new ChannelUI(options2);
  };

  // js/control/Coords.js
  var import_leaflet13 = __toESM(require_leaflet_src());
  var Coords = import_leaflet13.Control.extend({
    options: {
      title: "Center coordinates. Click to change",
      position: "topright",
      coordinates: [{
        label: "RA, Dec",
        units: "HMS",
        nativeCelSys: false
      }],
      centerQueryKey: "center",
      fovQueryKey: "fov",
      sesameURL: "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame"
    },
    onAdd: function(map2) {
      const _this = this, className = "leaflet-control-coords";
      this._wcsdialog = import_leaflet13.DomUtil.create("div", className + "-dialog");
      this._map.on("layeradd", this._checkVisiomatic, this);
      return this._wcsdialog;
    },
    _checkVisiomatic: function(e) {
      const layer = e.layer;
      if (!layer || !layer.visioDefault) {
        return;
      }
      this._layer = layer;
      if (this._reloadFlag) {
        layer.once("load", this._resetDialog, this);
      } else {
        this._initDialog();
        this._reloadFlag = true;
      }
    },
    _initDialog: function() {
      const _this = this, wcs2 = this._map.options.crs, projections = wcs2.projections, coords2 = this.options.coordinates, className = "leaflet-control-coords", dialog = this._wcsdialog;
      if (projections) {
        const extSelect = this._wcsext = import_leaflet13.DomUtil.create(
          "select",
          className + "-ext",
          dialog
        ), extOpt = [];
        import_leaflet13.DomEvent.disableClickPropagation(extSelect);
        extSelect.id = "leaflet-ext-select";
        extSelect.title = "Switch detector";
        for (var p in projections) {
          extOpt[p] = document.createElement("option");
          extOpt[p].text = projections[p].name;
          var extIndex = parseInt(p, 10);
          extOpt[p].value = extIndex;
          if (extIndex === 0) {
            extOpt[p].selected = true;
          }
          extSelect.add(extOpt[p], null);
        }
        import_leaflet13.DomEvent.on(extSelect, "change", function(e) {
          const map2 = _this._map, wcs3 = map2.options.crs;
          map2.panTo(wcs3.unproject(
            wcs3.projections[extSelect.value].centerPnt
          ));
        });
      }
      const coordSelect = import_leaflet13.DomUtil.create(
        "select",
        className + "-select",
        dialog
      ), coordOpt = [];
      import_leaflet13.DomEvent.disableClickPropagation(coordSelect);
      this._currentCoord = 0;
      coordSelect.id = "leaflet-coord-select";
      coordSelect.title = "Switch coordinate system";
      for (var c2 in coords2) {
        coordOpt[c2] = document.createElement("option");
        coordOpt[c2].text = coords2[c2].label;
        var coordIndex = parseInt(c2, 10);
        coordOpt[c2].value = coordIndex;
        if (coordIndex === 0) {
          coordOpt[c2].selected = true;
        }
        coordSelect.add(coordOpt[c2], null);
      }
      import_leaflet13.DomEvent.on(coordSelect, "change", function(e) {
        _this._currentCoord = coordSelect.value;
        _this._onDrag();
      });
      if (projections) {
        coordSelect.style["border-radius"] = "0px";
      }
      const input = this._wcsinput = import_leaflet13.DomUtil.create(
        "input",
        className + "-input",
        dialog
      );
      import_leaflet13.DomEvent.disableClickPropagation(input);
      input.type = "text";
      input.title = this.options.title;
      if ("webkitSpeechRecognition" in window) {
        input.setAttribute("x-webkit-speech", "x-webkit-speech");
      }
      map.on("move zoomend", this._onDrag, this);
      import_leaflet13.DomEvent.on(input, "focus", function() {
        this.setSelectionRange(0, this.value.length);
      }, input);
      import_leaflet13.DomEvent.on(input, "change", function() {
        this.panTo(this._wcsinput.value);
      }, this);
      const clipboardbutton = import_leaflet13.DomUtil.create(
        "div",
        className + "-clipboard",
        dialog
      );
      clipboardbutton.title = "Copy to clipboard";
      import_leaflet13.DomEvent.on(clipboardbutton, "click", function() {
        const stateObj = {}, latlng = map.getCenter();
        let url = location.href;
        VUtil.flashElement(this._wcsinput);
        url = VUtil.updateURL(
          url,
          this.options.centerQueryKey,
          wcs2.latLngToHMSDMS(latlng)
        );
        url = VUtil.updateURL(
          url,
          this.options.fovQueryKey,
          wcs2.zoomToFov(map, map.getZoom(), latlng).toPrecision(4)
        );
        history.pushState(stateObj, "", url);
        VUtil.copyToClipboard(url);
      }, this);
      this._onDrag();
    },
    onRemove: function(map2) {
      map2.off("drag", this._onDrag);
    },
    _onDrag: function(e) {
      const wcs2 = this._map.options.crs, coord = this.options.coordinates[this._currentCoord];
      let latlng = this._map.getCenter();
      if (wcs2.projections) {
        this._wcsext.options[wcs2.multiLatLngToIndex(latlng)].selected = true;
      }
      if (wcs2.pixelFlag) {
        this._wcsinput.value = latlng.lng.toFixed(0) + " , " + latlng.lat.toFixed(0);
      } else {
        if (!coord.nativeCelSys && !wcs2.equatorialFlag) {
          latlng = wcs2.celSysToEq(latlng);
        } else if (coord.nativeCelSys && wcs2.equatorialFlag) {
          latlng = wcs2.eqToCelSys(latlng);
        }
        switch (coord.units) {
          case "HMS":
            this._wcsinput.value = wcs2.latLngToHMSDMS(latlng);
            break;
          case "deg":
            this._wcsinput.value = latlng.lng.toFixed(5) + " , " + latlng.lat.toFixed(5);
            break;
          default:
            this._wcsinput.value = latlng.lng.toFixed(1) + " , " + latlng.lat.toFixed(1);
            break;
        }
      }
    },
    panTo: function(str2) {
      const wcs2 = this._map.options.crs, coord = this.options.coordinates[this._currentCoord];
      let latlng = wcs2.parseCoords(str2);
      if (latlng) {
        if (wcs2.pixelFlag) {
          this._map.panTo(latlng);
        } else {
          if (!coord.nativeCelSys && !wcs2.equatorialFlag) {
            latlng = wcs2.eqToCelSys(latlng);
          } else if (coord.nativeCelSys && wcs2.equatorialFlag) {
            latlng = wcs2.celSysToEq(latlng);
          }
          this._map.panTo(latlng);
        }
      } else {
        VUtil.requestURL(
          this.options.sesameURL + "/-oI/A?" + str2,
          "getting coordinates for " + str2,
          this._getCoordinates,
          this,
          10
        );
      }
    },
    _getCoordinates: function(self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const str2 = httpRequest.responseText, latlng = _self._map.options.crs.parseCoords(str2);
          if (latlng) {
            self2._map.panTo(latlng);
            self2._onDrag();
          } else {
            alert(str2 + ": Unknown location");
          }
        } else {
          alert("There was a problem with the request to the Sesame service at CDS");
        }
      }
    }
  });
  var coords = function(options2) {
    return new Coords(options2);
  };
  import_leaflet13.Map.mergeOptions({
    positionControl: false
  });
  import_leaflet13.Map.addInitHook(function() {
    if (this.options.positionControl) {
      this.positionControl = new Coords(this.options.positionControl);
      this.addControl(this.positionControl);
    }
  });

  // js/control/DocUI.js
  var import_leaflet14 = __toESM(require_leaflet_src());
  var DocUI = UI.extend({
    options: {
      title: "Documentation",
      pdflink: void 0,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(url, options2) {
      import_leaflet14.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-doc";
      this._sideClass = "doc";
      this._url = url;
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, frameBox = import_leaflet14.DomUtil.create(
        "div",
        this._className + "-framebox",
        this._dialog
      ), iframe = this._iframe = import_leaflet14.DomUtil.create(
        "iframe",
        this._className + "-doc",
        frameBox
      );
      iframe.src = this._url;
      iframe.frameborder = 0;
      this._navHistory = [];
      this._navPos = 0;
      this._ignore = false;
      import_leaflet14.DomEvent.on(iframe, "load hashchange", this._onloadNav, this);
      const box = this._addDialogBox("visiomatic-doc-dialog"), line = this._addDialogLine("Navigate:", box), elem = this._addDialogElement(line);
      this._homeButton = this._addButton(
        className + "-button",
        elem,
        "home",
        "Navigate home",
        this._homeNav
      );
      this._backButton = this._addButton(
        className + "-button",
        elem,
        "back",
        "Navigate backward",
        this._backNav
      );
      this._forwardButton = this._addButton(
        className + "-button",
        elem,
        "forward",
        "Navigate forward",
        this._forwardNav
      );
      if (this.options.pdflink) {
        const pdfButton = this._addButton(
          className + "-button",
          elem,
          "pdf",
          "Download PDF version"
        );
        pdfButton.href = this.options.pdflink;
      }
    },
    _updateNav: function(newPos) {
      if (newPos !== this._navPos) {
        this._navPos = newPos;
        this._navIgnore = true;
        this._iframe.src = this._navHistory[this._navPos - 1];
        this._disableNav();
      }
    },
    _disableNav: function() {
      this._backButton.disabled = this._navPos === 1;
      this._forwardButton.disabled = this._navPos >= this._navHistory.length;
    },
    _backNav: function() {
      if (!this._backButton.disabled) {
        this._updateNav(Math.max(1, this._navPos - 1));
      }
    },
    _forwardNav: function() {
      if (!this._forwardButton.disabled) {
        this._updateNav(Math.min(this._navHistory.length, this._navPos + 1));
      }
    },
    _homeNav: function() {
      if (!this._backButton.disabled) {
        this._updateNav(1);
      }
    },
    _onloadNav: function() {
      if (true) {
        const as = this._iframe.contentDocument.getElementsByTagName("a");
        for (var i2 = 0; i2 < as.length; i2++) {
          if (VUtil.isExternal(as[i2].href)) {
            as[i2].setAttribute("target", "_blank");
          }
        }
        this._iframeLoad1 = true;
      }
      if (!this._navIgnore) {
        const href = this._iframe.contentWindow.location.href;
        if (href !== this._navHistory[this._navPos - 1]) {
          this._navHistory.splice(this._navPos, this._navHistory.length - this._navPos);
          this._navHistory.push(href);
          this._navPos = this._navHistory.length;
          this._disableNav();
        }
      } else {
        this._navIgnore = false;
      }
    }
  });
  var docUI = function(url, options2) {
    return new DocUI(url, options2);
  };

  // js/control/ExtraMap.js
  var import_leaflet15 = __toESM(require_leaflet_src());
  var ExtraMap = import_leaflet15.Control.extend({
    options: {
      title: "Navigation mini-map. Grab to navigate",
      position: "topright",
      width: 150,
      height: 150,
      collapsedWidth: 24,
      collapsedHeight: 24,
      toggleDisplay: true,
      autoToggleDisplay: false,
      zoomLevelFixed: false,
      zoomLevelOffset: -5,
      zoomAnimation: false,
      aimingRectOptions: {
        color: "#FFFFFF",
        weight: 1,
        clickable: false
      },
      shadowRectOptions: {
        color: "#FDC82F",
        weight: 1,
        opacity: 0,
        fillOpacity: 0,
        clickable: false
      },
      strings: { hideText: "Hide map", showText: "Show map" }
    },
    initialize: function(layer, options2) {
      import_leaflet15.Util.setOptions(this, options2);
      this.options.aimingRectOptions.clickable = false;
      this.options.shadowRectOptions.clickable = false;
      this._layer = layer;
    },
    onAdd: function(map2) {
      this._mainMap = map2;
      this._container = import_leaflet15.DomUtil.create("div", "leaflet-control-extramap");
      this._container.style.width = this.options.width + "px";
      this._container.style.height = this.options.height + "px";
      this._container.title = this.options.title;
      import_leaflet15.DomEvent.disableClickPropagation(this._container);
      import_leaflet15.DomEvent.on(this._container, "mousewheel", import_leaflet15.DomEvent.stopPropagation);
      this._extraMap = new import_leaflet15.Map(this._container, {
        attributionControl: false,
        zoomControl: false,
        zoomAnimation: this.options.zoomAnimation,
        autoToggleDisplay: this.options.autoToggleDisplay,
        touchZoom: !this._isZoomLevelFixed(),
        scrollWheelZoom: !this._isZoomLevelFixed(),
        doubleClickZoom: !this._isZoomLevelFixed(),
        boxZoom: !this._isZoomLevelFixed()
      });
      this._layer.addTo(this._extraMap);
      this._userToggledDisplay = false;
      this._minimized = false;
      if (this.options.toggleDisplay) {
        this._addToggleButton();
      }
      this._mainMap.whenReady(import_leaflet15.Util.bind(function() {
        this._extraMap.whenReady(import_leaflet15.Util.bind(function() {
          this._aimingRect = (0, import_leaflet15.rectangle)(
            this._mainMap.getBounds(),
            this.options.aimingRectOptions
          ).addTo(this._extraMap);
          this._shadowRect = (0, import_leaflet15.rectangle)(
            this._mainMap.getBounds(),
            this.options.shadowRectOptions
          ).addTo(this._extraMap);
          this._mainMap.on("moveend", this._onMainMapMoved, this);
          this._mainMap.on("move", this._onMainMapMoving, this);
          this._extraMap.on(
            "movestart",
            this._onExtraMapMoveStarted,
            this
          );
          this._extraMap.on("move", this._onExtraMapMoving, this);
          this._extraMap.on("moveend", this._onExtraMapMoved, this);
          this._extraMap.setView(
            this._mainMap.getCenter(),
            this._decideZoom(true)
          );
          this._setDisplay(this._decideMinimized());
        }, this));
      }, this));
      return this._container;
    },
    onRemove: function(map2) {
      this._mainMap.off("moveend", this._onMainMapMoved, this);
      this._mainMap.off("move", this._onMainMapMoving, this);
      this._extraMap.off("moveend", this._onExtraMapMoved, this);
      this._extraMap.removeLayer(this._layer);
    },
    changeLayer: function(layer) {
      this._extraMap.removeLayer(this._layer);
      this._layer = layer;
      this._extraMap.addLayer(this._layer);
    },
    _addToggleButton: function() {
      this._toggleDisplayButton = this.options.toggleDisplay ? this._addButton(
        "",
        this.options.strings.hideText,
        "leaflet-control-extramap-toggle-display leaflet-control-extramap-toggle-display-" + this.options.position,
        this._container,
        this._toggleDisplayButtonClicked,
        this
      ) : void 0;
      this._toggleDisplayButton.style.width = this.options.collapsedWidth + "px";
      this._toggleDisplayButton.style.height = this.options.collapsedHeight + "px";
    },
    _addButton: function(html, title, className, container, fn, context) {
      const link = import_leaflet15.DomUtil.create("a", className, container);
      link.innerHTML = html;
      link.href = "#";
      link.title = title;
      const stop = import_leaflet15.DomEvent.stopPropagation;
      import_leaflet15.DomEvent.on(link, "click", stop).on(link, "mousedown", stop).on(link, "dblclick", stop).on(link, "click", import_leaflet15.DomEvent.preventDefault).on(link, "click", fn, context);
      return link;
    },
    _toggleDisplayButtonClicked: function() {
      this._userToggledDisplay = true;
      if (!this._minimized) {
        this._minimize();
        this._toggleDisplayButton.title = this.options.strings.showText;
      } else {
        this._restore();
        this._toggleDisplayButton.title = this.options.strings.hideText;
      }
    },
    _setDisplay: function(minimize) {
      if (minimize !== this._minimized) {
        if (!this._minimized) {
          this._minimize();
        } else {
          this._restore();
        }
      }
    },
    _minimize: function() {
      if (this.options.toggleDisplay) {
        this._container.style.width = this.options.collapsedWidth + "px";
        this._container.style.height = this.options.collapsedHeight + "px";
        this._toggleDisplayButton.className += " minimized-" + this.options.position;
      } else {
        this._container.style.display = "none";
      }
      this._minimized = true;
    },
    _restore: function() {
      if (this.options.toggleDisplay) {
        this._container.style.width = this.options.width + "px";
        this._container.style.height = this.options.height + "px";
        this._toggleDisplayButton.className = this._toggleDisplayButton.className.replace("minimized-" + this.options.position, "");
      } else {
        this._container.style.display = "block";
      }
      this._minimized = false;
    },
    _onMainMapMoved: function(e) {
      if (!this._extraMapMoving) {
        this._mainMapMoving = true;
        this._extraMap.setView(
          this._mainMap.getCenter(),
          this._decideZoom(true)
        );
        this._setDisplay(this._decideMinimized());
      } else {
        this._extraMapMoving = false;
      }
      this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onMainMapMoving: function(e) {
      this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onExtraMapMoveStarted: function(e) {
      const lastAimingRect = this._aimingRect.getBounds(), sw = this._extraMap.latLngToContainerPoint(
        lastAimingRect.getSouthWest()
      ), ne = this._extraMap.latLngToContainerPoint(
        lastAimingRect.getNorthEast()
      );
      this._lastAimingRectPosition = { sw, ne };
    },
    _onExtraMapMoving: function(e) {
      if (!this._mainMapMoving && this._lastAimingRectPosition) {
        this._shadowRect.setBounds(new import_leaflet15.LatLngBounds(
          this._extraMap.containerPointToLatLng(
            this._lastAimingRectPosition.sw
          ),
          this._extraMap.containerPointToLatLng(
            this._lastAimingRectPosition.ne
          )
        ));
        this._shadowRect.setStyle({ opacity: 1, fillOpacity: 0.3 });
      }
    },
    _onExtraMapMoved: function(e) {
      if (!this._mainMapMoving) {
        this._extraMapMoving = true;
        this._mainMap.setView(
          this._extraMap.getCenter(),
          this._decideZoom(false)
        );
        this._shadowRect.setStyle({ opacity: 0, fillOpacity: 0 });
      } else {
        this._mainMapMoving = false;
      }
    },
    _isZoomLevelFixed: function() {
      const zoomLevelFixed = this.options.zoomLevelFixed;
      return this._isDefined(zoomLevelFixed) && this._isInteger(zoomLevelFixed);
    },
    _decideZoom: function(fromMaintoExtra) {
      if (!this._isZoomLevelFixed()) {
        if (fromMaintoExtra) {
          return this._mainMap.getZoom() + this.options.zoomLevelOffset;
        } else {
          const currentDiff = this._extraMap.getZoom() - this._mainMap.getZoom(), proposedZoom = this._extraMap.getZoom() - this.options.zoomLevelOffset;
          var toRet;
          if (currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._extraMap.getMinZoom() - this.options.zoomLevelOffset) {
            if (this._extraMap.getZoom() > this._lastExtraMapZoom) {
              toRet = this._mainMap.getZoom() + 1;
              this._extraMap.setZoom(this._extraMap.getZoom() - 1);
            } else {
              toRet = this._mainMap.getZoom();
            }
          } else {
            toRet = proposedZoom;
          }
          this._lastExtraMapZoom = this._extraMap.getZoom();
          return toRet;
        }
      } else {
        if (fromMaintoExtra) {
          return this.options.zoomLevelFixed;
        } else {
          return this._mainMap.getZoom();
        }
      }
    },
    _decideMinimized: function() {
      if (this._userToggledDisplay) {
        return this._minimized;
      }
      if (this.options.autoToggleDisplay) {
        if (this._mainMap.getBounds().contains(this._extraMap.getBounds())) {
          return true;
        }
        return false;
      }
      return this._minimized;
    },
    _isInteger: function(value) {
      return typeof value === "number";
    },
    _isDefined: function(value) {
      return typeof value !== "undefined";
    }
  });
  var extraMap = function(layer, options2) {
    return new ExtraMap(layer, options2);
  };
  import_leaflet15.Map.mergeOptions({
    extraMapControl: false
  });
  import_leaflet15.Map.addInitHook(function() {
    if (this.options.extraMapControl) {
      this.extraMapControl = new ExtraMap().addTo(this);
    }
  });

  // js/control/FullScreen.js
  var import_leaflet16 = __toESM(require_leaflet_src());
  var fullScreenApi = {
    supportsFullScreen: false,
    isFullScreen: function() {
      return false;
    },
    requestFullScreen: function() {
    },
    cancelFullScreen: function() {
    },
    fullScreenEventName: "",
    prefix: ""
  };
  var browserPrefixes = "webkit moz o ms khtml".split(" ");
  if (typeof document.exitFullscreen !== "undefined") {
    fullScreenApi.supportsFullScreen = true;
  } else {
    for (i2 = 0, il = browserPrefixes.length; i2 < il; i2++) {
      fullScreenApi.prefix = browserPrefixes[i2];
      if (typeof document[fullScreenApi.prefix + "CancelFullScreen"] !== "undefined") {
        fullScreenApi.supportsFullScreen = true;
        break;
      }
    }
  }
  var i2;
  var il;
  if (fullScreenApi.supportsFullScreen) {
    fullScreenApi.fullScreenEventName = fullScreenApi.prefix + "fullscreenchange";
    fullScreenApi.isFullScreen = function() {
      switch (this.prefix) {
        case "":
          return document.fullScreen;
        case "webkit":
          return document.webkitIsFullScreen;
        default:
          return document[this.prefix + "FullScreen"];
      }
    };
    fullScreenApi.requestFullScreen = function(el) {
      return this.prefix === "" ? el.requestFullscreen() : el[this.prefix + "RequestFullScreen"]();
    };
    fullScreenApi.cancelFullScreen = function(el) {
      return this.prefix === "" ? document.exitFullscreen() : document[this.prefix + "CancelFullScreen"]();
    };
  }
  window.fullScreenApi = fullScreenApi;
  var FullScreen = import_leaflet16.Control.extend({
    options: {
      title: "Toggle full screen mode",
      position: "topleft",
      forceSeparateButton: false
    },
    onAdd: function(map2) {
      const className = "leaflet-control-zoom-fullscreen";
      var container;
      if (map2.zoomControl && !this.options.forceSeparateButton) {
        container = map2.zoomControl._container;
      } else {
        container = import_leaflet16.DomUtil.create("div", "leaflet-bar");
      }
      this._addButton(
        this.options.title,
        className,
        container,
        this.toogleFullScreen,
        map2
      );
      return container;
    },
    _addButton: function(title, className, container, fn, context) {
      const link = import_leaflet16.DomUtil.create("a", className, container);
      link.href = "#";
      link.title = title;
      import_leaflet16.DomEvent.addListener(link, "click", import_leaflet16.DomEvent.stopPropagation).addListener(link, "click", import_leaflet16.DomEvent.preventDefault).addListener(link, "click", fn, context);
      import_leaflet16.DomEvent.addListener(container, fullScreenApi.fullScreenEventName, import_leaflet16.DomEvent.stopPropagation).addListener(container, fullScreenApi.fullScreenEventName, import_leaflet16.DomEvent.preventDefault).addListener(container, fullScreenApi.fullScreenEventName, this._handleEscKey, context);
      return link;
    },
    toogleFullScreen: function() {
      this._exitFired = false;
      const container = this._container;
      if (this._isFullscreen) {
        if (fullScreenApi.supportsFullScreen) {
          fullScreenApi.cancelFullScreen(container);
        } else {
          import_leaflet16.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
        }
        this.invalidateSize();
        this.fire("exitFullscreen");
        this._exitFired = true;
        this._isFullscreen = false;
      } else {
        if (fullScreenApi.supportsFullScreen) {
          fullScreenApi.requestFullScreen(container);
        } else {
          import_leaflet16.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
        }
        this.invalidateSize();
        this.fire("enterFullscreen");
        this._isFullscreen = true;
      }
    },
    _handleEscKey: function() {
      if (!fullScreenApi.isFullScreen(this) && !this._exitFired) {
        this.fire("exitFullscreen");
        this._exitFired = true;
        this._isFullscreen = false;
      }
    }
  });
  var fullScreen = function(options2) {
    return new FullScreen(options2);
  };
  import_leaflet16.Map.addInitHook(function() {
    if (this.options.fullScreenControl) {
      this.fullScreenControl = fullscreen(this.options.fullScreenControlOptions);
      this.addControl(this.fullScreenControl);
    }
  });

  // js/control/ImageUI.js
  var import_leaflet17 = __toESM(require_leaflet_src());
  var ImageUI = UI.extend({
    options: {
      title: "Image preferences",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options2) {
      import_leaflet17.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-image";
      this._sideClass = "image";
      this._initsettings = {};
    },
    saveSettings: function(layer, settings) {
      if (!settings) {
        return;
      }
      const visio = layer.visio;
      settings.invertCMap = visio.invertCMap;
      settings.contrast = visio.contrast;
      settings.colorSat = visio.colorSat;
      settings.gamma = visio.gamma;
      settings.quality = visio.quality;
    },
    loadSettings: function(layer, settings) {
      if (!settings) {
        return;
      }
      const visio = layer.visio;
      visio.invertCMap = settings.invertCMap;
      this._updateInput(this._input.invertCMap, settings.invertCMap);
      visio.contrast = settings.contrast;
      this._updateInput(this._input.contrast, settings.contrast);
      visio.colorSat = settings.colorSat;
      this._updateInput(this._input.colorSat, settings.colorSat);
      visio.gamma = settings.gamma;
      this._updateInput(this._input.gamma, settings.gamma);
      visio.quality = settings.quality;
      this._updateInput(this._input.quality, settings.quality);
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, visio = layer.visio, map2 = this._map;
      this._input = {};
      this.saveSettings(layer, this._initsettings);
      this._input.invertCMap = this._addSwitchInput(
        layer,
        "invertCMap",
        this._dialog,
        "Invert:",
        "Invert color map(s)",
        visio.invertCMap
      );
      this._input.contrast = this._addNumericalInput(
        layer,
        "contrast",
        this._dialog,
        "Contrast:",
        "Adjust Contrast. 1.0: normal",
        visio.contrast,
        0.05,
        0,
        10
      );
      this._input.colorSat = this._addNumericalInput(
        layer,
        "colorSat",
        this._dialog,
        "Color Sat.:",
        "Adjust Color Saturation. 0: B&W, 1.0: normal",
        visio.colorSat,
        0.05,
        0,
        5,
        this._updateMix
      );
      this._input.gamma = this._addNumericalInput(
        layer,
        "gamma",
        this._dialog,
        "Gamma:",
        "Adjust Gamma correction. The standard value is 2.2",
        visio.gamma,
        0.05,
        0.5,
        5
      );
      this._input.quality = this._addNumericalInput(
        layer,
        "quality",
        this._dialog,
        "JPEG quality:",
        "Adjust JPEG compression quality. 1: lowest, 100: highest",
        visio.quality,
        1,
        1,
        100
      );
      const line = this._addDialogLine("Reset:", this._dialog), elem = this._addDialogElement(line);
      this._addButton(
        className + "-button",
        elem,
        "image-reset",
        "Reset image settings",
        function() {
          _this.loadSettings(layer, _this._initsettings);
          layer.updateMix();
          layer.redraw();
        }
      );
    },
    _updateMix: function(layer) {
      const colors = layer.visio.rgb;
      for (const c2 in colors) {
        layer.rgbToMix(c2);
      }
      return;
    }
  });
  var imageUI = function(options2) {
    return new ImageUI(options2);
  };

  // js/control/ProfileUI.js
  var import_jquery3 = __toESM(require_jquery());
  var import_jqplot_exported = __toESM(require_jqplot());
  var import_leaflet18 = __toESM(require_leaflet_src());
  window.$ = window.jQuery = import_jquery3.default;
  var ProfileUI = UI.extend({
    options: {
      title: "Profile overlays",
      profile: true,
      profileColor: "#FF00FF",
      spectrum: true,
      spectrumColor: "#A000FF",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options2) {
      import_leaflet18.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-profile";
      this._layers = {};
      this._sideClass = "profile";
      this._handlingClick = false;
    },
    _initDialog: function() {
      const _this = this, options2 = this.options, className = this._className, box = this._addDialogBox();
      if (options2.profile) {
        const line = this._addDialogLine("Profile:", box), elem = this._addDialogElement(line), linecolpick = this._addColorPicker(
          className + "-color",
          elem,
          "profile",
          options2.profileColor,
          "visiomaticProfile",
          "Click to set line color"
        );
        this._addButton(
          className + "-button",
          elem,
          "start",
          "Start drawing a profile line",
          function() {
            if (this._currProfileLine) {
              this._updateLine();
            } else {
              const map2 = _this._map, point7 = map2.getCenter(), line2 = this._currProfileLine = (0, import_leaflet18.polyline)(
                [point7, point7],
                {
                  color: linecolpick.value,
                  weight: 7,
                  opacity: 0.5
                }
              );
              line2.nameColor = linecolpick.value;
              line2.addTo(map2);
              map2.on("drag", this._updateLine, this);
            }
          }
        );
        this._addButton(
          className + "-button",
          elem,
          "end",
          "End line and plot",
          this._profileEnd
        );
      }
      if (options2.spectrum) {
        const line = this._addDialogLine("Spectrum:", box), elem = this._addDialogElement(line);
        const speccolpick = this._addColorPicker(
          className + "-color",
          elem,
          "spectrum",
          options2.spectrumColor,
          "visiomaticSpectra",
          "Click to set marker color"
        );
        this._addButton(
          className + "-button",
          elem,
          "spectrum",
          "Plot a spectrum at the current map position",
          function() {
            const map2 = _this._map, latLng11 = map2.getCenter(), zoom = map2.options.crs.options.nzoom - 1, point7 = map2.project(latLng11, zoom).floor().add([0.5, 0.5]), rLatLng = map2.unproject(point7, zoom), marker2 = this._spectrumMarker = (0, import_leaflet18.circleMarker)(rLatLng, {
              color: speccolpick.value,
              radius: 6,
              title: "Spectrum"
            }).addTo(map2), popdiv = import_leaflet18.DomUtil.create(
              "div",
              this._className + "-popup"
            ), activity = import_leaflet18.DomUtil.create(
              "div",
              this._className + "-activity",
              popdiv
            );
            popdiv.id = "leaflet-spectrum-plot";
            marker2.bindPopup(
              popdiv,
              {
                minWidth: 16,
                maxWidth: 1024,
                closeOnClick: false
              }
            ).openPopup();
            VUtil.requestURL(
              this._layer._url.replace(/\&.*$/g, "") + "&PFL=" + zoom.toString() + ":" + (point7.x - 0.5).toFixed(0) + "," + (point7.y - 0.5).toFixed(0) + "-" + (point7.x - 0.5).toFixed(0) + "," + (point7.y - 0.5).toFixed(0),
              "getting layer spectrum",
              this._plotSpectrum,
              this
            );
          }
        );
      }
    },
    _updateLine: function(e) {
      const map2 = this._map, latLng11 = map2.getCenter(), maxzoom = map2.options.crs.options.nzoom - 1, path = this._currProfileLine.getLatLngs(), point1 = map2.project(path[0], maxzoom), point22 = map2.project(map2.getCenter(), maxzoom);
      if (Math.abs(point1.x - point22.x) > Math.abs(point1.y - point22.y)) {
        point22.y = point1.y;
      } else {
        point22.x = point1.x;
      }
      path[1] = map2.unproject(point22, maxzoom);
      this._currProfileLine.redraw();
    },
    _profileEnd: function() {
      const map2 = this._map, point7 = map2.getCenter(), line = this._profileLine = this._currProfileLine;
      map2.off("drag", this._updateLine, this);
      this._currProfileLine = void 0;
      const popdiv = import_leaflet18.DomUtil.create("div", this._className + "-popup"), activity = import_leaflet18.DomUtil.create(
        "div",
        this._className + "-activity",
        popdiv
      );
      popdiv.id = "leaflet-profile-plot";
      line.bindPopup(
        popdiv,
        { minWidth: 16, maxWidth: 1024, closeOnClick: false }
      ).openPopup();
      const zoom = map2.options.crs.options.nzoom - 1, path = line.getLatLngs(), point1 = map2.project(path[0], zoom), point22 = map2.project(path[1], zoom);
      if (point22.x < point1.x) {
        const x = point22.x;
        point22.x = point1.x;
        point1.x = x;
      }
      if (point22.y < point1.y) {
        const y = point22.y;
        point22.y = point1.y;
        point1.y = y;
      }
      VUtil.requestURL(
        this._layer._url.replace(/\&.*$/g, "") + "&PFL=" + zoom.toString() + ":" + (point1.x - 0.5).toFixed(0) + "," + (point1.y - 0.5).toFixed(0) + "-" + (point22.x - 0.5).toFixed(0) + "," + (point22.y - 0.5).toFixed(0),
        "getting layer profile",
        this._plotProfile,
        this
      );
    },
    _getMeasurementString: function() {
      const currentLatLng = this._currentLatLng, previousLatLng = this._markers[this._markers.length - 1].getLatLng();
      var unit;
      let distance = this._measurementRunningTotal + VUtil.distance(
        currentLatLng,
        previousLatLng
      );
      if (distance >= 1) {
        unit = "&#176;";
      } else {
        distance *= 60;
        if (distance >= 1) {
          unit = "&#39;";
        } else {
          distance *= 60;
          unit = "&#34;";
        }
      }
      const distanceStr = distance.toFixed(2) + unit;
      return distanceStr;
    },
    _plotProfile: function(self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const json = JSON.parse(httpRequest.responseText), rawprof = json.profile, layer = self2._layer, visio = layer.visio, line = self2._profileLine, popdiv = document.getElementById("leaflet-profile-plot"), prof = [], series = [];
          var title, ylabel;
          self2.addLayer(line, "Image profile");
          if (visio.mode === "mono") {
            prof.push(self2._extractProfile(
              layer,
              rawprof,
              visio.channel
            ));
            series.push({
              color: "black"
            });
            title = "Image profile for " + visio.channelLabels[visio.channel];
            ylabel = "Pixel value in " + visio.channelUnits[visio.channel];
          } else {
            const rgb2 = visio.rgb;
            for (let c2 = 0; c2 < visio.nChannel; c2++) {
              if (rgb2[c2].isOn()) {
                prof.push(self2._extractProfile(layer, rawprof, c2));
                series.push({
                  color: rgb2[c2].toStr(),
                  label: visio.channelLabels[c2]
                });
              }
            }
            title = "Image profiles";
            ylabel = "Pixel value";
          }
          $(document).ready(function() {
            $.jqplot.config.enablePlugins = true;
            $.jqplot("leaflet-profile-plot", prof, {
              title,
              grid: {
                backgroundColor: "#ddd",
                gridLineColor: "#eee"
              },
              axes: {
                xaxis: {
                  label: "position along line",
                  labelRenderer: $.jqplot.CanvasAxisLabelRenderer,
                  pad: 1
                },
                yaxis: {
                  label: ylabel,
                  labelRenderer: $.jqplot.CanvasAxisLabelRenderer,
                  pad: 1
                }
              },
              legend: {
                show: visio.mode !== "mono",
                location: "ne"
              },
              highlighter: {
                show: true,
                sizeAdjust: 2,
                tooltipLocation: "n",
                tooltipAxes: "y",
                tooltipFormatString: "%.6g " + visio.channelUnits[visio.channel],
                useAxesFormatters: false,
                bringSeriesToFront: true
              },
              cursor: {
                show: true,
                zoom: true
              },
              series,
              seriesDefaults: {
                lineWidth: 2,
                showMarker: false
              }
            });
          });
          popdiv.removeChild(
            popdiv.childNodes[0]
          );
          line._popup.update();
        }
      }
    },
    _extractProfile: function(layer, rawprof, channel) {
      const nchan = layer.visio.nChannel, npix = rawprof.length / nchan, prof = [];
      for (let i2 = 0; i2 < npix; i2++) {
        prof.push(rawprof[i2 * nchan + channel]);
      }
      return prof;
    },
    _plotSpectrum: function(self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const json = JSON.parse(httpRequest.responseText), rawprof = json.profile, layer = self2._layer, visio = layer.visio, marker2 = self2._spectrumMarker, popdiv = document.getElementById("leaflet-spectrum-plot"), spec = [], series = [], title = "Image Spectrum", ylabel = "Average pixel value";
          self2.addLayer(marker2, "Image spectrum");
          for (let c2 = 0; c2 < visio.nChannel; c2++) {
            spec.push([
              visio.channelLabels[c2],
              self2._extractAverage(layer, rawprof, c2)
            ]);
          }
          $(document).ready(function() {
            $.jqplot.config.enablePlugins = true;
            $.jqplot("leaflet-spectrum-plot", [spec], {
              title,
              grid: {
                backgroundColor: "#F0F0F0",
                gridLineColor: "#F8F8F8"
              },
              axes: {
                xaxis: {
                  renderer: $.jqplot.CategoryAxisRenderer,
                  tickRenderer: $.jqplot.CanvasAxisTickRenderer,
                  tickOptions: {
                    angle: -30,
                    fontSize: "6pt"
                  }
                },
                yaxis: {
                  label: ylabel,
                  labelRenderer: $.jqplot.CanvasAxisLabelRenderer
                }
              },
              highlighter: {
                show: true,
                sizeAdjust: 2,
                tooltipLocation: "n",
                tooltipAxes: "y",
                tooltipFormatString: "%.6g " + visio.channelUnits[visio.channel],
                useAxesFormatters: false
              },
              cursor: {
                show: true,
                zoom: true
              },
              seriesDefaults: {
                lineWidth: 2,
                showMarker: false
              }
            });
          });
          popdiv.removeChild(
            popdiv.childNodes[0]
          );
          marker2._popup.update();
        }
      }
    },
    _extractAverage: function(layer, rawprof, channel) {
      const nchan = layer.visio.nChannel, npix = rawprof.length / nchan;
      let val = 0;
      if (npix === 0) {
        return 0;
      }
      for (let i2 = 0; i2 < npix; i2++) {
        val += rawprof[i2 * nchan + channel];
      }
      return val / npix;
    }
  });
  var profileUI = function(options2) {
    return new ProfileUI(options2);
  };

  // js/control/RegionUI.js
  var import_leaflet19 = __toESM(require_leaflet_src());
  var RegionUI = UI.extend({
    options: {
      title: "Region overlays",
      nativeCelSys: true,
      color: "#00FFFF",
      timeOut: 30,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(regions, options2) {
      import_leaflet19.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-region";
      this._layers = {};
      this._handlingClick = false;
      this._sideClass = "region";
      this._regions = regions && regions[0] ? regions : [];
    },
    _initDialog: function() {
      const className = this._className, regions = this._regions, box = this._addDialogBox(), line = this._addDialogLine("Regions:", box), elem = this._addDialogElement(line), colpick = this._addColorPicker(
        className + "-color",
        elem,
        "region",
        this.options.color,
        "visiomaticRegion",
        "Click to set region color"
      );
      const select = this._regionSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        regions.map(function(o) {
          return o.name;
        }),
        regions.map(function(o) {
          return o.load ? true : false;
        }),
        -1,
        "Select region"
      );
      this._addButton(
        className + "-button",
        this._addDialogElement(line),
        "region",
        "Display region",
        function() {
          const index2 = select.selectedIndex - 1;
          if (index2 >= 0) {
            const region2 = this._regions[index2];
            region2.color = colpick.value;
            select.selectedIndex = 0;
            select.opt[index2].disabled = true;
            this._getRegion(region2, this.options.timeOut);
          }
        }
      );
      for (var index = 0; index < regions.length; index++) {
        var region = regions[index];
        region.index = index;
        if (region.load === true) {
          if (!region.color) {
            region.color = this.options.color;
          }
          this._getRegion(regions[index], this.options.timeOut);
        }
      }
    },
    _resetDialog: function() {
    },
    _getRegion: function(region, timeout) {
      const _this = this, map2 = this._map, wcs2 = map2.options.crs, sysflag = !wcs2.equatorialFlag && !this.options.nativeCelSys, templayer = new import_leaflet19.LayerGroup(null);
      templayer.notReady = true;
      this.addLayer(templayer, region.name);
      VUtil.requestURL(
        region.url,
        "loading " + region.name + " data",
        function(context, httpRequest) {
          _this._loadRegion(region, templayer, context, httpRequest);
        },
        this,
        this.options.timeOut
      );
    },
    _loadRegion: function(region, templayer, _this, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const wcs2 = _this._map.options.crs, response = httpRequest.responseText, geoRegion = (0, import_leaflet19.geoJson)(
            JSON.parse(response),
            {
              onEachFeature: function(feature, layer) {
                if (feature.properties && feature.properties.description) {
                  layer.bindPopup(feature.properties.description);
                } else if (region.description) {
                  layer.bindPopup(region.description);
                }
              },
              coordsToLatLng: function(coords2) {
                if (wcs2.equatorialFlag) {
                  return new import_leaflet19.LatLng(coords2[1], coords2[0], coords2[2]);
                } else {
                  const latLng11 = wcs2.eqToCelSys(
                    latLng11(coords2[1], coords2[0])
                  );
                  return new import_leaflet19.LatLng(
                    latLng11.lat,
                    latLng11.lng,
                    coords2[2]
                  );
                }
              },
              style: function(feature) {
                return { color: region.color, weight: 2 };
              },
              pointToLayer: function(feature, latlng) {
                return region.drawPoint ? region.drawPoint(feature, latlng) : (0, import_leaflet19.marker)(latlng);
              }
            }
          );
          geoRegion.nameColor = region.color;
          geoRegion.addTo(_this._map);
          _this.removeLayer(templayer);
          _this.addLayer(geoRegion, region.name, region.index);
          import_leaflet19.DomEvent.on(geoRegion, "trash", function(e) {
            if (e.index || e.index === 0) {
              _this._regionSelect.opt[e.index].disabled = false;
            }
          }, _this);
        } else {
          if (httpRequest.status !== 0) {
            alert("Error " + httpRequest.status + " while downloading " + region.url + ".");
          }
          _this.removeLayer(templayer);
          _this._regionSelect.opt[region.index].disabled = false;
        }
      }
    }
  });
  var regionUI = function(regions, options2) {
    return new RegionUI(regions, options2);
  };

  // js/control/Reticle.js
  var import_leaflet20 = __toESM(require_leaflet_src());
  var Reticle = import_leaflet20.Control.extend({
    initialize: function(options2) {
      import_leaflet20.Util.setOptions(this, options2);
    },
    onAdd: function(map2) {
      const reticle2 = this._reticle = import_leaflet20.DomUtil.create(
        "div",
        "leaflet-reticle",
        this._map._controlContainer
      ), style = reticle2.style;
      style.position = "absolute";
      style.left = "50%";
      style.bottom = "50%";
      style.textAlign = "center";
      style.verticalAlign = "middle";
      style.pointerEvents = "none";
      reticle2.innerHTML = "";
      const container = this._container = import_leaflet20.DomUtil.create("div", "leaflet-dummy");
      return container;
    },
    onRemove: function(map2) {
      this._reticle.parentNode.removeChild(this._reticle);
    }
  });
  var reticle = function(options2) {
    return new Reticle(options2);
  };

  // js/control/Scale.js
  var import_leaflet21 = __toESM(require_leaflet_src());
  var Scale = import_leaflet21.Control.Scale.extend({
    options: {
      title: "Scale",
      position: "bottomleft",
      maxWidth: 128,
      metric: false,
      imperial: false,
      degrees: true,
      pixels: false,
      custom: false,
      customScale: 1,
      customUnits: "",
      planetRadius: 6378137,
      updateWhenIdle: false
    },
    initialize: function(options2) {
      import_leaflet21.Util.setOptions(this, options2);
    },
    _addScales: function(options2, className, container) {
      if (options2.metric) {
        this._mScale = import_leaflet21.DomUtil.create("div", className, container);
        this._mScale.title = options2.metricTitle ? options2.metricTitle : options2.title;
      }
      if (options2.imperial) {
        this._iScale = import_leaflet21.DomUtil.create("div", className, container);
        this._iScale.title = options2.imperialTitle ? options2.imperialTitle : options2.title;
      }
      if (options2.degrees) {
        this._dScale = import_leaflet21.DomUtil.create("div", className, container);
        this._dScale.title = options2.degreesTitle ? options2.degreesTitle : options2.title;
      }
      if (options2.pixels) {
        this._pScale = import_leaflet21.DomUtil.create("div", className, container);
        this._pScale.title = options2.pixelsTitle ? options2.pixelsTitle : options2.title;
      }
      if (options2.custom) {
        this._cScale = import_leaflet21.DomUtil.create("div", className, container);
        this._cScale.title = options2.customTitle ? options2.customTitle : options2.title;
      }
      this.angular = options2.metric || options2.imperial || options2.degrees;
    },
    _update: function() {
      const options2 = this.options, map2 = this._map, crs = map2.options.crs;
      if (options2.pixels && crs.options && crs.options.nzoom) {
        const pixelScale = Math.pow(
          2,
          crs.options.nzoom - 1 - map2.getZoom()
        );
        this._updatePixels(pixelScale * options2.maxWidth);
      }
      if (options2.custom && crs.options && crs.options.nzoom) {
        const customScale = Math.pow(
          2,
          crs.options.nzoom - 1 - map2.getZoom()
        ) * options2.customScale;
        this._updateCustom(
          customScale * options2.maxWidth,
          options2.customUnits
        );
      }
      if (this.angular) {
        const center = map2.getCenter(), cosLat = Math.cos(center.lat * Math.PI / 180), dist = Math.sqrt(this._jacobian(center)) * cosLat, maxDegrees = dist * options2.maxWidth;
        if (options2.metric) {
          this._updateMetric(
            maxDegrees * Math.PI / 180 * options2.planetRadius
          );
        }
        if (options2.imperial) {
          this._updateImperial(
            maxDegrees * Math.PI / 180 * options2.planetRadius
          );
        }
        if (options2.degrees) {
          this._updateDegrees(maxDegrees);
        }
      }
    },
    _jacobian: function(latlng) {
      const map2 = this._map, p0 = map2.project(latlng), latlngdx = map2.unproject(p0.add([10, 0])), latlngdy = map2.unproject(p0.add([0, 10]));
      return 0.01 * Math.abs((latlngdx.lng - latlng.lng) * (latlngdy.lat - latlng.lat) - (latlngdy.lng - latlng.lng) * (latlngdx.lat - latlng.lat));
    },
    _updateCustom: function(maxCust, units) {
      const scale2 = this._cScale;
      if (maxCust > 1e9) {
        var maxGCust = maxCust * 1e-9, gCust = this._getRoundNum(maxGCust);
        this._updateScale(scale2, gCust + " G" + units, gCust / maxGCust);
      } else if (maxCust > 1e6) {
        var maxMCust = maxCust * 1e-6, mCust = this._getRoundNum(maxMCust);
        this._updateScale(scale2, mCust + " M" + units, mCust / maxMCust);
      } else if (maxCust > 1e3) {
        var maxKCust = maxCust * 1e-3, kCust = this._getRoundNum(maxKCust);
        this._updateScale(scale2, kCust + " k" + units, kCust / maxKCust);
      } else {
        var cust = this._getRoundNum(maxCust);
        this._updateScale(scale2, cust + " " + units, cust / maxCust);
      }
    },
    _updatePixels: function(maxPix) {
      const scale2 = this._pScale;
      if (maxPix > 1e6) {
        var maxMPix = maxPix * 1e-6, mPix = this._getRoundNum(maxMPix);
        this._updateScale(scale2, mPix + " Mpx", mPix / maxMPix);
      } else if (maxPix > 1e3) {
        var maxKPix = maxPix * 1e-3, kPix = this._getRoundNum(maxKPix);
        this._updateScale(scale2, kPix + " kpx", kPix / maxKPix);
      } else {
        var pix = this._getRoundNum(maxPix);
        this._updateScale(scale2, pix + " px", pix / maxPix);
      }
    },
    _updateDegrees: function(maxDegrees) {
      const maxSeconds = maxDegrees * 3600, scale2 = this._dScale;
      if (maxSeconds < 1) {
        var maxMas = maxSeconds * 1e3, mas = this._getRoundNum(maxMas);
        this._updateScale(scale2, mas + " mas", mas / maxMas);
      } else if (maxSeconds < 60) {
        var seconds = this._getRoundNum(maxSeconds);
        this._updateScale(scale2, seconds + " &#34;", seconds / maxSeconds);
      } else if (maxSeconds < 3600) {
        var maxMinutes = maxDegrees * 60, minutes = this._getRoundNum(maxMinutes);
        this._updateScale(scale2, minutes + " &#39;", minutes / maxMinutes);
      } else {
        var degrees = this._getRoundNum(maxDegrees);
        this._updateScale(scale2, degrees + " &#176;", degrees / maxDegrees);
      }
    }
  });
  var scale = function(options2) {
    return new Scale(options2);
  };

  // js/control/Sidebar.js
  var import_leaflet22 = __toESM(require_leaflet_src());
  var Sidebar = import_leaflet22.Control.extend({
    includes: import_leaflet22.Evented && import_leaflet22.Evented.prototype,
    options: {
      title: "Toggle advanced menu",
      position: "left",
      collapsed: true,
      forceSeparateButton: false
    },
    initialize: function(options2) {
      import_leaflet22.Util.setOptions(this, options2);
      this._sidebar = import_leaflet22.DomUtil.create("div", "leaflet-container sidebar");
      if (this.options.collapsed) {
        import_leaflet22.DomUtil.addClass(this._sidebar, "collapsed");
      } else {
        import_leaflet22.DomUtil.addClass(this._sidebar, "closed");
      }
      import_leaflet22.DomUtil.addClass(this._sidebar, "sidebar-" + this.options.position);
      if (import_leaflet22.Browser.touch) {
        import_leaflet22.DomUtil.addClass(this._sidebar, "leaflet-touch");
      }
      this._tabs = import_leaflet22.DomUtil.create("div", "sidebar-tabs", this._sidebar);
      this._tabitems = [];
      this._container = import_leaflet22.DomUtil.create("div", "sidebar-content", this._sidebar);
      this._panes = [];
      this._closeButtons = [];
    },
    addTo: function(map2) {
      const className = "leaflet-control-zoom-sidebar", parent = map2._controlContainer;
      var buttonContainer;
      import_leaflet22.DomUtil.addClass(map2._container, "sidebar-map");
      parent.insertBefore(this._sidebar, parent.firstChild);
      import_leaflet22.DomEvent.disableClickPropagation(this._sidebar).disableScrollPropagation(this._sidebar);
      this._map = map2;
      if (map2.zoomControl && !this.options.forceSeparateButton) {
        buttonContainer = map2.zoomControl._container;
      } else {
        buttonContainer = import_leaflet22.DomUtil.create("div", "leaflet-bar");
      }
      this._toggleButton = this._addButton(
        this.options.title,
        className + (this.options.collapsed ? " collapsed" : ""),
        buttonContainer
      );
      return this;
    },
    addTabList: function() {
      this._tablist = import_leaflet22.DomUtil.create("ul", "", this._tabs);
      this._tablist.setAttribute("role", "tablist");
      return this._tablist;
    },
    addTab: function(id, className, title, content, sideClass) {
      const tablist = this._tablist ? this._tablist : this.addTabList(), item = import_leaflet22.DomUtil.create("li", "", tablist), button = import_leaflet22.DomUtil.create("a", className, item);
      item.setAttribute("role", "tab");
      item._sidebar = this;
      button.href = "#" + id;
      button.id = id + "-toggle";
      button.title = title;
      import_leaflet22.DomEvent.on(button, "click", L.DomEvent.preventDefault);
      import_leaflet22.DomEvent.on(button, "click", this._onClick, item);
      item.sideClass = sideClass;
      this._tabitems.push(item);
      const pane = import_leaflet22.DomUtil.create("div", "sidebar-pane", this._container), header = import_leaflet22.DomUtil.create("h1", "sidebar-header", pane);
      header.innerHTML = title;
      const closeButton = import_leaflet22.DomUtil.create("div", "sidebar-close", header);
      this._closeButtons.push(closeButton);
      import_leaflet22.DomEvent.on(closeButton, "click", this._onCloseClick, this);
      pane.id = id;
      pane.sideClass = sideClass;
      pane.appendChild(content);
      this._panes.push(pane);
      return pane;
    },
    removeFrom: function(map2) {
      this._map = null;
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        import_leaflet22.DomEvent.off(child.querySelector("a"), "click", this._onClick);
      }
      for (var i2 = this._closeButtons.length - 1; i2 >= 0; i2--) {
        var child = this._closeButtons[i2];
        import_leaflet22.DomEvent.off(child, "click", this._onCloseClick, this);
      }
      return this;
    },
    open: function(id) {
      for (var i2 = this._panes.length - 1; i2 >= 0; i2--) {
        var child = this._panes[i2];
        if (child.id === id) {
          import_leaflet22.DomUtil.addClass(child, "active");
          if (child.sideClass) {
            import_leaflet22.DomUtil.addClass(this._sidebar, child.sideClass);
          }
        } else if (import_leaflet22.DomUtil.hasClass(child, "active")) {
          import_leaflet22.DomUtil.removeClass(child, "active");
          if (child.sideClass) {
            import_leaflet22.DomUtil.removeClass(this._sidebar, child.sideClass);
          }
        }
      }
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        if (child.querySelector("a").hash === "#" + id) {
          import_leaflet22.DomUtil.addClass(child, "active");
        } else if (import_leaflet22.DomUtil.hasClass(child, "active")) {
          import_leaflet22.DomUtil.removeClass(child, "active");
        }
      }
      this.fire("content", { id });
      if (import_leaflet22.DomUtil.hasClass(this._sidebar, "closed")) {
        this.fire("opening");
        import_leaflet22.DomUtil.removeClass(this._sidebar, "closed");
      }
      return this;
    },
    close: function() {
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        if (import_leaflet22.DomUtil.hasClass(child, "active")) {
          import_leaflet22.DomUtil.removeClass(child, "active");
          if (child.sideClass) {
            import_leaflet22.DomUtil.removeClass(this._sidebar, child.sideClass);
          }
        }
      }
      if (!import_leaflet22.DomUtil.hasClass(this._sidebar, "closed")) {
        this.fire("closing");
        import_leaflet22.DomUtil.addClass(this._sidebar, "closed");
      }
      return this;
    },
    toggle: function() {
      this.close();
      if (import_leaflet22.DomUtil.hasClass(this._sidebar, "collapsed")) {
        import_leaflet22.DomUtil.addClass(this._sidebar, "closed");
        this.fire("expanding");
        import_leaflet22.DomUtil.removeClass(this._sidebar, "collapsed");
        import_leaflet22.DomUtil.removeClass(this._toggleButton, "collapsed");
      } else {
        import_leaflet22.DomUtil.removeClass(this._sidebar, "closed");
        this.fire("collapsing");
        import_leaflet22.DomUtil.addClass(this._sidebar, "collapsed");
        import_leaflet22.DomUtil.addClass(this._toggleButton, "collapsed");
      }
    },
    _onClick: function() {
      if (import_leaflet22.DomUtil.hasClass(this, "active")) {
        this._sidebar.close();
      } else if (!import_leaflet22.DomUtil.hasClass(this, "disabled")) {
        this._sidebar.open(this.querySelector("a").hash.slice(1));
      }
    },
    _onCloseClick: function() {
      this.close();
    },
    _addButton: function(title, className, container) {
      const link = import_leaflet22.DomUtil.create("a", className, container);
      link.href = "#";
      link.title = title;
      import_leaflet22.DomEvent.addListener(link, "click", import_leaflet22.DomEvent.stopPropagation).addListener(link, "click", import_leaflet22.DomEvent.preventDefault).addListener(link, "click", this.toggle, this);
      return link;
    }
  });
  var sidebar = function(map2, options2) {
    return new Sidebar(map2, options2);
  };

  // js/control/SnapshotUI.js
  var import_leaflet23 = __toESM(require_leaflet_src());
  var SnapshotUI = UI.extend({
    options: {
      title: "Snapshots",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options2) {
      import_leaflet23.Util.setOptions(this, options2);
      this._className = "visiomatic-control";
      this._id = "visiomatic-snapshot";
      this._sideClass = "snapshot";
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, visio = layer.visio, map2 = this._map;
      const line = this._addDialogLine("Snap:", this._dialog), elem = this._addDialogElement(line), items = ["Screen pixels", "Native pixels"];
      this._snapType = 0;
      this._snapSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        items,
        void 0,
        this._snapType,
        "Select snapshot resolution",
        function() {
          this._snapType = parseInt(this._snapSelect.selectedIndex - 1, 10);
        }
      );
      const hiddenlink = document.createElement("a");
      const button = this._addButton(
        className + "-button",
        elem,
        "snapshot",
        "Take a snapshot of the displayed image",
        function(event) {
          const latlng = map2.getCenter(), bounds3 = map2.getPixelBounds(), wcs2 = map2.options.crs;
          let z = map2.getZoom();
          var zfac;
          if (z > visio.maxZoom) {
            zfac = Math.pow(2, z - visio.maxZoom);
            z = visio.maxZoom;
          } else {
            zfac = 1;
          }
          const sizex = visio.imageSize[z].x * zfac, sizey = visio.imageSize[z].y * zfac, dx = bounds3.max.x - bounds3.min.x, dy = bounds3.max.y - bounds3.min.y;
          hiddenlink.href = layer.getTileUrl(
            { x: 1, y: 1 }
          ).replace(
            /JTL\=\d+\,\d+/g,
            "RGN=" + bounds3.min.x / sizex + "," + bounds3.min.y / sizey + "," + dx / sizex + "," + dy / sizey + "&WID=" + (this._snapType === 0 ? Math.floor(dx / zfac) : Math.floor(dx / zfac / layer.wcs.scale(z))) + "&CVT=jpeg"
          );
          hiddenlink.download = layer._title + "_" + wcs2.latLngToHMSDMS(latlng).replace(/[\s\:\.]/g, "") + ".jpg";
          hiddenlink.click();
        }
      );
      document.body.appendChild(hiddenlink);
      const line2 = this._addDialogLine("Print:", this._dialog);
      this._addButton(
        className + "-button",
        this._addDialogElement(line2),
        "print",
        "Print current map",
        function(event) {
          var control = document.querySelector(
            "#map > .leaflet-control-container"
          );
          control.style.display = "none";
          window.print();
          control.style.display = "unset";
        }
      );
    }
  });
  var snapshotUI = function(options2) {
    return new SnapshotUI(options2);
  };

  // js/crs/index.js
  var crs_exports = {};
  __export(crs_exports, {
    CAR: () => CAR,
    CEA: () => CEA,
    COE: () => COE,
    Pixel: () => Pixel,
    TAN: () => TAN,
    WCS: () => WCS,
    ZEA: () => ZEA,
    wcs: () => wcs
  });

  // js/crs/WCS.js
  var import_leaflet29 = __toESM(require_leaflet_src());

  // js/crs/Conical.js
  var import_leaflet25 = __toESM(require_leaflet_src());

  // js/crs/Projection.js
  var import_leaflet24 = __toESM(require_leaflet_src());
  var Projection = import_leaflet24.Class.extend({
    bounds: (0, import_leaflet24.bounds)([-0.5, -0.5], [0.5, 0.5]),
    defaultProjParam: {
      name: "",
      ctype: { x: "PIXEL", y: "PIXEL" },
      naxis: [256, 256],
      crpix: [129, 129],
      crval: [0, 0],
      cd: [[1, 0], [0, 1]],
      natpole: [90, 999],
      pv: [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ]
    },
    initialize: function(header, options2) {
      const projparam2 = this._paramUpdate(this.defaultProjParam);
      this.options = options2;
      this._readWCS(header);
      if (options2) {
        this._paramUpdate(options2);
      }
      this._projInit();
      if (!projparam2._pixelFlag) {
        switch (projparam2.ctype.x.substr(0, 1)) {
          case "G":
            projparam2._celsyscode = "galactic";
            break;
          case "E":
            projparam2._celsyscode = "ecliptic";
            break;
          case "S":
            projparam2._celsyscode = "supergalactic";
            break;
          default:
            projparam2._celsyscode = "equatorial";
            break;
        }
        this.equatorialFlag = !projparam2.nativeCelSys || projparam2._celsyscode == "equatorial";
        this.celSysConvFlag = !projparam2.nativeCelSys && projparam2._celsyscode !== "equatorial";
        if (this.celSysConvFlag) {
          projparam2._celsysmat = this._celsysmatInit(this.celsyscode);
        }
      }
    },
    _paramUpdate: function(paramsrc) {
      if (!this.projparam) {
        this.projparam = {};
      }
      projparam = this.projparam;
      if (paramsrc.ctype) {
        projparam.ctype = { x: paramsrc.ctype.x, y: paramsrc.ctype.y };
      }
      if (paramsrc.naxis) {
        projparam.naxis = (0, import_leaflet24.point)(paramsrc.naxis);
      }
      if (paramsrc.crval) {
        projparam.crval = projparam.cpole = (0, import_leaflet24.latLng)(paramsrc.crval);
      }
      if (paramsrc.crpix) {
        projparam.crpix = (0, import_leaflet24.point)(paramsrc.crpix);
      }
      if (paramsrc.cd) {
        projparam.cd = [
          [paramsrc.cd[0][0], paramsrc.cd[0][1]],
          [paramsrc.cd[1][0], paramsrc.cd[1][1]]
        ];
      }
      if (paramsrc.natpole) {
        projparam.natpole = (0, import_leaflet24.latLng)(paramsrc.natpole);
      }
      if (paramsrc.pv) {
        projparam.pv = [];
        projparam.pv[0] = paramsrc.pv[0].slice();
        projparam.pv[1] = paramsrc.pv[1].slice();
      }
      if (paramsrc.dataslice && paramsrc.detslice) {
        projparam.dataslice = paramsrc.dataslice;
        projparam.detslice = paramsrc.detslice;
        this._shiftWCS(projparam);
      }
      return projparam;
    },
    _readWCS: function(header) {
      const projparam2 = this.projparam;
      var v;
      this.name = projparam2.name;
      if (v = header["EXTNAME"]) {
        this.name = v;
      }
      if (v = header["CTYPE1"]) {
        projparam2.ctype.x = v;
      }
      if (v = header["CTYPE2"]) {
        projparam2.ctype.y = v;
      }
      if (v = header["NAXIS1"]) {
        projparam2.naxis.x = v;
      }
      if (v = header["NAXIS2"]) {
        projparam2.naxis.y = v;
      }
      if (v = header["CRPIX1"]) {
        projparam2.crpix.x = v;
      }
      if (v = header["CRPIX2"]) {
        projparam2.crpix.y = v;
      }
      if (v = header["CRVAL1"]) {
        projparam2.crval.lng = v;
      }
      if (v = header["CRVAL2"]) {
        projparam2.crval.lat = v;
      }
      if (v = header["LONPOLE"]) {
        projparam2.natpole.lng = v;
      }
      if (v = header["LATPOLE"]) {
        projparam2.natpole.lat = v;
      }
      if (v = header["CD1_1"]) {
        projparam2.cd[0][0] = v;
      }
      if (v = header["CD1_2"]) {
        projparam2.cd[0][1] = v;
      }
      if (v = header["CD2_1"]) {
        projparam2.cd[1][0] = v;
      }
      if (v = header["CD2_2"]) {
        projparam2.cd[1][1] = v;
      }
      for (var d2 = 0; d2 < 2; d2++) {
        for (var j = 0; j < 20; j++) {
          if (v = header["PV" + (d2 + 1) + "_" + j]) {
            projparam2.pv[d2][j] = v;
          }
        }
      }
    },
    _shiftWCS: function(projparam2) {
      const crpix = projparam2.crpix, cd = projparam2.cd, dataslice = projparam2.dataslice, detslice = projparam2.detslice;
      crpix.x = detslice[0][0] + detslice[0][2] * (crpix.x - dataslice[0][0]);
      crpix.y = detslice[1][0] + detslice[1][2] * (crpix.y - dataslice[1][0]);
      cd[0][0] *= detslice[0][2];
      cd[0][1] *= detslice[1][2];
      cd[1][0] *= detslice[0][2];
      cd[1][1] *= detslice[1][2];
    },
    _celsysmatInit: function(celsyscode) {
      const deg = Math.PI / 180, cmat = [];
      var corig, cpole;
      switch (celsyscode) {
        case "galactic":
          corig = (0, import_leaflet24.latLng)(-28.93617242, 266.40499625);
          cpole = (0, import_leaflet24.latLng)(27.1282512, 192.85948123);
          break;
        case "ecliptic":
          corig = (0, import_leaflet24.latLng)(0, 0);
          cpole = (0, import_leaflet24.latLng)(66.99111111, 273.85261111);
          break;
        case "supergalactic":
          corig = (0, import_leaflet24.latLng)(59.52315, 42.29235);
          cpole = (0, import_leaflet24.latLng)(15.7048, 283.7514);
          break;
        default:
          corig = (0, import_leaflet24.latLng)(0, 0);
          cpole = (0, import_leaflet24.latLng)(0, 0);
          break;
      }
      cmat[0] = cpole.lng * deg;
      cmat[1] = Math.asin(Math.cos(corig.lat * deg) * Math.sin((cpole.lng - corig.lng) * deg));
      cmat[2] = Math.cos(cpole.lat * deg);
      cmat[3] = Math.sin(cpole.lat * deg);
      return cmat;
    },
    project: function(latlng) {
      const phiTheta = this._raDecToPhiTheta(
        this.celSysConvFlag ? this.eqToCelSys(latlng) : latlng
      );
      phiTheta.lat = this._thetaToR(phiTheta.lat);
      return this._redToPix(this._phiRToRed(phiTheta));
    },
    unproject: function(pnt) {
      const phiTheta = this._redToPhiR(this._pixToRed(pnt));
      phiTheta.lat = this._rToTheta(phiTheta.lat);
      const latlng = this._phiThetaToRADec(phiTheta);
      if (latlng.lng < -180) {
        latlng.lng += 360;
      }
      return this.celSysConvFlag ? this.celSysToEq(latlng) : latlng;
    },
    celSysToEq: function(latlng) {
      const cmat = this.projparam._celsysmat, deg = Math.PI / 180, invdeg = 180 / Math.PI, a2 = latlng.lng * deg - cmat[1], d2 = latlng.lat * deg, sd2 = Math.sin(d2), cd2cp = Math.cos(d2) * cmat[2], sd = sd2 * cmat[3] - cd2cp * Math.cos(a2);
      return L.latLng(
        Math.asin(sd) * invdeg,
        ((Math.atan2(cd2cp * Math.sin(a2), sd2 - sd * cmat[3]) + cmat[0]) * invdeg + 360) % 360
      );
    },
    eqToCelSys: function(latlng) {
      const cmat = this.projparam._celsysmat, deg = Math.PI / 180, invdeg = 180 / Math.PI, a = latlng.lng * deg - cmat[0], sd = Math.sin(latlng.lat * deg), cdcp = Math.cos(latlng.lat * deg) * cmat[2], sd2 = sd * cmat[3] + cdcp * Math.cos(a);
      return L.latLng(
        Math.asin(sd2) * invdeg,
        ((Math.atan2(cdcp * Math.sin(a), sd2 * cmat[3] - sd) + cmat[1]) * invdeg + 360) % 360
      );
    },
    _getCenter(proj2) {
      const projparam2 = this.projparam, detslice = projparam2.detslice;
      return detslice ? proj2.project(
        this.unproject((0, import_leaflet24.point)(detslice[0][0], detslice[1][0]))
      )._add(proj2.project(
        this.unproject((0, import_leaflet24.point)(detslice[0][1], detslice[1][1]))
      ))._divideBy(2) : (0, import_leaflet24.point)(
        (projparam2.naxis.x + 1) / 2,
        (projparam2.naxis.y + 1) / 2
      );
    },
    _natpole: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam, natpole = (0, import_leaflet24.latLng)(90, 180);
      if (projparam2._natrval.lat === 90) {
        if (projparam2.natpole.lng === 999) {
          natpole.lng = 180;
        }
        natpole.lat = projparam2.crval.lat;
      } else if (projparam2.natpole.lng === 999) {
        natpole.lng = projparam2.crval.lat < projparam2._natrval.lat ? 180 : 0;
      }
      return natpole;
    },
    _cpole: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam, dphip = projparam2._natpole.lng - projparam2._natrval.lng, cdphip = Math.cos(dphip * deg), sdphip = Math.sin(dphip * deg), ct0 = Math.cos(projparam2._natrval.lat * deg), st0 = Math.sin(projparam2._natrval.lat * deg), cd0 = Math.cos(projparam2.crval.lat * deg), sd0 = Math.sin(projparam2.crval.lat * deg), ddeltap = Math.acos(sd0 / Math.sqrt(1 - ct0 * ct0 * sdphip * sdphip)) / deg;
      let deltap = Math.atan2(st0, ct0 * cdphip) / deg, deltap1 = deltap + ddeltap, deltap2 = deltap - ddeltap;
      if (deltap1 < -180) {
        deltap1 += 360;
      } else if (deltap1 > 180) {
        deltap1 -= 360;
      }
      if (deltap2 < -180) {
        deltap2 += 360;
      } else if (deltap2 > 180) {
        deltap2 -= 360;
      }
      if (deltap1 > 90) {
        deltap = deltap2;
      } else if (deltap2 < -90) {
        deltap = deltap1;
      } else {
        deltap = Math.abs(deltap1 - projparam2._natpole.lat) < Math.abs(deltap2 - projparam2._natpole.lat) ? deltap1 : deltap2;
      }
      const alphap = Math.abs(projparam2.crval.lat) === 90 ? projparam2.crval.lng : deltap === 90 ? projparam2.crval.lng + projparam2._natpole.lng - projparam2._natrval.lng - 180 : deltap === -90 ? projparam2.crval.lng - projparam2._natpole.lng + projparam2._natrval.lng : projparam2.crval.lng - Math.atan2(
        sdphip * ct0 / cd0,
        (st0 - Math.sin(deltap * deg) * sd0) / (Math.cos(deltap * deg) * cd0)
      ) / deg;
      return (0, import_leaflet24.latLng)(deltap, alphap);
    },
    _phiThetaToRADec: function(phiTheta) {
      const projparam2 = this.projparam, deg = Math.PI / 180, rad = 180 / Math.PI, t = phiTheta.lat * deg, ct = Math.cos(t), st = Math.sin(t), dp = projparam2._cpole.lat * deg, cdp = Math.cos(dp), sdp = Math.sin(dp), dphi = (phiTheta.lng - projparam2._natpole.lng) * deg, cdphi = Math.cos(dphi);
      let asinarg = st * sdp + ct * cdp * cdphi;
      if (asinarg > 1) {
        asinarg = 1;
      } else if (asinarg < -1) {
        asinarg = -1;
      }
      return (0, import_leaflet24.latLng)(
        Math.asin(asinarg) * rad,
        projparam2._cpole.lng + Math.atan2(
          -ct * Math.sin(dphi),
          st * cdp - ct * sdp * cdphi
        ) * rad
      );
    },
    _raDecToPhiTheta: function(raDec) {
      const projparam2 = this.projparam, deg = Math.PI / 180, rad = 180 / Math.PI, da = (raDec.lng - projparam2._cpole.lng) * deg, cda = Math.cos(da), sda = Math.sin(da), d2 = raDec.lat * deg, cd = Math.cos(d2), sd = Math.sin(d2), dp = projparam2._cpole.lat * deg, cdp = Math.cos(dp), sdp = Math.sin(dp), asinarg = sd * sdp + cd * cdp * cda, phitheta = (0, import_leaflet24.latLng)(
        Math.asin(asinarg > 1 ? 1 : asinarg < -1 ? -1 : asinarg) * rad,
        projparam2._natpole.lng + Math.atan2(
          -cd * sda,
          sd * cdp - cd * sdp * cda
        ) * rad
      );
      if (phitheta.lng > 180) {
        phitheta.lng -= 360;
      } else if (phitheta.lng < -180) {
        phitheta.lng += 360;
      }
      return phitheta;
    },
    _pixToRed: function(pix) {
      const projparam2 = this.projparam, cd = projparam2.cd, red = pix.subtract(projparam2.crpix);
      return (0, import_leaflet24.point)(
        red.x * cd[0][0] + red.y * cd[0][1],
        red.x * cd[1][0] + red.y * cd[1][1]
      );
    },
    _redToPix: function(red) {
      const projparam2 = this.projparam, cdinv = projparam2._cdinv;
      return (0, import_leaflet24.point)(
        red.x * cdinv[0][0] + red.y * cdinv[0][1],
        red.x * cdinv[1][0] + red.y * cdinv[1][1]
      ).add(projparam2.crpix);
    },
    _invertCD: function(cd) {
      const detinv = 1 / (cd[0][0] * cd[1][1] - cd[0][1] * cd[1][0]);
      return [
        [cd[1][1] * detinv, -cd[0][1] * detinv],
        [-cd[1][0] * detinv, cd[0][0] * detinv]
      ];
    }
  });

  // js/crs/Conical.js
  Conical = Projection.extend({
    _redToPhiR: function(red) {
      const deg = Math.PI / 180, projparam2 = this.projparam, dy = projparam2._y0 - red.y, rTheta = projparam2._sthetaA * Math.sqrt(red.x * red.x + dy * dy);
      return (0, import_leaflet25.latLng)(
        rTheta,
        Math.atan2(red.x / rTheta, dy / rTheta) / projparam2._c / deg
      );
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180, p = this.projparam._c * phiR.lng * deg;
      return (0, import_leaflet25.point)(
        phiR.lat * Math.sin(p),
        this.projparam._y0 - phiR.lat * Math.cos(p)
      );
    }
  });
  var COE = Conical.extend({
    _projInit: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._thetaA = projparam2.pv[1][1];
      projparam2._eta = projparam2.pv[1][2];
      projparam2._sthetaA = projparam2._thetaA >= 0 ? 1 : -1;
      const theta1 = projparam2._thetaA - projparam2._eta, theta2 = projparam2._thetaA + projparam2._eta, s1 = Math.sin(theta1 * deg), s2 = Math.sin(theta2 * deg);
      projparam2._gamma = s1 + s2;
      projparam2._s1s2p1 = s1 * s2 + 1;
      projparam2._c = projparam2._gamma / 2;
      projparam2._y0 = 2 / projparam2._gamma * Math.sqrt(projparam2._s1s2p1 - projparam2._gamma * Math.sin(projparam2._thetaA * deg)) / deg;
      projparam2._natrval = (0, import_leaflet25.latLng)(projparam2._thetaA, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _rToTheta: function(r) {
      const deg = Math.PI / 180, gamma = this.projparam._gamma;
      let sinarg = this.projparam._s1s2p1 / gamma - gamma * r * r * deg * deg / 4;
      if (sinarg < -1) {
        sinarg = -1;
      } else if (sinarg > 1) {
        sinarg = 1;
      }
      return Math.asin(sinarg) / deg;
    },
    _thetaToR: function(theta) {
      const deg = Math.PI / 180, gamma = this.projparam._gamma;
      return 2 / gamma * Math.sqrt(this.projparam._s1s2p1 - gamma * Math.sin(theta * deg)) / deg;
    }
  });

  // js/crs/Cylindrical.js
  var import_leaflet26 = __toESM(require_leaflet_src());
  Cylindrical = Projection.extend({
    _projInit: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._lambda = projparam2.pv[1][1];
      if (projparam2._lambda === 0) {
        projparam2._lambda = 1;
      }
      projparam2._natrval = (0, import_leaflet26.latLng)(0, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _rToTheta: function(r) {
      return r;
    },
    _thetaToR: function(theta) {
      return theta;
    }
  });
  var CAR = Cylindrical.extend({
    _redToPhiR: function(red) {
      return (0, import_leaflet26.latLng)(red.y, red.x);
    },
    _phiRToRed: function(phiR) {
      return (0, import_leaflet26.point)(phiR.lng, phiR.lat);
    }
  });
  var CEA = Cylindrical.extend({
    _redToPhiR: function(red) {
      const deg = Math.PI / 180, slat = red.y * this.projparam._lambda * deg;
      return (0, import_leaflet26.latLng)(slat > -1 ? slat < 1 ? Math.asin(slat) / deg : 90 : -90, red.x);
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180;
      return (0, import_leaflet26.point)(
        phiR.lng,
        Math.sin(phiR.lat * deg) / (this.projparam._lambda * deg)
      );
    }
  });

  // js/crs/Zenithal.js
  var import_leaflet27 = __toESM(require_leaflet_src());
  Zenithal = Projection.extend({
    _projInit: function() {
      const projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._natrval = (0, import_leaflet27.latLng)(90, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _redToPhiR: function(red) {
      return (0, import_leaflet27.latLng)(
        Math.sqrt(red.x * red.x + red.y * red.y),
        Math.atan2(red.x, -red.y) * 180 / Math.PI
      );
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180, p = phiR.lng * deg;
      return new import_leaflet27.Point(phiR.lat * Math.sin(p), -phiR.lat * Math.cos(p));
    }
  });
  var TAN = Zenithal.extend({
    code: "TAN",
    _rToTheta: function(r) {
      return Math.atan2(180, Math.PI * r) * 180 / Math.PI;
    },
    _thetaToR: function(theta) {
      return Math.tan((90 - theta) * Math.PI / 180) * 180 / Math.PI;
    }
  });
  var ZEA = Zenithal.extend({
    code: "ZEA",
    _rToTheta: function(r) {
      const rr = r * Math.PI / 360;
      if (Math.abs(rr) < 1) {
        return 90 - 2 * Math.asin(rr) * 180 / Math.PI;
      } else {
        return 90;
      }
    },
    _thetaToR: function(theta) {
      return Math.sin((90 - theta) * Math.PI / 360) * 360 / Math.PI;
    }
  });

  // js/crs/Pixel.js
  var import_leaflet28 = __toESM(require_leaflet_src());
  var Pixel = Projection.extend({
    code: "PIX",
    _projInit: function() {
      const projparam2 = this.projparam;
      if (!options.crval) {
        projparam2.crval = (0, import_leaflet28.latLng)(
          (projparam2.naxis.y + 1) / 2,
          (projparam2.naxis.x + 1) / 2
        );
      }
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._cpole = projparam2.crval;
      this.bounds = (0, import_leaflet28.bounds)(
        [0.5, this.projparam.naxis.y - 0.5],
        [this.projparam.naxis.x - 0.5, 0.5]
      );
      projparam2._pixelFlag = true;
      projparam2._infinite = false;
    },
    project: function(latlng) {
      return (0, import_leaflet28.point)(latlng.lng, latlng.lat);
    },
    unproject: function(point7) {
      return (0, import_leaflet28.latLng)(point7.y, point7.x);
    }
  });

  // js/crs/WCS.js
  CRSclass = import_leaflet29.Class.extend(import_leaflet29.CRS);
  var WCS = CRSclass.extend({
    code: "WCS",
    options: {
      nzoom: 9,
      nativeCelSys: false
    },
    initialize: function(header, images2, options2) {
      const nimages = images2.length;
      options2 = import_leaflet29.Util.setOptions(this, options2);
      this.nzoom = options2.nzoom;
      this.projection = this.getProjection(header, options2);
      if (nimages > 1) {
        this.projections = new Array(nimages);
        for (const [i2, image] of images2.entries()) {
          var proj2 = this.getProjection(
            image.header,
            {
              nativeCelSys: options2.nativeCelSys,
              dataslice: image.dataslice,
              detslice: image.detslice
            }
          );
          if (proj2.name === "") {
            proj2.name = "#" + str(i2 + 1);
          }
          proj2.centerPnt = proj2._getCenter(this.projection);
          this.projections[i2] = proj2;
        }
        this.latLngToPoint = this.multiLatLngToPoint;
        this.pointToLatLng = this.multiPointToLatLng;
        this.project = this.multiProject;
        this.unproject = this.multiUnproject;
      }
      this.naxis = this.projection.projparam.naxis;
      this.centerLatLng = this.projection.unproject(
        this.projection._getCenter(this.projection)
      );
      this.wrapLng = [0.5, this.naxis.x - 0.5];
      this.wrapLat = [this.naxis.y - 0.5, 0.5];
      this.transformation = new import_leaflet29.Transformation(
        1,
        -0.5,
        -1,
        this.naxis.y + 0.5
      );
      this.code += ":" + this.projection.code;
      this.equatorialFlag = this.projection.equatorialFlag;
      this.celSysCode = this.projection.projparam._celsyscode;
      this.pixelFlag = this.projection.projparam._pixelFlag;
      this.infinite = this.projection.projparam._infinite;
    },
    multiLatLngToPoint(latlng, zoom) {
      const projectedPoint = this.multiProject(latlng), scale2 = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale2);
    },
    multiPointToLatLng(pnt, zoom) {
      const scale2 = this.scale(zoom), untransformedPoint = this.transformation.untransform(pnt, scale2);
      return this.multiUnproject(untransformedPoint);
    },
    multiProject(latlng) {
      const pnt = this.projection.project(latlng);
      let dc = 1e30, pc = -1;
      for (var p in this.projections) {
        var pntc = this.projections[p].centerPnt;
        if ((d = pnt.distanceTo(pntc)) < dc) {
          pc = p;
          dc = d;
        }
      }
      return this.projections[pc].project(latlng);
    },
    multiUnproject(pnt) {
      let dc = 1e30, pc = -1;
      for (var p in this.projections) {
        var pntc = this.projections[p].centerPnt;
        if ((d = pnt.distanceTo(pntc)) < dc) {
          pc = p;
          dc = d;
        }
      }
      return this.projections[pc].unproject(pnt);
    },
    multiLatLngToIndex(latlng) {
      const pnt = this.projection.project(latlng);
      let dc = 1e30, pc = -1;
      for (var p in this.projections) {
        var pntc = this.projections[p].centerPnt;
        if ((d = pnt.distanceTo(pntc)) < dc) {
          pc = p;
          dc = d;
        }
      }
      return pc;
    },
    getProjection: function(header, options2) {
      const ctype1 = header["CTYPE1"] || "PIXEL";
      switch (ctype1.substr(5, 3)) {
        case "ZEA":
          proj = new ZEA(header, options2);
          break;
        case "TAN":
          proj = new TAN(header, options2);
          break;
        case "CAR":
          proj = new CAR(header, options2);
          break;
        case "CEA":
          proj = new CEA(header, options2);
          break;
        case "COE":
          proj = new COE(header, options2);
          break;
        default:
          proj = new Pixel(header, options2);
          break;
      }
      return proj;
    },
    scale: function(zoom) {
      return Math.pow(2, zoom - this.nzoom + 1);
    },
    zoom: function(scale2) {
      return Math.log(scale2) / Math.LN2 + this.nzoom - 1;
    },
    rawPixelScale: function(latlng) {
      const p0 = this.projection.project(latlng), latlngdx = this.projection.unproject(p0.add([10, 0])), latlngdy = this.projection.unproject(p0.add([0, 10]));
      let dlngdx = latlngdx.lng - latlng.lng, dlngdy = latlngdy.lng - latlng.lng;
      if (dlngdx > 180) {
        dlngdx -= 360;
      } else if (dlngdx < -180) {
        dlngdx += 360;
      }
      if (dlngdy > 180) {
        dlngdy -= 360;
      } else if (dlngdy < -180) {
        dlngdy += 360;
      }
      return 0.1 * Math.sqrt(Math.abs(dlngdx * (latlngdy.lat - latlng.lat) - dlngdy * (latlngdx.lat - latlng.lat)) * Math.cos(latlng.lat * Math.PI / 180));
    },
    pixelScale: function(zoom, latlng) {
      return this.rawPixelScale(latlng) / this.scale(zoom);
    },
    fovToZoom: function(map2, fov, latlng) {
      const size = map2.getSize();
      let scale2 = this.rawPixelScale(latlng);
      if (fov < scale2) {
        fov = scale2;
      }
      scale2 *= Math.sqrt(size.x * size.x + size.y * size.y);
      return fov > 0 ? this.zoom(scale2 / fov) : this.nzoom - 1;
    },
    zoomToFov: function(map2, zoom, latlng) {
      const size = map2.getSize(), scale2 = this.rawPixelScale(latlng) * Math.sqrt(size.x * size.x + size.y * size.y), zscale = this.scale(zoom);
      return zscale > 0 ? scale2 / zscale : scale2;
    },
    distance: function(latlng1, latlng2) {
      const rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(
        (latlng2.lng - latlng1.lng) * rad
      );
      return 180 / Math.PI * Math.acos(Math.min(a, 1));
    },
    parseCoords: function(str2) {
      let latlng = this.hmsDMSToLatLng(str2);
      if (typeof latlng === "undefined") {
        let result = /(?:%J\s|^)([-+]?\d+\.?\d*)\s*[,\s]+\s*([-+]?\d+\.?\d*)/g.exec(str2);
        if (result && result.length >= 3) {
          latlng = (0, import_leaflet29.latLng)(Number(result[2]), Number(result[1]));
        }
      }
      if (latlng) {
        if (this.projection.celSysConvFlag) {
          latlng = this.projection.eqToCelSys(latlng);
        }
        return latlng;
      } else {
        return void 0;
      }
    },
    latLngToHMSDMS: function(latlng) {
      let lng = (latlng.lng + 360) / 360;
      lng = (lng - Math.floor(lng)) * 24;
      let h = Math.floor(lng), mf = (lng - h) * 60, m = Math.floor(mf), sf = (mf - m) * 60;
      if (sf >= 60) {
        m++;
        sf = 0;
      }
      if (m === 60) {
        h++;
        m = 0;
      }
      const str2 = (h < 10 ? "0" : "") + h.toString() + ":" + (m < 10 ? "0" : "") + m.toString() + ":" + (sf < 10 ? "0" : "") + sf.toFixed(3), lat = Math.abs(latlng.lat), sgn = latlng.lat < 0 ? "-" : "+", d2 = Math.floor(lat);
      mf = (lat - d2) * 60;
      m = Math.floor(mf);
      sf = (mf - m) * 60;
      if (sf >= 60) {
        m++;
        sf = 0;
      }
      if (m === 60) {
        h++;
        m = 0;
      }
      return str2 + " " + sgn + (d2 < 10 ? "0" : "") + d2.toString() + ":" + (m < 10 ? "0" : "") + m.toString() + ":" + (sf < 10 ? "0" : "") + sf.toFixed(2);
    },
    hmsDMSToLatLng: function(str2) {
      var result;
      result = /^\s*(\d+)[h:](\d+)[m':](\d+\.?\d*)[s"]?\s*,?\s*([-+]?)(\d+)[d:](\d+)[m':](\d+\.?\d*)[s"]?/g.exec(str2);
      if (result && result.length >= 8) {
        const sgn = Number(result[4] + "1");
        return (0, import_leaflet29.latLng)(
          sgn * (Number(result[5]) + Number(result[6]) / 60 + Number(result[7]) / 3600),
          Number(result[1]) * 15 + Number(result[2]) / 4 + Number(result[3]) / 240
        );
      } else {
        return void 0;
      }
    },
    _deltaLng: function(latLng11, latLng0) {
      const dlng = latLng11.lng - latLng0.lng;
      return dlng > 180 ? dlng - 360 : dlng < -180 ? dlng + 360 : dlng;
    }
  });
  var wcs = function(header, images2, options2) {
    return new WCS(header, images2, options2);
  };

  // js/layer/index.js
  var layer_exports = {};
  __export(layer_exports, {
    VTileLayer: () => VTileLayer,
    vTileLayer: () => vTileLayer
  });

  // js/layer/VTileLayer.js
  var import_leaflet30 = __toESM(require_leaflet_src());
  var VTileLayer = import_leaflet30.TileLayer.extend({
    options: {
      title: null,
      crs: null,
      nativeCelSys: false,
      center: null,
      fov: null,
      minZoom: 0,
      maxZoom: null,
      maxNativeZoom: 18,
      noWrap: true,
      contrast: 1,
      colorSat: 1,
      gamma: null,
      cMap: "grey",
      invertCMap: false,
      quality: null,
      mixingMode: "color",
      channelColors: [],
      channelLabels: [],
      channelLabelMatch: ".*",
      channelUnits: [],
      minMaxValues: [],
      defaultChannel: 0,
      sesameURL: "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame",
      credentials: null
    },
    visioDefault: {
      contrast: 1,
      gamma: 2.2,
      cMap: "grey",
      invertCMap: false,
      minValue: [],
      maxValue: [],
      channelColors: [
        [""],
        ["#FFFFFF"],
        ["#00BAFF", "#FFBA00"],
        ["#0000FF", "#00BA00", "#FF0000"],
        ["#0000E0", "#00BA88", "#88BA00", "#E00000"],
        ["#0000CA", "#007BA8", "#00CA00", "#A87B00", "#CA0000"],
        ["#0000BA", "#00719B", "#009B71", "#719B00", "#9B7100", "#BA0000"]
      ],
      quality: 90
    },
    initialize: function(url, options2) {
      this.type = "tilelayer";
      this._url = url.replace(/\&.*$/g, "");
      options2 = import_leaflet30.Util.setOptions(this, options2);
      if (options2.detectRetina && L.Browser.retina && options2.maxZoom > 0) {
        options2.tileSize = Math.floor(options2.tileSize / 2);
        options2.zoomOffset++;
        options2.minZoom = Math.max(0, options2.minZoom);
        options2.maxZoom--;
      }
      if (typeof options2.subdomains === "string") {
        options2.subdomains = options2.subdomains.split("");
      }
      this.tileSize = { x: 256, y: 256 };
      this.visio = {
        imageSize: [[this.tileSize]],
        gridSize: [{ x: 1, y: 1 }],
        bpp: 8,
        mixingMode: options2.mixingMode,
        channel: 0,
        nChannel: 1,
        minZoom: options2.minZoom,
        maxZoom: options2.maxZoom,
        contrast: options2.contrast,
        colorSat: options2.colorSat,
        gamma: options2.gamma,
        cMap: options2.cMap,
        invertCMap: options2.invertCMap,
        minValue: [0],
        maxValue: [255],
        mix: [[]],
        rgb: [],
        channelLabels: [],
        channelFlags: [],
        channelUnits: [],
        quality: options2.quality
      };
      this._title = options2.title ? options2.title : this._url.match(/^.*\/(.*)\..*$/)[1];
      this.getMetaData(this._url);
      if (!import_leaflet30.Browser.android) {
        this.on("tileunload", this._onTileRemove);
      }
      return this;
    },
    getMetaData: async function(url) {
      const res = await fetch(url + "&INFO", { method: "GET" });
      const meta = await res.json();
      if (res.status == 200 && meta["type"] == "visiomatic") {
        const options2 = this.options, visio = this.visio, visioDefault = this.visioDefault, maxsize = { x: meta.full_size[0], y: meta.full_size[1] };
        this.tileSize = { x: meta.tile_size[0], y: meta.tile_size[1] };
        options2.tileSize = this.tileSize.x;
        visio.maxZoom = meta.tile_levels - 1;
        if (visio.minZoom > options2.minZoom) {
          options2.minZoom = visio.minZoom;
        }
        if (!options2.maxZoom) {
          options2.maxZoom = visio.maxZoom + 6;
        }
        options2.maxNativeZoom = visio.maxZoom;
        for (let z = 0; z <= visio.maxZoom; z++) {
          visio.imageSize[z] = {
            x: Math.floor(maxsize.x / Math.pow(2, visio.maxZoom - z)),
            y: Math.floor(maxsize.y / Math.pow(2, visio.maxZoom - z))
          };
          visio.gridSize[z] = {
            x: Math.ceil(visio.imageSize[z].x / this.tileSize.x),
            y: Math.ceil(visio.imageSize[z].y / this.tileSize.y)
          };
        }
        for (let z = visio.maxZoom; z <= options2.maxZoom; z++) {
          visio.gridSize[z] = visio.gridSize[visio.maxZoom];
        }
        visio.bpp = meta.bits_per_channel;
        if (meta.gamma) {
          visioDefault.gamma = meta.gamma;
        }
        if (!visio.gamma) {
          visio.gamma = visioDefault.gamma;
        }
        nchannel = visio.nChannel = meta.channels;
        if (meta.quality) {
          visioDefault.quality = meta.quality;
        }
        if (!visio.quality) {
          visio.quality = visioDefault.quality;
        }
        images = meta.images;
        for (let c3 = 0; c3 < nchannel; c3++) {
          visioDefault.minValue[c3] = images[0].min_max[c3][0];
          visioDefault.maxValue[c3] = images[0].min_max[c3][1];
        }
        const minmax = options2.minMaxValues;
        if (minmax.length) {
          for (let c3 = 0; c3 < nchannel; c3++) {
            if (minmax[c3] !== void 0 && minmax[c3].length) {
              visio.minValue[c3] = minmax[c3][0];
              visio.maxValue[c3] = minmax[c3][1];
            } else {
              visio.minValue[c3] = visioDefault.minValue[c3];
              visio.maxValue[c3] = visioDefault.maxValue[c3];
            }
          }
        } else {
          for (let c3 = 0; c3 < nchannel; c3++) {
            visio.minValue[c3] = visioDefault.minValue[c3];
            visio.maxValue[c3] = visioDefault.maxValue[c3];
          }
        }
        visio.channel = options2.defaultChannel;
        const inlabels = options2.channelLabels, ninlabel = inlabels.length, labels = visio.channelLabels, inunits = options2.channelUnits, ninunits = inunits.length, units = visio.channelUnits, key = VUtil.readFITSKey;
        let label = "Channel";
        if (nchannel === 1 && (filter = images[0].header["FILTER"])) {
          label = filter;
        }
        for (let c3 = 0; c3 < nchannel; c3++) {
          if (c3 < ninlabel) {
            labels[c3] = inlabels[c3];
          } else {
            labels[c3] = nchannel > 1 ? "Channel #" + (c3 + 1).toString() : filter;
          }
        }
        for (const c3 in inunits) {
          units[c3] = inunits[c3];
        }
        for (let c3 = ninunits; c3 < nchannel; c3++) {
          units[c3] = "ADUs";
        }
        const mix = visio.mix, colors = options2.channelColors, rgb2 = visio.rgb, re = new RegExp(options2.channelLabelMatch), channelflags = visio.channelFlags;
        let cc = 0, nchanon = 0;
        for (var c2 = 0; c2 < nchannel; c2++) {
          channelflags[c2] = re.test(labels[c2]);
          if (channelflags[c2]) {
            nchanon++;
          }
        }
        if (nchanon >= visioDefault.channelColors.length) {
          nchanon = visioDefault.channelColors.length - 1;
        }
        if (colors.length) {
          for (const c3 in colors) {
            rgb2[c3] = rgb(colors[c3][0], colors[c3][1], colors[c3][2]);
            mix[c3] = [];
            this.rgbToMix(c3);
          }
        } else {
          rgb2[0] = rgb(visioDefault.channelColors[3][0]);
          rgb2[Math.floor(nchannel / 2)] = rgb(visioDefault.channelColors[3][1]);
          rgb2[nchannel - 1] = rgb(visioDefault.channelColors[3][2]);
        }
        if (options2.bounds) {
          options2.bounds = (0, import_leaflet30.latLngBounds)(options2.bounds);
        }
        this.wcs = options2.crs ? options2.crs : new WCS(
          meta.header,
          meta.images,
          {
            nativeCelSys: this.options.nativeCelSys,
            nzoom: visio.maxZoom + 1
          }
        );
        visio.metaReady = true;
        this.fire("metaload");
      } else {
        alert("There was a problem with the VisiOmatic metadata request.");
      }
    },
    rgbToMix: function(channel, rgb2) {
      const visio = this.visio;
      if (rgb2) {
        visio.rgb[channel] = rgb2.clone();
      } else if (rgb2 === false) {
        delete visio.rgb[channel];
        delete visio.mix[channel];
        return;
      } else {
        rgb2 = visio.rgb[channel];
      }
      const cr = this._gammaCorr(rgb2.r), cg = this._gammaCorr(rgb2.g), cb = this._gammaCorr(rgb2.b), lum = (cr + cg + cb) / 3, alpha = visio.colorSat / 3;
      visio.mix[channel] = [];
      visio.mix[channel][0] = lum + alpha * (2 * cr - cg - cb);
      visio.mix[channel][1] = lum + alpha * (2 * cg - cr - cb);
      visio.mix[channel][2] = lum + alpha * (2 * cb - cr - cg);
      return;
    },
    updateMono: function() {
      this.visio.mode = "mono";
    },
    updateMix: function() {
      const visio = this.visio, nchannel2 = visio.nChannel;
      visio.mode = "color";
      for (const c2 in visio.rgb) {
        this.rgbToMix(c2, visio.rgb[c2]);
      }
    },
    _gammaCorr: function(val) {
      return val > 0 ? Math.pow(val, this.visio.gamma) : 0;
    },
    _readVisioKey: function(str2, keyword, regexp) {
      const reg = new RegExp(keyword + ":" + regexp);
      return reg.exec(str2);
    },
    addTo: function(map2) {
      if (this.visio.metaReady) {
        this._addToMap(map2);
      } else {
        this._loadActivity = import_leaflet30.DomUtil.create(
          "div",
          "visiomatic-layer-activity-",
          map2._controlContainer
        );
        this.once("metaload", function() {
          this._addToMap(map2);
          map2._controlContainer.removeChild(this._loadActivity);
        }, this);
      }
      return this;
    },
    _addToMap: function(map2) {
      const newcrs = this.wcs, curcrs = map2.options.crs, prevcrs = map2._prevcrs, maploadedflag = map2._loaded;
      var zoom, center;
      if (maploadedflag) {
        curcrs._prevLatLng = map2.getCenter();
        curcrs._prevZoom = map2.getZoom();
      }
      map2._prevcrs = map2.options.crs = newcrs;
      import_leaflet30.TileLayer.prototype.addTo.call(this, map2);
      if (prevcrs && newcrs !== curcrs && maploadedflag && newcrs.pixelFlag === curcrs.pixelFlag) {
        center = curcrs._prevLatLng;
        zoom = curcrs._prevZoom;
        const prevpixscale = prevcrs.pixelScale(zoom, center), newpixscale = newcrs.pixelScale(zoom, center);
        if (prevpixscale > 1e-20 && newpixscale > 1e-20) {
          zoom += Math.round(Math.LOG2E * Math.log(newpixscale / prevpixscale));
        }
      } else if (newcrs._prevLatLng) {
        center = newcrs._prevLatLng;
        zoom = newcrs._prevZoom;
      } else if (this.options.center) {
        const latlng = typeof this.options.center === "string" ? newcrs.parseCoords(decodeURI(this.options.center)) : this.options.center;
        if (latlng) {
          if (this.options.fov) {
            zoom = newcrs.fovToZoom(map2, this.options.fov, latlng);
          }
          map2.setView(latlng, zoom, { reset: true, animate: false });
        } else {
          VUtil.requestURL(
            this.options.sesameURL + "/-oI/A?" + this.options.center,
            "getting coordinates for " + this.options.center,
            function(_this, httpRequest) {
              if (httpRequest.readyState === 4) {
                if (httpRequest.status === 200) {
                  const str2 = httpRequest.responseText, newLatlng = newcrs.parseCoords(str2);
                  if (newLatlng) {
                    if (_this.options.fov) {
                      zoom = newcrs.fovToZoom(
                        map2,
                        _this.options.fov,
                        newLatlng
                      );
                    }
                    map2.setView(
                      newLatlng,
                      zoom,
                      { reset: true, animate: false }
                    );
                  } else {
                    map2.setView(
                      newcrs.crval,
                      zoom,
                      { reset: true, animate: false }
                    );
                    alert(str2 + ": Unknown location");
                  }
                } else {
                  map2.setView(
                    newcrs.crval,
                    zoom,
                    { reset: true, animate: false }
                  );
                  alert("There was a problem with the request to the Sesame service at CDS");
                }
              }
            },
            this,
            10
          );
        }
      } else {
        map2.setView(
          newcrs.centerLatLng,
          zoom,
          { reset: true, animate: false }
        );
      }
    },
    _isValidTile: function(coords2) {
      const crs = this._map.options.crs;
      if (!crs.infinite) {
        const bounds3 = this._globalTileRange;
        if (!crs.wrapLng && (coords2.x < bounds3.min.x || coords2.x > bounds3.max.x) || !crs.wrapLat && (coords2.y < bounds3.min.y || coords2.y > bounds3.max.y)) {
          return false;
        }
      }
      const z = this._getZoomForUrl(), wcoords = coords2.clone();
      this._wrapCoords(wcoords);
      if (wcoords.x < 0 || wcoords.x >= this.visio.gridSize[z].x || wcoords.y < 0 || wcoords.y >= this.visio.gridSize[z].y) {
        return false;
      }
      if (!this.options.bounds) {
        return true;
      }
      return (0, import_leaflet30.latLngBounds)(this.options.bounds).intersects(
        this._tileCoordsToBounds(coords2)
      );
    },
    createTile: function(coords2, done) {
      const tile2 = import_leaflet30.TileLayer.prototype.createTile.call(this, coords2, done);
      tile2.coords = coords2;
      return tile2;
    },
    getTileUrl: function(coords2) {
      const visio = this.visio, visioDefault = this.visioDefault, z = this._getZoomForUrl();
      let str2 = this._url;
      if (visio.cMap !== visioDefault.cMap) {
        str2 += "&CMP=" + visio.cMap;
      }
      if (visio.invertCMap !== visioDefault.invertCMap) {
        str2 += "&INV";
      }
      if (visio.contrast !== visioDefault.contrast) {
        str2 += "&CNT=" + visio.contrast.toString();
      }
      if (visio.gamma !== visioDefault.gamma) {
        str2 += "&GAM=" + (1 / visio.gamma).toFixed(4);
      }
      const nchannel2 = visio.nChannel, mix = visio.mix;
      if (visio.mode === "color") {
        for (let c2 = 0; c2 < visio.nChannel; c2++) {
          if (visio.minValue[c2] !== visioDefault.minValue[c2] || visio.maxValue[c2] !== visioDefault.maxValue[c2]) {
            str2 += "&MINMAX=" + (c2 + 1).toString() + ":" + visio.minValue[c2].toString() + "," + visio.maxValue[c2].toString();
          }
        }
        for (const m in mix) {
          str2 += "&MIX=" + (parseInt(m, 10) + 1).toString() + ":";
          for (let n = 0; n < 3; n++) {
            if (n) {
              str2 += ",";
            }
            str2 += mix[m][n].toFixed(3);
          }
        }
      } else {
        const chan = visio.channel;
        let chanp1 = chan + 1;
        if (chanp1 > nchannel2) {
          chanp1 = 1;
        }
        str2 += "&CHAN=" + chanp1.toString();
        if (visio.minValue[chan] !== visioDefault.minValue[chan] || visio.maxValue[chan] !== visioDefault.maxValue[chan]) {
          str2 += "&MINMAX=" + chanp1.toString() + ":" + visio.minValue[chan].toString() + "," + visio.maxValue[chan].toString();
        }
      }
      if (visio.quality !== visioDefault.quality) {
        str2 += "&QLT=" + visio.quality.toString();
      }
      return str2 + "&JTL=" + z.toString() + "," + (coords2.x + visio.gridSize[z].x * coords2.y).toString();
    },
    _initTile: function(tile2) {
      import_leaflet30.DomUtil.addClass(tile2, "leaflet-tile");
      if (this.options.maxNativeZoom && this._tileZoom >= this.options.maxNativeZoom) {
        tile2.style.imageRendering = "pixelated";
      }
      tile2.onselectstart = import_leaflet30.Util.falseFn;
      tile2.onmousemove = import_leaflet30.Util.falseFn;
      if (import_leaflet30.Browser.ielt9 && this.options.opacity < 1) {
        import_leaflet30.DomUtil.setOpacity(tile2, this.options.opacity);
      }
      if (import_leaflet30.Browser.android && !import_leaflet30.Browser.android23) {
        tile2.style.WebkitBackfaceVisibility = "hidden";
      }
    },
    _refreshTileUrl: function(tile2, url) {
      const img = new Image();
      img.onload = function() {
        L.Util.requestAnimFrame(function() {
          tile2.el.src = url;
        });
      };
      img.src = url;
    },
    redraw: function() {
      const wasAnimated = this._map._fadeAnimated;
      this._map._fadeAnimated = false;
      for (var key in this._tiles) {
        tile = this._tiles[key];
        if (tile.current && tile.active) {
          const oldsrc = tile.el.src, newsrc = this.getTileUrl(tile.coords);
          if (oldsrc != newsrc) {
            this._refreshTileUrl(tile, newsrc);
          }
        }
      }
      if (wasAnimated) {
        setTimeout(function() {
          map._fadeAnimated = wasAnimated;
        }, 5e3);
      }
    }
  });
  var vTileLayer = function(url, options2) {
    return new VTileLayer(url, options2);
  };

  // js/VisiomaticGlobal.js
  function getGlobalObject() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("Unable to locate global object.");
  }
  var globalObject = getGlobalObject();
  globalObject.V = Visiomatic_exports;
})();
/* @preserve
 * Leaflet 1.9.3, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */
/*!
 * jQuery JavaScript Library v3.6.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-08-26T17:52Z
 */
