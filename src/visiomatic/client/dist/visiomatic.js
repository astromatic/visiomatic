(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.leaflet = {}));
      })(exports, function(exports2) {
        "use strict";
        var version3 = "1.9.4";
        function extend4(dest) {
          var i2, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i2 in src) {
              dest[i2] = src[i2];
            }
          }
          return dest;
        }
        var create$2 = Object.create || function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn2, obj) {
          var slice = Array.prototype.slice;
          if (fn2.bind) {
            return fn2.bind.apply(fn2, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn2.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle(fn2, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn2.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x, range, includeMax) {
          var max = range[1], min = range[0], d2 = max - min;
          return x === max && includeMax ? x : ((x - min) % d2 + d2) % d2 + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow) / pow;
        }
        function trim(str2) {
          return str2.trim ? str2.trim() : str2.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str2) {
          return trim(str2).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i2 in options) {
            obj.options[i2] = options[i2];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i2 in obj) {
            params.push(encodeURIComponent(uppercase ? i2.toUpperCase() : i2) + "=" + encodeURIComponent(obj[i2]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str2, data) {
          return str2.replace(templateRe, function(str3, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str3);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray2 = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array, el) {
          for (var i2 = 0; i2 < array.length; i2++) {
            if (array[i2] === el) {
              return i2;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn2) {
          var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn2, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame2(fn2, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn2.call(context);
          } else {
            return requestFn.call(window, bind(fn2, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util24 = {
          __proto__: null,
          extend: extend4,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray: isArray2,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame: requestAnimFrame2,
          cancelAnimFrame
        };
        function Class4() {
        }
        Class4.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i2 in this) {
            if (Object.prototype.hasOwnProperty.call(this, i2) && i2 !== "prototype" && i2 !== "__super__") {
              NewClass[i2] = this[i2];
            }
          }
          if (props.statics) {
            extend4(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend4.apply(null, [proto].concat(props.includes));
          }
          extend4(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend4(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i3 = 0, len = proto._initHooks.length; i3 < len; i3++) {
              proto._initHooks[i3].call(this);
            }
          };
          return NewClass;
        };
        Class4.include = function(props) {
          var parentOptions = this.prototype.options;
          extend4(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class4.mergeOptions = function(options) {
          extend4(this.prototype.options, options);
          return this;
        };
        Class4.addInitHook = function(fn2) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn2 === "function" ? fn2 : function() {
            this[fn2].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray2(includes) ? includes : [includes];
          for (var i2 = 0; i2 < includes.length; i2++) {
            if (includes[i2] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          on: function(types, fn2, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn2);
              }
            } else {
              types = splitWords(types);
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                this._on(types[i2], fn2, context);
              }
            }
            return this;
          },
          off: function(types, fn2, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn2);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                if (removeAll) {
                  this._off(types[i2]);
                } else {
                  this._off(types[i2], fn2, context);
                }
              }
            }
            return this;
          },
          _on: function(type, fn2, context, _once) {
            if (typeof fn2 !== "function") {
              console.warn("wrong listener type: " + typeof fn2);
              return;
            }
            if (this._listens(type, fn2, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn: fn2, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn2, context) {
            var listeners, i2, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i2 = 0, len = listeners.length; i2 < len; i2++) {
                  listeners[i2].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn2 !== "function") {
              console.warn("wrong listener type: " + typeof fn2);
              return;
            }
            var index3 = this._listens(type, fn2, context);
            if (index3 !== false) {
              var listener = listeners[index3];
              if (this._firingCount) {
                listener.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index3, 1);
            }
          },
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend4({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
                  var l = listeners[i2];
                  var fn2 = l.fn;
                  if (l.once) {
                    this.off(type, fn2, l.ctx);
                  }
                  fn2.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          listens: function(type, fn2, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn2;
            if (typeof fn2 !== "function") {
              propagate = !!fn2;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, fn2, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          _listens: function(type, fn2, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn2) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
              if (listeners[i2].fn === fn2 && listeners[i2].ctx === context) {
                return i2;
              }
            }
            return false;
          },
          once: function(types, fn2, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn2, true);
              }
            } else {
              types = splitWords(types);
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                this._on(types[i2], fn2, context, true);
              }
            }
            return this;
          },
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend4({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented4 = Class4.extend(Events);
        function Point(x, y, round2) {
          this.x = round2 ? Math.round(x) : x;
          this.y = round2 ? Math.round(y) : y;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point.prototype = {
          clone: function() {
            return new Point(this.x, this.y);
          },
          add: function(point8) {
            return this.clone()._add(toPoint(point8));
          },
          _add: function(point8) {
            this.x += point8.x;
            this.y += point8.y;
            return this;
          },
          subtract: function(point8) {
            return this.clone()._subtract(toPoint(point8));
          },
          _subtract: function(point8) {
            this.x -= point8.x;
            this.y -= point8.y;
            return this;
          },
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          scaleBy: function(point8) {
            return new Point(this.x * point8.x, this.y * point8.y);
          },
          unscaleBy: function(point8) {
            return new Point(this.x / point8.x, this.y / point8.y);
          },
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          distanceTo: function(point8) {
            point8 = toPoint(point8);
            var x = point8.x - this.x, y = point8.y - this.y;
            return Math.sqrt(x * x + y * y);
          },
          equals: function(point8) {
            point8 = toPoint(point8);
            return point8.x === this.x && point8.y === this.y;
          },
          contains: function(point8) {
            point8 = toPoint(point8);
            return Math.abs(point8.x) <= Math.abs(this.x) && Math.abs(point8.y) <= Math.abs(this.y);
          },
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x, y, round2) {
          if (x instanceof Point) {
            return x;
          }
          if (isArray2(x)) {
            return new Point(x[0], x[1]);
          }
          if (x === void 0 || x === null) {
            return x;
          }
          if (typeof x === "object" && "x" in x && "y" in x) {
            return new Point(x.x, x.y);
          }
          return new Point(x, y, round2);
        }
        function Bounds2(a, b) {
          if (!a) {
            return;
          }
          var points = b ? [a, b] : a;
          for (var i2 = 0, len = points.length; i2 < len; i2++) {
            this.extend(points[i2]);
          }
        }
        Bounds2.prototype = {
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          getCenter: function(round2) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round2
            );
          },
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          getTopLeft: function() {
            return this.min;
          },
          getBottomRight: function() {
            return this.max;
          },
          getSize: function() {
            return this.max.subtract(this.min);
          },
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds2) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          intersects: function(bounds3) {
            bounds3 = toBounds(bounds3);
            var min = this.min, max = this.max, min2 = bounds3.min, max2 = bounds3.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          overlaps: function(bounds3) {
            bounds3 = toBounds(bounds3);
            var min = this.min, max = this.max, min2 = bounds3.min, max2 = bounds3.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          isValid: function() {
            return !!(this.min && this.max);
          },
          pad: function(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(
              toPoint(min.x - heightBuffer, min.y - widthBuffer),
              toPoint(max.x + heightBuffer, max.y + widthBuffer)
            );
          },
          equals: function(bounds3) {
            if (!bounds3) {
              return false;
            }
            bounds3 = toBounds(bounds3);
            return this.min.equals(bounds3.getTopLeft()) && this.max.equals(bounds3.getBottomRight());
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds2) {
            return a;
          }
          return new Bounds2(a, b);
        }
        function LatLngBounds3(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
            this.extend(latlngs[i2]);
          }
        }
        LatLngBounds3.prototype = {
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng2) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds3) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng2(sw2.lat, sw2.lng);
              this._northEast = new LatLng2(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds3(
              new LatLng2(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng2(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          getCenter: function() {
            return new LatLng2(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          getSouthWest: function() {
            return this._southWest;
          },
          getNorthEast: function() {
            return this._northEast;
          },
          getNorthWest: function() {
            return new LatLng2(this.getNorth(), this.getWest());
          },
          getSouthEast: function() {
            return new LatLng2(this.getSouth(), this.getEast());
          },
          getWest: function() {
            return this._southWest.lng;
          },
          getSouth: function() {
            return this._southWest.lat;
          },
          getEast: function() {
            return this._northEast.lng;
          },
          getNorth: function() {
            return this._northEast.lat;
          },
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng2 || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds3) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          intersects: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds3.getSouthWest(), ne2 = bounds3.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          overlaps: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds3.getSouthWest(), ne2 = bounds3.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          equals: function(bounds3, maxMargin) {
            if (!bounds3) {
              return false;
            }
            bounds3 = toLatLngBounds(bounds3);
            return this._southWest.equals(bounds3.getSouthWest(), maxMargin) && this._northEast.equals(bounds3.getNorthEast(), maxMargin);
          },
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds3) {
            return a;
          }
          return new LatLngBounds3(a, b);
        }
        function LatLng2(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng2.prototype = {
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng2(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c2) {
          if (a instanceof LatLng2) {
            return a;
          }
          if (isArray2(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng2(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng2(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng2(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng2(a, b, c2);
        }
        var CRS2 = {
          latLngToPoint: function(latlng, zoom3) {
            var projectedPoint = this.projection.project(latlng), scale3 = this.scale(zoom3);
            return this.transformation._transform(projectedPoint, scale3);
          },
          pointToLatLng: function(point8, zoom3) {
            var scale3 = this.scale(zoom3), untransformedPoint = this.transformation.untransform(point8, scale3);
            return this.projection.unproject(untransformedPoint);
          },
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          unproject: function(point8) {
            return this.projection.unproject(point8);
          },
          scale: function(zoom3) {
            return 256 * Math.pow(2, zoom3);
          },
          zoom: function(scale3) {
            return Math.log(scale3 / 256) / Math.LN2;
          },
          getProjectedBounds: function(zoom3) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom3), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds2(min, max);
          },
          infinite: false,
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng2(lat, lng, alt);
          },
          wrapLatLngBounds: function(bounds3) {
            var center = bounds3.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds3;
            }
            var sw = bounds3.getSouthWest(), ne = bounds3.getNorthEast(), newSw = new LatLng2(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng2(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds3(newSw, newNe);
          }
        };
        var Earth = extend4({}, CRS2, {
          wrapLng: [-180, 180],
          R: 6371e3,
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c2 = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c2;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d2 = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d2);
            return new Point(
              this.R * latlng.lng * d2,
              this.R * Math.log((1 + sin) / (1 - sin)) / 2
            );
          },
          unproject: function(point8) {
            var d2 = 180 / Math.PI;
            return new LatLng2(
              (2 * Math.atan(Math.exp(point8.y / this.R)) - Math.PI / 2) * d2,
              point8.x * d2 / this.R
            );
          },
          bounds: function() {
            var d2 = earthRadius * Math.PI;
            return new Bounds2([-d2, -d2], [d2, d2]);
          }()
        };
        function Transformation2(a, b, c2, d2) {
          if (isArray2(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c2;
          this._d = d2;
        }
        Transformation2.prototype = {
          transform: function(point8, scale3) {
            return this._transform(point8.clone(), scale3);
          },
          _transform: function(point8, scale3) {
            scale3 = scale3 || 1;
            point8.x = scale3 * (this._a * point8.x + this._b);
            point8.y = scale3 * (this._c * point8.y + this._d);
            return point8;
          },
          untransform: function(point8, scale3) {
            scale3 = scale3 || 1;
            return new Point(
              (point8.x / scale3 - this._b) / this._a,
              (point8.y / scale3 - this._d) / this._c
            );
          }
        };
        function toTransformation(a, b, c2, d2) {
          return new Transformation2(a, b, c2, d2);
        }
        var EPSG3857 = extend4({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale3 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale3, 0.5, -scale3, 0.5);
          }()
        });
        var EPSG900913 = extend4({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str2 = "", i2, j, len, len2, points, p;
          for (i2 = 0, len = rings.length; i2 < len; i2++) {
            points = rings[i2];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p = points[j];
              str2 += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str2 += closed ? Browser4.svg ? "z" : "x" : "";
          }
          return str2 || "M0 0";
        }
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str2) {
          return navigator.userAgent.toLowerCase().indexOf(str2) >= 0;
        }
        var Browser4 = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser4.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser4.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser4.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser4.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i2 in _pointers) {
            e.touches.push(_pointers[i2]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i2;
          for (i2 in event) {
            prop = event[i2];
            newEvent[i2] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e);
            if (path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now = Date.now();
            if (now - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle2(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i2 = 0, len = classes.length; i2 < len; i2++) {
              el.classList.add(classes[i2]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter2 = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter2 = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter2) {
            filter2.Enabled = value !== 100;
            filter2.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i2 = 0; i2 < props.length; i2++) {
            if (props[i2] in style2) {
              return props[i2];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale3) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (Browser4.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale3 ? " scale(" + scale3 + ")" : "");
        }
        function setPosition(el, point8) {
          el._leaflet_pos = point8;
          if (Browser4.any3d) {
            setTransform(el, point8);
          } else {
            el.style.left = point8.x + "px";
            el.style.top = point8.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outlineStyle;
          element.style.outlineStyle = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outlineStyle = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil17 = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle: getStyle2,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn2, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn2);
            }
          } else {
            types = splitWords(types);
            for (var i2 = 0, len = types.length; i2 < len; i2++) {
              addOne(obj, types[i2], fn2, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn2, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn2);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i2 = 0, len = types.length; i2 < len; i2++) {
                removeOne(obj, types[i2], fn2, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn2, context) {
          var id = type + stamp(fn2) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn2.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser4.touchNative && Browser4.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser4.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser4.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn2, context, id) {
          id = id || type + stamp(fn2) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser4.touchNative && Browser4.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser4.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el = ev.target;
          while (el) {
            path.push(el);
            el = el.parentNode;
          }
          return path;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale3 = getScale(container), offset = scale3.boundingClientRect;
          return new Point(
            (e.clientX - offset.left) / scale3.x - container.clientLeft,
            (e.clientY - offset.top) / scale3.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser4.linux && Browser4.chrome ? window.devicePixelRatio : Browser4.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser4.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent12 = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented4.extend({
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
          },
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame2(this._animate, this);
            this._step();
          },
          _step: function(round2) {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round2);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round2) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round2) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map6 = Evented4.extend({
          options: {
            crs: EPSG3857,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: true,
            zoomAnimationThreshold: 4,
            fadeAnimation: true,
            markerZoomAnimation: true,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser4.any3d && !Browser4.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          setView: function(center, zoom3, options) {
            zoom3 = zoom3 === void 0 ? this._zoom : this._limitZoom(zoom3);
            center = this._limitCenter(toLatLng(center), zoom3, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend4({ animate: options.animate }, options.zoom);
                options.pan = extend4({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom3 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom3, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom3, options.pan && options.pan.noMoveStart);
            return this;
          },
          setZoom: function(zoom3, options) {
            if (!this._loaded) {
              this._zoom = zoom3;
              return this;
            }
            return this.setView(this.getCenter(), zoom3, { zoom: options });
          },
          zoomIn: function(delta, options) {
            delta = delta || (Browser4.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          zoomOut: function(delta, options) {
            delta = delta || (Browser4.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          setZoomAround: function(latlng, zoom3, options) {
            var scale3 = this.getZoomScale(zoom3), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale3), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom3, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds3, options) {
            options = options || {};
            bounds3 = bounds3.getBounds ? bounds3.getBounds() : toLatLngBounds(bounds3);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom3 = this.getBoundsZoom(bounds3, false, paddingTL.add(paddingBR));
            zoom3 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom3) : zoom3;
            if (zoom3 === Infinity) {
              return {
                center: bounds3.getCenter(),
                zoom: zoom3
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds3.getSouthWest(), zoom3), nePoint = this.project(bounds3.getNorthEast(), zoom3), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom3);
            return {
              center,
              zoom: zoom3
            };
          },
          fitBounds: function(bounds3, options) {
            bounds3 = toLatLngBounds(bounds3);
            if (!bounds3.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds3, options);
            return this.setView(target.center, target.zoom, options);
          },
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser4.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from2 = this.project(this.getCenter()), to2 = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to2.distanceTo(from2) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i2) {
              var s1 = i2 ? -1 : 1, s2 = i2 ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log = sq < 1e-9 ? -18 : Math.log(sq);
              return log;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame2(frame, this);
                this._move(
                  this.unproject(from2.add(to2.subtract(from2).multiplyBy(u(s) / u1)), startZoom),
                  this.getScaleZoom(w0 / w(s), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          flyToBounds: function(bounds3, options) {
            var target = this._getBoundsCenterZoom(bounds3, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          setMaxBounds: function(bounds3) {
            bounds3 = toLatLngBounds(bounds3);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds3.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds3;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          setMinZoom: function(zoom3) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom3;
            if (this._loaded && oldZoom !== zoom3) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom3);
              }
            }
            return this;
          },
          setMaxZoom: function(zoom3) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom3;
            if (this._loaded && oldZoom !== zoom3) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom3);
              }
            }
            return this;
          },
          panInsideBounds: function(bounds3, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds3));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend4({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          locate: function(options) {
            options = this._locateOptions = extend4({
              timeout: 1e4,
              watch: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c2 = error.code, message = error.message || (c2 === 1 ? "permission denied" : c2 === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c2,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng2(lat, lng), bounds3 = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom3 = this.getBoundsZoom(bounds3);
              this.setView(latlng, options.maxZoom ? Math.min(zoom3, options.maxZoom) : zoom3);
            }
            var data = {
              latlng,
              bounds: bounds3,
              timestamp: pos.timestamp
            };
            for (var i2 in pos.coords) {
              if (typeof pos.coords[i2] === "number") {
                data[i2] = pos.coords[i2];
              }
            }
            this.fire("locationfound", data);
          },
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i2;
            for (i2 in this._layers) {
              this._layers[i2].remove();
            }
            for (i2 in this._panes) {
              remove(this._panes[i2]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          getZoom: function() {
            return this._zoom;
          },
          getBounds: function() {
            var bounds3 = this.getPixelBounds(), sw = this.unproject(bounds3.getBottomLeft()), ne = this.unproject(bounds3.getTopRight());
            return new LatLngBounds3(sw, ne);
          },
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          getBoundsZoom: function(bounds3, inside, padding) {
            bounds3 = toLatLngBounds(bounds3);
            padding = toPoint(padding || [0, 0]);
            var zoom3 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds3.getNorthWest(), se = bounds3.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom3), this.project(nw, zoom3)).getSize(), snap = Browser4.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale3 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom3 = this.getScaleZoom(scale3, zoom3);
            if (snap) {
              zoom3 = Math.round(zoom3 / (snap / 100)) * (snap / 100);
              zoom3 = inside ? Math.ceil(zoom3 / snap) * snap : Math.floor(zoom3 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom3));
          },
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          getPixelBounds: function(center, zoom3) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom3);
            return new Bounds2(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          getPixelWorldBounds: function(zoom3) {
            return this.options.crs.getProjectedBounds(zoom3 === void 0 ? this.getZoom() : zoom3);
          },
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          getPanes: function() {
            return this._panes;
          },
          getContainer: function() {
            return this._container;
          },
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          getScaleZoom: function(scale3, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom3 = crs.zoom(scale3 * crs.scale(fromZoom));
            return isNaN(zoom3) ? Infinity : zoom3;
          },
          project: function(latlng, zoom3) {
            zoom3 = zoom3 === void 0 ? this._zoom : zoom3;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom3);
          },
          unproject: function(point8, zoom3) {
            zoom3 = zoom3 === void 0 ? this._zoom : zoom3;
            return this.options.crs.pointToLatLng(toPoint(point8), zoom3);
          },
          layerPointToLatLng: function(point8) {
            var projectedPoint = toPoint(point8).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          containerPointToLayerPoint: function(point8) {
            return toPoint(point8).subtract(this._getMapPanePos());
          },
          layerPointToContainerPoint: function(point8) {
            return toPoint(point8).add(this._getMapPanePos());
          },
          containerPointToLatLng: function(point8) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point8));
            return this.layerPointToLatLng(layerPoint);
          },
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser4.any3d;
            addClass(container, "leaflet-container" + (Browser4.touch ? " leaflet-touch" : "") + (Browser4.retina ? " leaflet-retina" : "") + (Browser4.ielt9 ? " leaflet-oldie" : "") + (Browser4.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle2(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          _resetView: function(center, zoom3, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom3 = this._limitZoom(zoom3);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom3;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom3)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom3, data, supressEvent) {
            if (zoom3 === void 0) {
              zoom3 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom3;
            this._zoom = zoom3;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser4.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame2(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el && el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend4({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i2 = 0; i2 < canvasTargets.length; i2++) {
                if (canvasTargets[i2].listens(type, true)) {
                  filtered.push(canvasTargets[i2]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i2 = 0; i2 < targets.length; i2++) {
              targets[i2].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i2].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i2 = 0, len = this._handlers.length; i2 < len; i2++) {
              this._handlers[i2].disable();
            }
          },
          whenReady: function(callback2, context) {
            if (this._loaded) {
              callback2.call(context || this, { target: this });
            } else {
              this.on("load", callback2, context);
            }
            return this;
          },
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom3) {
            var pixelOrigin = center && zoom3 !== void 0 ? this._getNewPixelOrigin(center, zoom3) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom3) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom3)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom3, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom3);
            return this.project(latlng, zoom3)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds2, zoom3, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom3);
            return toBounds([
              this.project(latLngBounds2.getSouthWest(), zoom3)._subtract(topLeft),
              this.project(latLngBounds2.getNorthWest(), zoom3)._subtract(topLeft),
              this.project(latLngBounds2.getSouthEast(), zoom3)._subtract(topLeft),
              this.project(latLngBounds2.getNorthEast(), zoom3)._subtract(topLeft)
            ]);
          },
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          _limitCenter: function(center, zoom3, bounds3) {
            if (!bounds3) {
              return center;
            }
            var centerPoint = this.project(center, zoom3), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds2(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds3, zoom3);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom3);
          },
          _limitOffset: function(offset, bounds3) {
            if (!bounds3) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds2(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds3));
          },
          _getBoundsOffset: function(pxBounds, maxBounds, zoom3) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom3),
              this.project(maxBounds.getSouthWest(), zoom3)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom3) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser4.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom3 = Math.round(zoom3 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom3));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c2 = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c2, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom3, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom3 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale3 = this.getZoomScale(zoom3), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale3);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame2(function() {
              this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom3, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom3, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom3;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom3,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options) {
          return new Map6(id, options);
        }
        var Control9 = Class4.extend({
          options: {
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          getPosition: function() {
            return this.options.position;
          },
          setPosition: function(position) {
            var map4 = this._map;
            if (map4) {
              map4.removeControl(this);
            }
            this.options.position = position;
            if (map4) {
              map4.addControl(this);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          addTo: function(map4) {
            this.remove();
            this._map = map4;
            var container = this._container = this.onAdd(map4), pos = this.getPosition(), corner = map4._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control9(options);
        };
        Map6.include({
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i2 in this._controlCorners) {
              remove(this._controlCorners[i2]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control9.extend({
          options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true,
            hideSingleBase: false,
            sortLayers: false,
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for (var i2 in baseLayers) {
              this._addLayer(baseLayers[i2], i2);
            }
            for (i2 in overlays) {
              this._addLayer(overlays[i2], i2, true);
            }
          },
          onAdd: function(map4) {
            this._initLayout();
            this._update();
            this._map = map4;
            map4.on("zoomend", this._checkDisabledLayers, this);
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              this._layers[i2].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map4) {
            Control9.prototype.addTo.call(this, map4);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              this._layers[i2].layer.off("add remove", this._onLayerChange, this);
            }
          },
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, {
              keydown: function(e) {
                if (e.keyCode === 13) {
                  this._expandSafely();
                }
              },
              click: function(e) {
                preventDefault(e);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i2 = 0; i2 < this._layers.length; i2++) {
              if (this._layers[i2] && stamp(this._layers[i2].layer) === id) {
                return this._layers[i2];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i2, obj, baseLayersCount = 0;
            for (i2 = 0; i2 < this._layers.length; i2++) {
              obj = this._layers[i2];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            if (this._preventClick) {
              return;
            }
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
              input = inputs[i2];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i2 = 0; i2 < removedLayers.length; i2++) {
              if (this._map.hasLayer(removedLayers[i2])) {
                this._map.removeLayer(removedLayers[i2]);
              }
            }
            for (i2 = 0; i2 < addedLayers.length; i2++) {
              if (!this._map.hasLayer(addedLayers[i2])) {
                this._map.addLayer(addedLayers[i2]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom3 = this._map.getZoom();
            for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
              input = inputs[i2];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom3 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom3 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            this._preventClick = true;
            on(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
              off(section, "click", preventDefault);
              that._preventClick = false;
            });
          }
        });
        var layers = function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        };
        var Zoom = Control9.extend({
          options: {
            position: "topleft",
            zoomInText: '<span aria-hidden="true">+</span>',
            zoomInTitle: "Zoom in",
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map4) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map4.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map4) {
            map4.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title2, className, container, fn2) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title2;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title2);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn2, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map4 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map4._zoom === map4.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map4._zoom === map4.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map6.mergeOptions({
          zoomControl: true
        });
        Map6.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom2 = function(options) {
          return new Zoom(options);
        };
        var Scale3 = Control9.extend({
          options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true
          },
          onAdd: function(map4) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map4.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map4.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map4) {
            map4.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map4 = this._map, y = map4.getSize().y / 2;
            var maxMeters = map4.distance(
              map4.containerPointToLatLng([0, y]),
              map4.containerPointToLatLng([this.options.maxWidth, y])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale3, text, ratio) {
            scale3.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale3.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d2 = num / pow10;
            d2 = d2 >= 10 ? 10 : d2 >= 5 ? 5 : d2 >= 3 ? 3 : d2 >= 2 ? 2 : 1;
            return pow10 * d2;
          }
        });
        var scale2 = function(options) {
          return new Scale3(options);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control9.extend({
          options: {
            position: "bottomright",
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser4.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map4) {
            map4.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i2 in map4._layers) {
              if (map4._layers[i2].getAttribution) {
                this.addAttribution(map4._layers[i2].getAttribution());
              }
            }
            this._update();
            map4.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map4) {
            map4.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i2 in this._attributions) {
              if (this._attributions[i2]) {
                attribs.push(i2);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map6.mergeOptions({
          attributionControl: true
        });
        Map6.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control9.Layers = Layers;
        Control9.Zoom = Zoom;
        Control9.Scale = Scale3;
        Control9.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom2;
        control.scale = scale2;
        control.attribution = attribution;
        var Handler = Class4.extend({
          initialize: function(map4) {
            this._map = map4;
          },
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          enabled: function() {
            return !!this._enabled;
          }
        });
        Handler.addTo = function(map4, name) {
          map4.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser4.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented4.extend({
          options: {
            clickTolerance: 3
          },
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first2 = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first2.clientX, first2.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first2 = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first2.clientX, first2.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
          }
        });
        function clipPolygon(points, bounds3, round2) {
          var clippedPoints, edges = [1, 4, 2, 8], i2, j, k, a, b, len, edge2, p;
          for (i2 = 0, len = points.length; i2 < len; i2++) {
            points[i2]._code = _getBitCode(points[i2], bounds3);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges[k];
            clippedPoints = [];
            for (i2 = 0, len = points.length, j = len - 1; i2 < len; j = i2++) {
              a = points[i2];
              b = points[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds3, round2);
                  p._code = _getBitCode(p, bounds3);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds3, round2);
                p._code = _getBitCode(p, bounds3);
                clippedPoints.push(p);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        function polygonCenter(latlngs, crs) {
          var i2, j, p1, p2, f, area, x, y, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds3 = toLatLngBounds(latlngs);
          var areaBounds = bounds3.getNorthWest().distanceTo(bounds3.getSouthWest()) * bounds3.getNorthEast().distanceTo(bounds3.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i2 = 0; i2 < len; i2++) {
            var latlng = toLatLng(latlngs[i2]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          area = x = y = 0;
          for (i2 = 0, j = len - 1; i2 < len; j = i2++) {
            p1 = points[i2];
            p2 = points[j];
            f = p1.y * p2.x - p2.y * p1.x;
            x += (p1.x + p2.x) * f;
            y += (p1.y + p2.y) * f;
            area += f * 3;
          }
          if (area === 0) {
            center = points[0];
          } else {
            center = [x / area, y / area];
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        function centroid(coords2) {
          var latSum = 0;
          var lngSum = 0;
          var len = 0;
          for (var i2 = 0; i2 < coords2.length; i2++) {
            var latlng = toLatLng(coords2[i2]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
          }
          return toLatLng([latSum / len, lngSum / len]);
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter,
          centroid
        };
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i2, newPoints = [];
          for (i2 = 0; i2 < len; i2++) {
            if (markers[i2]) {
              newPoints.push(points[i2]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first2, last) {
          var maxSqDist = 0, index3, i2, sqDist;
          for (i2 = first2 + 1; i2 <= last - 1; i2++) {
            sqDist = _sqClosestPointOnSegment(points[i2], points[first2], points[last], true);
            if (sqDist > maxSqDist) {
              index3 = i2;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index3] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first2, index3);
            _simplifyDPStep(points, markers, sqTolerance, index3, last);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i2 = 1, prev = 0, len = points.length; i2 < len; i2++) {
            if (_sqDist(points[i2], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i2]);
              prev = i2;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds3, useLastCode, round2) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds3), codeB = _getBitCode(b, bounds3), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds3, round2);
            newCode = _getBitCode(p, bounds3);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds3, round2) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds3.min, max = bounds3.max, x, y;
          if (code & 8) {
            x = a.x + dx * (max.y - a.y) / dy;
            y = max.y;
          } else if (code & 4) {
            x = a.x + dx * (min.y - a.y) / dy;
            y = min.y;
          } else if (code & 2) {
            x = max.x;
            y = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x = min.x;
            y = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point(x, y, round2);
        }
        function _getBitCode(p, bounds3) {
          var code = 0;
          if (p.x < bounds3.min.x) {
            code |= 1;
          } else if (p.x > bounds3.max.x) {
            code |= 2;
          }
          if (p.y < bounds3.min.y) {
            code |= 4;
          } else if (p.y > bounds3.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
            if (t > 1) {
              x = p2.x;
              y = p2.y;
            } else if (t > 0) {
              x += dx * t;
              y += dy * t;
            }
          }
          dx = p.x - x;
          dy = p.y - y;
          return sqDist ? dx * dx + dy * dy : new Point(x, y);
        }
        function isFlat(latlngs) {
          return !isArray2(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        function polylineCenter(latlngs, crs) {
          var i2, halfDist, segDist, dist, p1, p2, ratio, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds3 = toLatLngBounds(latlngs);
          var areaBounds = bounds3.getNorthWest().distanceTo(bounds3.getSouthWest()) * bounds3.getNorthEast().distanceTo(bounds3.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i2 = 0; i2 < len; i2++) {
            var latlng = toLatLng(latlngs[i2]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          for (i2 = 0, halfDist = 0; i2 < len - 1; i2++) {
            halfDist += points[i2].distanceTo(points[i2 + 1]) / 2;
          }
          if (halfDist === 0) {
            center = points[0];
          } else {
            for (i2 = 0, dist = 0; i2 < len - 1; i2++) {
              p1 = points[i2];
              p2 = points[i2 + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ];
                break;
              }
            }
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point8) {
            return new LatLng2(point8.y, point8.x);
          },
          bounds: new Bounds2([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds2([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d2 = Math.PI / 180, r = this.R, y = latlng.lat * d2, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d2 * r, y);
          },
          unproject: function(point8) {
            var d2 = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point8.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i2 = 0, dphi = 0.1, con; i2 < 15 && Math.abs(dphi) > 1e-7; i2++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng2(phi * d2, point8.x * d2 / r);
          }
        };
        var index2 = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend4({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale3 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale3, 0.5, -scale3, 0.5);
          }()
        });
        var EPSG4326 = extend4({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend4({}, CRS2, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom3) {
            return Math.pow(2, zoom3);
          },
          zoom: function(scale3) {
            return Math.log(scale3) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS2.Earth = Earth;
        CRS2.EPSG3395 = EPSG3395;
        CRS2.EPSG3857 = EPSG3857;
        CRS2.EPSG900913 = EPSG900913;
        CRS2.EPSG4326 = EPSG4326;
        CRS2.Simple = Simple;
        var Layer = Evented4.extend({
          options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: true
          },
          addTo: function(map4) {
            map4.addLayer(this);
            return this;
          },
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map4 = e.target;
            if (!map4.hasLayer(this)) {
              return;
            }
            this._map = map4;
            this._zoomAnimated = map4._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map4.on(events, this);
              this.once("remove", function() {
                map4.off(events, this);
              }, this);
            }
            this.onAdd(map4);
            this.fire("add");
            map4.fire("layeradd", { layer: this });
          }
        });
        Map6.include({
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          eachLayer: function(method, context) {
            for (var i2 in this._layers) {
              method.call(context, this._layers[i2]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray2(layers2) ? layers2 : [layers2] : [];
            for (var i2 = 0, len = layers2.length; i2 < len; i2++) {
              this.addLayer(layers2[i2]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i2 in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i2].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup3 = Layer.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i2, len;
            if (layers2) {
              for (i2 = 0, len = layers2.length; i2 < len; i2++) {
                this.addLayer(layers2[i2]);
              }
            }
          },
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i2, layer;
            for (i2 in this._layers) {
              layer = this._layers[i2];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map4) {
            this.eachLayer(map4.addLayer, map4);
          },
          onRemove: function(map4) {
            this.eachLayer(map4.removeLayer, map4);
          },
          eachLayer: function(method, context) {
            for (var i2 in this._layers) {
              method.call(context, this._layers[i2]);
            }
            return this;
          },
          getLayer: function(id) {
            return this._layers[id];
          },
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options) {
          return new LayerGroup3(layers2, options);
        };
        var FeatureGroup = LayerGroup3.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup3.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup3.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          getBounds: function() {
            var bounds3 = new LatLngBounds3();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds3.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds3;
          }
        });
        var featureGroup = function(layers2, options) {
          return new FeatureGroup(layers2, options);
        };
        var Icon = Class4.extend({
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser4.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options) {
          return new Icon(options);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str2, re, idx) {
              var match = re.exec(str2);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle2(el, "background-image") || getStyle2(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker4) {
            this._marker = marker4;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker4 = this._marker, map4 = marker4._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker4._icon), bounds3 = map4.getPixelBounds(), origin = map4.getPixelOrigin();
            var panBounds = toBounds(
              bounds3.min._subtract(origin).add(padding),
              bounds3.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds3.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds3.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds3.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds3.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map4.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker4._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame2(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame2(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker4 = this._marker, shadow = marker4._shadow, iconPos = getPosition(marker4._icon), latlng = marker4._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker4._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker4.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          options: {
            icon: new IconDefault(),
            interactive: true,
            keyboard: true,
            title: "",
            alt: "Marker",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250,
            pane: "markerPane",
            shadowPane: "shadowPane",
            bubblingMouseEvents: false,
            autoPanOnFocus: true,
            draggable: false,
            autoPan: false,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map4) {
            this._zoomAnimated = this._zoomAnimated && map4.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map4.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map4) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map4.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          getIcon: function() {
            return this.options.icon;
          },
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon2.title = options.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options.keyboard) {
              icon2.tabIndex = "0";
              icon2.setAttribute("role", "button");
            }
            this._icon = icon2;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon2, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map4 = this._map;
            if (!map4) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map4.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker3(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path2 = Layer.extend({
          options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            fillRule: "evenodd",
            interactive: true,
            bubblingMouseEvents: true
          },
          beforeAdd: function(map4) {
            this._renderer = map4.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path2.extend({
          options: {
            fill: true,
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          getLatLng: function() {
            return this._latlng;
          },
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path2.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds2(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker3(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        var Circle = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend4({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._mRadius;
          },
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds3(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path2.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map4 = this._map, crs = map4.options.crs;
            if (crs.distance === Earth.distance) {
              var d2 = Math.PI / 180, latR = this._mRadius / Earth.R / d2, top = map4.project([lat + latR, lng]), bottom = map4.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map4.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d2) - Math.sin(lat * d2) * Math.sin(lat2 * d2)) / (Math.cos(lat * d2) * Math.cos(lat2 * d2))) / d2;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map4.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map4.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map4.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map4.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options, legacyOptions) {
          return new Circle(latlng, options, legacyOptions);
        }
        var Polyline = Path2.extend({
          options: {
            smoothFactor: 1,
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          getLatLngs: function() {
            return this._latlngs;
          },
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          isEmpty: function() {
            return !this._latlngs.length;
          },
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i2 = 1, len = points.length; i2 < len; i2++) {
                p1 = points[i2 - 1];
                p2 = points[i2];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          getBounds: function() {
            return this._bounds;
          },
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds3();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
              if (flat) {
                result[i2] = toLatLng(latlngs[i2]);
                this._bounds.extend(result[i2]);
              } else {
                result[i2] = this._convertLatLngs(latlngs[i2]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds2();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point(w, w);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds2([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng2, len = latlngs.length, i2, ring;
            if (flat) {
              ring = [];
              for (i2 = 0; i2 < len; i2++) {
                ring[i2] = this._map.latLngToLayerPoint(latlngs[i2]);
                projectedBounds.extend(ring[i2]);
              }
              result.push(ring);
            } else {
              for (i2 = 0; i2 < len; i2++) {
                this._projectLatlngs(latlngs[i2], result, projectedBounds);
              }
            }
          },
          _clipPoints: function() {
            var bounds3 = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds3)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i2, j, k, len, len2, segment, points;
            for (i2 = 0, k = 0, len = this._rings.length; i2 < len; i2++) {
              points = this._rings[i2];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds3, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i2 = 0, len = parts.length; i2 < len; i2++) {
              parts[i2] = simplify(parts[i2], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          _containsPoint: function(p, closed) {
            var i2, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
              part = this._parts[i2];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline3(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng2 && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds3 = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            bounds3 = new Bounds2(bounds3.min.subtract(p), bounds3.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds3)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i2 = 0, len = this._rings.length, clipped; i2 < len; i2++) {
              clipped = clipPolygon(this._rings[i2], bounds3, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i2, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
              part = this._parts[i2];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          addData: function(geojson) {
            var features = isArray2(geojson) ? geojson : geojson.features, i2, len, feature;
            if (features) {
              for (i2 = 0, len = features.length; i2 < len; i2++) {
                feature = features[i2];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend4({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords2 = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i2, len;
          if (!coords2 && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords2);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i2 = 0, len = coords2.length; i2 < len; i2++) {
                latlng = _coordsToLatLng(coords2[i2]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords2, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords2, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i2 = 0, len = geometry.geometries.length; i2 < len; i2++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i2],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (geoLayer) {
                  layers2.push(geoLayer);
                }
              }
              return new FeatureGroup(layers2);
            case "FeatureCollection":
              for (i2 = 0, len = geometry.features.length; i2 < len; i2++) {
                var featureLayer = geometryToLayer(geometry.features[i2], options);
                if (featureLayer) {
                  layers2.push(featureLayer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords2) {
          return new LatLng2(coords2[1], coords2[0], coords2[2]);
        }
        function coordsToLatLngs(coords2, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i2 = 0, len = coords2.length, latlng; i2 < len; i2++) {
            latlng = levelsDeep ? coordsToLatLngs(coords2[i2], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords2[i2]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords2 = [];
          for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
            coords2.push(levelsDeep ? latLngsToCoords(latlngs[i2], isFlat(latlngs[i2]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i2], precision));
          }
          if (!levelsDeep && closed && coords2.length > 0) {
            coords2.push(coords2[0].slice());
          }
          return coords2;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend4({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords2 = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords2
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords2 = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords2 = [coords2];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords2
            });
          }
        });
        LayerGroup3.include({
          toMultiPoint: function(precision) {
            var coords2 = [];
            this.eachLayer(function(layer) {
              coords2.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords2
            });
          },
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson3 = geoJSON;
        var ImageOverlay = Layer.extend({
          options: {
            opacity: 1,
            alt: "",
            interactive: false,
            crossOrigin: false,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
          },
          initialize: function(url, bounds3, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds3);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          setBounds: function(bounds3) {
            this._bounds = toLatLngBounds(bounds3);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          getBounds: function() {
            return this._bounds;
          },
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale3 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale3);
          },
          _reset: function() {
            var image = this._image, bounds3 = new Bounds2(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds3.getSize();
            setPosition(image, bounds3.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds3, options) {
          return new ImageOverlay(url, bounds3, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          options: {
            autoplay: true,
            loop: true,
            keepAspectRatio: true,
            muted: false,
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray2(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i2 = 0; i2 < this._url.length; i2++) {
              var source = create$1("source");
              source.src = this._url[i2];
              vid.appendChild(source);
            }
          }
        });
        function videoOverlay(video, bounds3, options) {
          return new VideoOverlay(video, bounds3, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
        });
        function svgOverlay(el, bounds3, options) {
          return new SVGOverlay(el, bounds3, options);
        }
        var DivOverlay = Layer.extend({
          options: {
            interactive: false,
            offset: [0, 0],
            className: "",
            pane: void 0,
            content: ""
          },
          initialize: function(options, source) {
            if (options && (options instanceof LatLng2 || isArray2(options))) {
              this._latlng = toLatLng(options);
              setOptions(this, source);
            } else {
              setOptions(this, options);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          openOn: function(map4) {
            map4 = arguments.length ? map4 : this._source._map;
            if (!map4.hasLayer(this)) {
              map4.addLayer(this);
            }
            return this;
          },
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map4) {
            this._zoomAnimated = map4._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map4._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map4._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map4) {
            if (map4._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          getElement: function() {
            return this._container;
          },
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id in layers2) {
                if (layers2[id]._map) {
                  source = layers2[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map6.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          options: {
            pane: "popupPane",
            offset: [0, 7],
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: true,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: false,
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            className: ""
          },
          openOn: function(map4) {
            map4 = arguments.length ? map4 : this._source._map;
            if (!map4.hasLayer(this) && map4._popup && map4._popup.options.autoClose) {
              map4.removeLayer(map4._popup);
            }
            map4._popup = this;
            return DivOverlay.prototype.openOn.call(this, map4);
          },
          onAdd: function(map4) {
            DivOverlay.prototype.onAdd.call(this, map4);
            map4.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map4) {
            DivOverlay.prototype.onRemove.call(this, map4);
            map4.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path2)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map4 = this._map, marginBottom = parseInt(getStyle2(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map4.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map4.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map4.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup(options, source);
        };
        Map6.mergeOptions({
          closePopupOnClick: true
        });
        Map6.include({
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup, popup2, latlng, options).openOn(this);
            return this;
          },
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path2)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip2 = DivOverlay.extend({
          options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: false,
            sticky: false,
            opacity: 0.9
          },
          onAdd: function(map4) {
            DivOverlay.prototype.onAdd.call(this, map4);
            this.setOpacity(this.options.opacity);
            map4.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map4) {
            DivOverlay.prototype.onRemove.call(this, map4);
            map4.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map4 = this._map, container = this._container, centerPoint = map4.latLngToContainerPoint(map4.getCenter()), tooltipPoint = map4.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip2(options, source);
        };
        Map6.include({
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip2, tooltip2, latlng, options).openOn(this);
            return this;
          },
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip2, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              on(el, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on(el, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              el.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map) {
              return;
            }
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = true;
              var that = this;
              this._map.once("moveend", function() {
                that._openOnceFlag = false;
                that._openTooltip(e);
              });
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            iconSize: [12, 12],
            html: false,
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon2(options) {
          return new DivIcon(options);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          options: {
            tileSize: 256,
            opacity: 1,
            updateWhenIdle: Browser4.mobile,
            updateWhenZooming: true,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: void 0,
            maxNativeZoom: void 0,
            minNativeZoom: void 0,
            noWrap: false,
            pane: "tilePane",
            className: "",
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map4) {
            map4._addZoomLimit(this);
          },
          onRemove: function(map4) {
            this._removeAllTiles();
            remove(this._container);
            map4._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          isLoading: function() {
            return this._loading;
          },
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          createTile: function() {
            return document.createElement("div");
          },
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i2 = 0, len = layers2.length, zIndex; i2 < len; i2++) {
              zIndex = layers2[i2].style.zIndex;
              if (layers2[i2] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser4.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile2 = this._tiles[key];
              if (!tile2.current || !tile2.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile2.loaded) / 200);
              setOpacity(tile2.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile2.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile2);
                }
                tile2.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame2(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom3 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom3 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom3) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom3 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom3], map4 = this._map;
            if (!level) {
              level = this._levels[zoom3] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map4.project(map4.unproject(map4.getPixelOrigin()), zoom3).round();
              level.zoom = zoom3;
              this._setZoomTransform(level, map4.getCenter(), map4.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile2;
            var zoom3 = this._map.getZoom();
            if (zoom3 > this.options.maxZoom || zoom3 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile2 = this._tiles[key];
              tile2.retain = tile2.current;
            }
            for (key in this._tiles) {
              tile2 = this._tiles[key];
              if (tile2.current && !tile2.active) {
                var coords2 = tile2.coords;
                if (!this._retainParent(coords2.x, coords2.y, coords2.z, coords2.z - 5)) {
                  this._retainChildren(coords2.x, coords2.y, coords2.z, coords2.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom3) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom3) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x, y, z, minZoom) {
            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile2 = this._tiles[key];
            if (tile2 && tile2.active) {
              tile2.retain = true;
              return true;
            } else if (tile2 && tile2.loaded) {
              tile2.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x2, y2, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x, y, z, maxZoom) {
            for (var i2 = 2 * x; i2 < 2 * x + 2; i2++) {
              for (var j = 2 * y; j < 2 * y + 2; j++) {
                var coords2 = new Point(i2, j);
                coords2.z = z + 1;
                var key = this._tileCoordsToKey(coords2), tile2 = this._tiles[key];
                if (tile2 && tile2.active) {
                  tile2.retain = true;
                  continue;
                } else if (tile2 && tile2.loaded) {
                  tile2.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i2, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom3) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom3 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom3) {
              return options.maxNativeZoom;
            }
            return zoom3;
          },
          _setView: function(center, zoom3, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom3);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom3);
          },
          _setZoomTransforms: function(center, zoom3) {
            for (var i2 in this._levels) {
              this._setZoomTransform(this._levels[i2], center, zoom3);
            }
          },
          _setZoomTransform: function(level, center, zoom3) {
            var scale3 = this._map.getZoomScale(zoom3, level.zoom), translate = level.origin.multiplyBy(scale3).subtract(this._map._getNewPixelOrigin(center, zoom3)).round();
            if (Browser4.any3d) {
              setTransform(level.el, translate, scale3);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map4 = this._map, crs = map4.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds3 = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds3) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds3);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map4.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map4.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map4.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map4.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map4 = this._map, mapZoom = map4._animatingZoom ? Math.max(map4._animateToZoom, map4.getZoom()) : map4.getZoom(), scale3 = map4.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map4.project(center, this._tileZoom).floor(), halfSize = map4.getSize().divideBy(scale3 * 2);
            return new Bounds2(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          _update: function(center) {
            var map4 = this._map;
            if (!map4) {
              return;
            }
            var zoom3 = this._clampZoom(map4.getZoom());
            if (center === void 0) {
              center = map4.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds2(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c2 = this._tiles[key].coords;
              if (c2.z !== this._tileZoom || !noPruneRange.contains(new Point(c2.x, c2.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom3 - this._tileZoom) > 1) {
              this._setView(center, zoom3);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i2 = tileRange.min.x; i2 <= tileRange.max.x; i2++) {
                var coords2 = new Point(i2, j);
                coords2.z = this._tileZoom;
                if (!this._isValidTile(coords2)) {
                  continue;
                }
                var tile2 = this._tiles[this._tileCoordsToKey(coords2)];
                if (tile2) {
                  tile2.current = true;
                } else {
                  queue.push(coords2);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i2 = 0; i2 < queue.length; i2++) {
                this._addTile(queue[i2], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords2) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds3 = this._globalTileRange;
              if (!crs.wrapLng && (coords2.x < bounds3.min.x || coords2.x > bounds3.max.x) || !crs.wrapLat && (coords2.y < bounds3.min.y || coords2.y > bounds3.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords2);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords2) {
            var map4 = this._map, tileSize = this.getTileSize(), nwPoint = coords2.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map4.unproject(nwPoint, coords2.z), se = map4.unproject(sePoint, coords2.z);
            return [nw, se];
          },
          _tileCoordsToBounds: function(coords2) {
            var bp = this._tileCoordsToNwSe(coords2), bounds3 = new LatLngBounds3(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds3 = this._map.wrapLatLngBounds(bounds3);
            }
            return bounds3;
          },
          _tileCoordsToKey: function(coords2) {
            return coords2.x + ":" + coords2.y + ":" + coords2.z;
          },
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords2 = new Point(+k[0], +k[1]);
            coords2.z = +k[2];
            return coords2;
          },
          _removeTile: function(key) {
            var tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            remove(tile2.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile2.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile2) {
            addClass(tile2, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile2.style.width = tileSize.x + "px";
            tile2.style.height = tileSize.y + "px";
            tile2.onselectstart = falseFn;
            tile2.onmousemove = falseFn;
            if (Browser4.ielt9 && this.options.opacity < 1) {
              setOpacity(tile2, this.options.opacity);
            }
          },
          _addTile: function(coords2, container) {
            var tilePos = this._getTilePos(coords2), key = this._tileCoordsToKey(coords2);
            var tile2 = this.createTile(this._wrapCoords(coords2), bind(this._tileReady, this, coords2));
            this._initTile(tile2);
            if (this.createTile.length < 2) {
              requestAnimFrame2(bind(this._tileReady, this, coords2, null, tile2));
            }
            setPosition(tile2, tilePos);
            this._tiles[key] = {
              el: tile2,
              coords: coords2,
              current: true
            };
            container.appendChild(tile2);
            this.fire("tileloadstart", {
              tile: tile2,
              coords: coords2
            });
          },
          _tileReady: function(coords2, err, tile2) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile: tile2,
                coords: coords2
              });
            }
            var key = this._tileCoordsToKey(coords2);
            tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            tile2.loaded = +new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile2.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame2(this._updateOpacity, this);
            } else {
              tile2.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile2.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile2.el,
                coords: coords2
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser4.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame2(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords2) {
            return coords2.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords2) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords2.x, this._wrapX) : coords2.x,
              this._wrapY ? wrapNum(coords2.y, this._wrapY) : coords2.y
            );
            newCoords.z = coords2.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds3) {
            var tileSize = this.getTileSize();
            return new Bounds2(
              bounds3.min.unscaleBy(tileSize).floor(),
              bounds3.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer2 = GridLayer.extend({
          options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: false,
            zoomReverse: false,
            detectRetina: false,
            crossOrigin: false,
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser4.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
              } else {
                options.zoomOffset--;
                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
              }
              options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) {
              options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            } else {
              options.minZoom = Math.min(options.maxZoom, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          createTile: function(coords2, done) {
            var tile2 = document.createElement("img");
            on(tile2, "load", bind(this._tileOnLoad, this, done, tile2));
            on(tile2, "error", bind(this._tileOnError, this, done, tile2));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile2.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile2.referrerPolicy = this.options.referrerPolicy;
            }
            tile2.alt = "";
            tile2.src = this.getTileUrl(coords2);
            return tile2;
          },
          getTileUrl: function(coords2) {
            var data = {
              r: Browser4.retina ? "@2x" : "",
              s: this._getSubdomain(coords2),
              x: coords2.x,
              y: coords2.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords2.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend4(data, this.options));
          },
          _tileOnLoad: function(done, tile2) {
            if (Browser4.ielt9) {
              setTimeout(bind(done, this, null, tile2), 0);
            } else {
              done(null, tile2);
            }
          },
          _tileOnError: function(done, tile2, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile2.getAttribute("src") !== errorUrl) {
              tile2.src = errorUrl;
            }
            done(e, tile2);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom3 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom3 = maxZoom - zoom3;
            }
            return zoom3 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index3 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index3];
          },
          _abortLoading: function() {
            var i2, tile2;
            for (i2 in this._tiles) {
              if (this._tiles[i2].coords.z !== this._tileZoom) {
                tile2 = this._tiles[i2].el;
                tile2.onload = falseFn;
                tile2.onerror = falseFn;
                if (!tile2.complete) {
                  tile2.src = emptyImageUrl;
                  var coords2 = this._tiles[i2].coords;
                  remove(tile2);
                  delete this._tiles[i2];
                  this.fire("tileabort", {
                    tile: tile2,
                    coords: coords2
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile2 = this._tiles[key];
            if (!tile2) {
              return;
            }
            tile2.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords2, err, tile2) {
            if (!this._map || tile2 && tile2.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords2, err, tile2);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer2(url, options);
        }
        var TileLayerWMS = TileLayer2.extend({
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false,
            version: "1.1.1"
          },
          options: {
            crs: null,
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend4({}, this.defaultWmsParams);
            for (var i2 in options) {
              if (!(i2 in this.options)) {
                wmsParams[i2] = options[i2];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser4.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map4) {
            this._crs = this.options.crs || map4.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer2.prototype.onAdd.call(this, map4);
          },
          getTileUrl: function(coords2) {
            var tileBounds = this._tileCoordsToNwSe(coords2), crs = this._crs, bounds3 = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds3.min, max = bounds3.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords2);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          setParams: function(params, noRedraw) {
            extend4(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer2.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          options: {
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom3) {
            var scale3 = this._map.getZoomScale(zoom3, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom3), topLeftOffset = viewHalf.multiplyBy(-scale3).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom3));
            if (Browser4.any3d) {
              setTransform(this._container, topLeftOffset, scale3);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds2(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas2 = Renderer.extend({
          options: {
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser4.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser4.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i2;
              for (i2 = 0; i2 < parts.length; i2++) {
                dashValue = Number(parts[i2]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame2(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds2();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds3 = this._redrawBounds;
            if (bounds3) {
              var size = bounds3.getSize();
              this._ctx.clearRect(bounds3.min.x, bounds3.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds3 = this._redrawBounds;
            this._ctx.save();
            if (bounds3) {
              var size = bounds3.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds3.min.x, bounds3.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds3 || layer._pxBounds && layer._pxBounds.intersects(bounds3)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i2, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i2 = 0; i2 < len; i2++) {
              for (j = 0, len2 = parts[i2].length; j < len2; j++) {
                p = parts[i2][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          _onClick: function(e) {
            var point8 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point8)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point8 = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point8);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point8) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point8)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser4.canvas ? new Canvas2(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill2 = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray2(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill2) {
                fill2 = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill2);
              fill2.color = options.fillColor || options.color;
              fill2.opacity = options.fillOpacity;
            } else if (fill2) {
              container.removeChild(fill2);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser4.vml ? vmlCreate : svgCreate;
        var SVG2 = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d2 = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d2);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser4.vml) {
          SVG2.include(vmlMixin);
        }
        function svg(options) {
          return Browser4.svg || Browser4.vml ? new SVG2(options) : null;
        }
        Map6.include({
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds2, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds2), options);
          },
          setBounds: function(latLngBounds2) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds2));
          },
          _boundsToLatLngs: function(latLngBounds2) {
            latLngBounds2 = toLatLngBounds(latLngBounds2);
            return [
              latLngBounds2.getSouthWest(),
              latLngBounds2.getNorthWest(),
              latLngBounds2.getNorthEast(),
              latLngBounds2.getSouthEast()
            ];
          }
        });
        function rectangle2(latLngBounds2, options) {
          return new Rectangle(latLngBounds2, options);
        }
        SVG2.create = create;
        SVG2.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map6.mergeOptions({
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map4) {
            this._map = map4;
            this._container = map4._container;
            this._pane = map4._panes.overlayPane;
            this._resetStateTimeout = 0;
            map4.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds3 = new Bounds2(this._point, this._startPoint), size = bounds3.getSize();
            setPosition(this._box, bounds3.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds3 = new LatLngBounds3(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds3).fire("boxzoomend", { boxZoomBounds: bounds3 });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map6.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map6.mergeOptions({
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map4 = this._map, oldZoom = map4.getZoom(), delta = map4.options.zoomDelta, zoom3 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map4.options.doubleClickZoom === "center") {
              map4.setZoom(zoom3);
            } else {
              map4.setZoomAround(e.containerPoint, zoom3);
            }
          }
        });
        Map6.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map6.mergeOptions({
          dragging: true,
          inertia: true,
          inertiaDeceleration: 3400,
          inertiaMaxSpeed: Infinity,
          easeLinearity: 0.2,
          worldCopyJump: false,
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map4 = this._map;
              this._draggable = new Draggable(map4._mapPane, map4._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map4.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map4.on("zoomend", this._onZoomEnd, this);
                map4.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map4 = this._map;
            map4._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds3 = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds3.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds3.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map4.fire("movestart").fire("dragstart");
            if (map4.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map4 = this._map, options = map4.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map4.fire("dragend", e);
            if (noInertia) {
              map4.fire("moveend");
            } else {
              this._prunePositions(+new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map4.fire("moveend");
              } else {
                offset = map4._limitOffset(offset, map4.options.maxBounds);
                requestAnimFrame2(function() {
                  map4.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map6.addInitHook("addHandler", "dragging", Drag);
        Map6.mergeOptions({
          keyboard: true,
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map4) {
            this._map = map4;
            this._setPanDelta(map4.options.keyboardPanDelta);
            this._setZoomDelta(map4.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i2, len;
            for (i2 = 0, len = codes.left.length; i2 < len; i2++) {
              keys[codes.left[i2]] = [-1 * panDelta, 0];
            }
            for (i2 = 0, len = codes.right.length; i2 < len; i2++) {
              keys[codes.right[i2]] = [panDelta, 0];
            }
            for (i2 = 0, len = codes.down.length; i2 < len; i2++) {
              keys[codes.down[i2]] = [0, panDelta];
            }
            for (i2 = 0, len = codes.up.length; i2 < len; i2++) {
              keys[codes.up[i2]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta2) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i2, len;
            for (i2 = 0, len = codes.zoomIn.length; i2 < len; i2++) {
              keys[codes.zoomIn[i2]] = zoomDelta2;
            }
            for (i2 = 0, len = codes.zoomOut.length; i2 < len; i2++) {
              keys[codes.zoomOut[i2]] = -zoomDelta2;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map4 = this._map, offset;
            if (key in this._panKeys) {
              if (!map4._panAnim || !map4._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map4.options.maxBounds) {
                  offset = map4._limitOffset(toPoint(offset), map4.options.maxBounds);
                }
                if (map4.options.worldCopyJump) {
                  var newLatLng = map4.wrapLatLng(map4.unproject(map4.project(map4.getCenter()).add(offset)));
                  map4.panTo(newLatLng);
                } else {
                  map4.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map4.setZoom(map4.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map4._popup && map4._popup.options.closeOnEscapeKey) {
              map4.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map6.addInitHook("addHandler", "keyboard", Keyboard);
        Map6.mergeOptions({
          scrollWheelZoom: true,
          wheelDebounceTime: 40,
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce3 = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +new Date();
            }
            var left = Math.max(debounce3 - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map4 = this._map, zoom3 = map4.getZoom(), snap = this._map.options.zoomSnap || 0;
            map4._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map4._limitZoom(zoom3 + (this._delta > 0 ? d4 : -d4)) - zoom3;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map4.options.scrollWheelZoom === "center") {
              map4.setZoom(zoom3 + delta);
            } else {
              map4.setZoomAround(this._lastMousePos, zoom3 + delta);
            }
          }
        });
        Map6.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map6.mergeOptions({
          tapHold: Browser4.touchNative && Browser4.safari && Browser4.mobile,
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first2 = e.touches[0];
            this._startPos = this._newPos = new Point(first2.clientX, first2.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first2);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first2 = e.touches[0];
            this._newPos = new Point(first2.clientX, first2.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map6.addInitHook("addHandler", "tapHold", TapHold);
        Map6.mergeOptions({
          touchZoom: Browser4.touch,
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map4 = this._map;
            if (!e.touches || e.touches.length !== 2 || map4._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map4.mouseEventToContainerPoint(e.touches[0]), p2 = map4.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map4.getSize()._divideBy(2);
            this._startLatLng = map4.containerPointToLatLng(this._centerPoint);
            if (map4.options.touchZoom !== "center") {
              this._pinchStartLatLng = map4.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map4.getZoom();
            this._moved = false;
            this._zooming = true;
            map4._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map4 = this._map, p1 = map4.mouseEventToContainerPoint(e.touches[0]), p2 = map4.mouseEventToContainerPoint(e.touches[1]), scale3 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map4.getScaleZoom(scale3, this._startZoom);
            if (!map4.options.bounceAtZoomLimits && (this._zoom < map4.getMinZoom() && scale3 < 1 || this._zoom > map4.getMaxZoom() && scale3 > 1)) {
              this._zoom = map4._limitZoom(this._zoom);
            }
            if (map4.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale3 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale3 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map4.unproject(map4.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map4._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map4._move, map4, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame2(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map6.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map6.BoxZoom = BoxZoom;
        Map6.DoubleClickZoom = DoubleClickZoom;
        Map6.Drag = Drag;
        Map6.Keyboard = Keyboard;
        Map6.ScrollWheelZoom = ScrollWheelZoom;
        Map6.TapHold = TapHold;
        Map6.TouchZoom = TouchZoom;
        exports2.Bounds = Bounds2;
        exports2.Browser = Browser4;
        exports2.CRS = CRS2;
        exports2.Canvas = Canvas2;
        exports2.Circle = Circle;
        exports2.CircleMarker = CircleMarker;
        exports2.Class = Class4;
        exports2.Control = Control9;
        exports2.DivIcon = DivIcon;
        exports2.DivOverlay = DivOverlay;
        exports2.DomEvent = DomEvent12;
        exports2.DomUtil = DomUtil17;
        exports2.Draggable = Draggable;
        exports2.Evented = Evented4;
        exports2.FeatureGroup = FeatureGroup;
        exports2.GeoJSON = GeoJSON;
        exports2.GridLayer = GridLayer;
        exports2.Handler = Handler;
        exports2.Icon = Icon;
        exports2.ImageOverlay = ImageOverlay;
        exports2.LatLng = LatLng2;
        exports2.LatLngBounds = LatLngBounds3;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup3;
        exports2.LineUtil = LineUtil;
        exports2.Map = Map6;
        exports2.Marker = Marker;
        exports2.Mixin = Mixin;
        exports2.Path = Path2;
        exports2.Point = Point;
        exports2.PolyUtil = PolyUtil;
        exports2.Polygon = Polygon;
        exports2.Polyline = Polyline;
        exports2.Popup = Popup;
        exports2.PosAnimation = PosAnimation;
        exports2.Projection = index2;
        exports2.Rectangle = Rectangle;
        exports2.Renderer = Renderer;
        exports2.SVG = SVG2;
        exports2.SVGOverlay = SVGOverlay;
        exports2.TileLayer = TileLayer2;
        exports2.Tooltip = Tooltip2;
        exports2.Transformation = Transformation2;
        exports2.Util = Util24;
        exports2.VideoOverlay = VideoOverlay;
        exports2.bind = bind;
        exports2.bounds = toBounds;
        exports2.canvas = canvas;
        exports2.circle = circle;
        exports2.circleMarker = circleMarker3;
        exports2.control = control;
        exports2.divIcon = divIcon2;
        exports2.extend = extend4;
        exports2.featureGroup = featureGroup;
        exports2.geoJSON = geoJSON;
        exports2.geoJson = geoJson3;
        exports2.gridLayer = gridLayer;
        exports2.icon = icon;
        exports2.imageOverlay = imageOverlay;
        exports2.latLng = toLatLng;
        exports2.latLngBounds = toLatLngBounds;
        exports2.layerGroup = layerGroup;
        exports2.map = createMap;
        exports2.marker = marker3;
        exports2.point = toPoint;
        exports2.polygon = polygon;
        exports2.polyline = polyline3;
        exports2.popup = popup;
        exports2.rectangle = rectangle2;
        exports2.setOptions = setOptions;
        exports2.stamp = stamp;
        exports2.svg = svg;
        exports2.svgOverlay = svgOverlay;
        exports2.tileLayer = tileLayer;
        exports2.tooltip = tooltip;
        exports2.transformation = toTransformation;
        exports2.version = version3;
        exports2.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // node_modules/spectrum-vanilla/dist/spectrum.js
  var require_spectrum = __commonJS({
    "node_modules/spectrum-vanilla/dist/spectrum.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Spectrum = factory());
      })(exports, function() {
        "use strict";
        const trimLeft = /^\s+/;
        const trimRight = /\s+$/;
        function tinycolor(color2, opts) {
          color2 = color2 ? color2 : "";
          opts = opts || {};
          if (color2 instanceof tinycolor) {
            return color2;
          }
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color2, opts);
          }
          var rgb2 = inputToRGB(color2);
          this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
          this._gradientType = opts.gradientType;
          if (this._r < 1)
            this._r = Math.round(this._r);
          if (this._g < 1)
            this._g = Math.round(this._g);
          if (this._b < 1)
            this._b = Math.round(this._b);
          this._ok = rgb2.ok;
        }
        tinycolor.prototype = {
          isDark: function() {
            return this.getBrightness() < 128;
          },
          isLight: function() {
            return !this.isDark();
          },
          isValid: function() {
            return this._ok;
          },
          getOriginalInput: function() {
            return this._originalInput;
          },
          getFormat: function() {
            return this._format;
          },
          getAlpha: function() {
            return this._a;
          },
          getBrightness: function() {
            var rgb2 = this.toRgb();
            return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
          },
          getLuminance: function() {
            var rgb2 = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb2.r / 255;
            GsRGB = rgb2.g / 255;
            BsRGB = rgb2.b / 255;
            if (RsRGB <= 0.03928)
              R = RsRGB / 12.92;
            else
              R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            if (GsRGB <= 0.03928)
              G = GsRGB / 12.92;
            else
              G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            if (BsRGB <= 0.03928)
              B = BsRGB / 12.92;
            else
              B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = Math.round(100 * this._a) / 100;
            return this;
          },
          toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
          },
          toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
          },
          toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function() {
            return {
              r: Math.round(this._r),
              g: Math.round(this._g),
              b: Math.round(this._b),
              a: this._a
            };
          },
          toRgbString: function() {
            return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function() {
            return {
              r: Math.round(bound01(this._r, 255) * 100) + "%",
              g: Math.round(bound01(this._g, 255) * 100) + "%",
              b: Math.round(bound01(this._b, 255) * 100) + "%",
              a: this._a
            };
          },
          toPercentageRgbString: function() {
            return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function() {
            return tinycolor(this.toString());
          },
          _applyModification: function(fn2, args) {
            var color2 = fn2.apply(null, [this].concat([].slice.call(args)));
            this._r = color2._r;
            this._g = color2._g;
            this._b = color2._b;
            this.setAlpha(color2._a);
            return this;
          },
          lighten: function() {
            return this._applyModification(lighten, arguments);
          },
          brighten: function() {
            return this._applyModification(brighten, arguments);
          },
          darken: function() {
            return this._applyModification(darken, arguments);
          },
          desaturate: function() {
            return this._applyModification(desaturate, arguments);
          },
          saturate: function() {
            return this._applyModification(saturate, arguments);
          },
          greyscale: function() {
            return this._applyModification(greyscale, arguments);
          },
          spin: function() {
            return this._applyModification(spin, arguments);
          },
          _applyCombination: function(fn2, args) {
            return fn2.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function() {
            return this._applyCombination(analogous, arguments);
          },
          complement: function() {
            return this._applyCombination(complement, arguments);
          },
          monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
          },
          splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
          },
          triad: function() {
            return this._applyCombination(polyad, [3]);
          },
          tetrad: function() {
            return this._applyCombination(polyad, [4]);
          }
        };
        tinycolor.fromRatio = function(color2, opts) {
          if (typeof color2 == "object") {
            var newColor = {};
            for (var i2 in color2) {
              if (color2.hasOwnProperty(i2)) {
                if (i2 === "a") {
                  newColor[i2] = color2[i2];
                } else {
                  newColor[i2] = convertToPercentage(color2[i2]);
                }
              }
            }
            color2 = newColor;
          }
          return tinycolor(color2, opts);
        };
        function inputToRGB(color2) {
          var rgb2 = { r: 0, g: 0, b: 0 };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color2 == "string") {
            color2 = stringInputToObject(color2);
          }
          if (typeof color2 == "object") {
            if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
              rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
              ok = true;
              format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
              s = convertToPercentage(color2.s);
              v = convertToPercentage(color2.v);
              rgb2 = hsvToRgb(color2.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
              s = convertToPercentage(color2.s);
              l = convertToPercentage(color2.l);
              rgb2 = hslToRgb(color2.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color2.hasOwnProperty("a")) {
              a = color2.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok,
            format: color2.format || format,
            r: Math.min(255, Math.max(rgb2.r, 0)),
            g: Math.min(255, Math.max(rgb2.g, 0)),
            b: Math.min(255, Math.max(rgb2.b, 0)),
            a
          };
        }
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b), min = Math.min(r, g, b);
          var h, s, l = (max + min) / 2;
          if (max == min) {
            h = s = 0;
          } else {
            var d2 = max - min;
            s = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d2 + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d2 + 2;
                break;
              case b:
                h = (r - g) / d2 + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, l };
        }
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p2, q2, t) {
            if (t < 0)
              t += 1;
            if (t > 1)
              t -= 1;
            if (t < 1 / 6)
              return p2 + (q2 - p2) * 6 * t;
            if (t < 1 / 2)
              return q2;
            if (t < 2 / 3)
              return p2 + (q2 - p2) * (2 / 3 - t) * 6;
            return p2;
          }
          if (s === 0) {
            r = g = b = l;
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b), min = Math.min(r, g, b);
          var h, s, v = max;
          var d2 = max - min;
          s = max === 0 ? 0 : d2 / max;
          if (max == min) {
            h = 0;
          } else {
            switch (max) {
              case r:
                h = (g - b) / d2 + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d2 + 2;
                break;
              case b:
                h = (r - g) / d2 + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, v };
        }
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i2 = Math.floor(h), f = h - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i2 % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHex(r, g, b, allow3Char) {
          var hex2 = [
            pad2(Math.round(r).toString(16)),
            pad2(Math.round(g).toString(16)),
            pad2(Math.round(b).toString(16))
          ];
          if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
            return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
          }
          return hex2.join("");
        }
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex2 = [
            pad2(Math.round(r).toString(16)),
            pad2(Math.round(g).toString(16)),
            pad2(Math.round(b).toString(16)),
            pad2(convertDecimalToHex(a))
          ];
          if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
            return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
          }
          return hex2.join("");
        }
        function rgbaToArgbHex(r, g, b, a) {
          var hex2 = [
            pad2(convertDecimalToHex(a)),
            pad2(Math.round(r).toString(16)),
            pad2(Math.round(g).toString(16)),
            pad2(Math.round(b).toString(16))
          ];
          return hex2.join("");
        }
        tinycolor.equals = function(color1, color2) {
          if (!color1 || !color2)
            return false;
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function() {
          return tinycolor.fromRatio({
            r: Math.random(),
            g: Math.random(),
            b: Math.random()
          });
        };
        function desaturate(color2, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color2).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function saturate(color2, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color2).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function greyscale(color2) {
          return tinycolor(color2).desaturate(100);
        }
        function lighten(color2, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color2).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function brighten(color2, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb2 = tinycolor(color2).toRgb();
          rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
          rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
          rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
          return tinycolor(rgb2);
        }
        function darken(color2, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color2).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function spin(color2, amount) {
          var hsl = tinycolor(color2).toHsl();
          var hue2 = (hsl.h + amount) % 360;
          hsl.h = hue2 < 0 ? 360 + hue2 : hue2;
          return tinycolor(hsl);
        }
        function complement(color2) {
          var hsl = tinycolor(color2).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function polyad(color2, number) {
          if (isNaN(number) || number <= 0) {
            throw new Error("Argument to polyad must be a positive number");
          }
          var hsl = tinycolor(color2).toHsl();
          var result = [tinycolor(color2)];
          var step = 360 / number;
          for (var i2 = 1; i2 < number; i2++) {
            result.push(tinycolor({ h: (hsl.h + i2 * step) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        }
        function splitcomplement(color2) {
          var hsl = tinycolor(color2).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color2),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function analogous(color2, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color2).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color2)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function monochromatic(color2, results) {
          results = results || 6;
          var hsv = tinycolor(color2).toHsv();
          var h = hsv.h, s = hsv.s, v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({ h, s, v }));
            v = (v + modification) % 1;
          }
          return ret;
        }
        tinycolor.mix = function(color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba);
        };
        tinycolor.readability = function(color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };
        tinycolor.isReadable = function(color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };
        tinycolor.mostReadable = function(baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i2 = 0; i2 < colorList.length; i2++) {
            readability = tinycolor.readability(baseColor, colorList[i2]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i2]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, {
            level,
            size
          }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };
        var names2 = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };
        var hexNames = tinycolor.hexNames = flip(names2);
        function flip(o) {
          var flipped = {};
          for (var i2 in o) {
            if (o.hasOwnProperty(i2)) {
              flipped[o[i2]] = i2;
            }
          }
          return flipped;
        }
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }
        function bound01(n, max) {
          if (isOnePointZero(n))
            n = "100%";
          var processPercent = isPercentage(n);
          n = Math.min(max, Math.max(0, parseFloat(n)));
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }
          if (Math.abs(n - max) < 1e-6) {
            return 1;
          }
          return n % max / parseFloat(max);
        }
        function clamp01(val) {
          return Math.min(1, Math.max(0, val));
        }
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }
        function pad2(c2) {
          return c2.length == 1 ? "0" + c2 : "" + c2;
        }
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }
        function convertDecimalToHex(d2) {
          return Math.round(parseFloat(d2) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function() {
          var CSS_INTEGER = "[-\\+]?\\d+%?";
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();
        function isValidCSSUnit(color2) {
          return !!matchers.CSS_UNIT.exec(color2);
        }
        function stringInputToObject(color2) {
          color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names2[color2]) {
            color2 = names2[color2];
            named = true;
          } else if (color2 == "transparent") {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          }
          var match;
          if (match = matchers.rgb.exec(color2)) {
            return { r: match[1], g: match[2], b: match[3] };
          }
          if (match = matchers.rgba.exec(color2)) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
          }
          if (match = matchers.hsl.exec(color2)) {
            return { h: match[1], s: match[2], l: match[3] };
          }
          if (match = matchers.hsla.exec(color2)) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
          }
          if (match = matchers.hsv.exec(color2)) {
            return { h: match[1], s: match[2], v: match[3] };
          }
          if (match = matchers.hsva.exec(color2)) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
          }
          if (match = matchers.hex8.exec(color2)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color2)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color2)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color2)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          var level, size;
          parms = parms || { level: "AA", size: "small" };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return { level, size };
        }
        function insertAfter(existingNode, newNode) {
          var _a;
          (_a = existingNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, existingNode.nextSibling);
          return existingNode;
        }
        function wrap(ele, wrapper) {
          ele.replaceWith(wrapper);
          wrapper.appendChild(ele);
          return ele;
        }
        function outerWidthWithMargin(ele) {
          const style = window.getComputedStyle(ele);
          return ele.getBoundingClientRect().width + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        function html(html2, doc = document) {
          const div = doc.createElement("div");
          div.innerHTML = html2;
          return div.children[0];
        }
        function throttle(func, wait, debounce3 = void 0) {
          let timeout;
          return function() {
            const context = this, args = arguments;
            const throttler = function() {
              timeout = null;
              func.apply(context, args);
            };
            if (debounce3)
              clearTimeout(timeout);
            if (debounce3 || !timeout) {
              timeout = setTimeout(throttler, wait);
            }
          };
        }
        function addClass(ele, className) {
          const classes = className.split(" ").filter((c2) => c2 !== "");
          if (className !== "" && classes.length) {
            ele.classList.add(...classes);
          }
          return ele;
        }
        function removeClass(ele, className) {
          const classes = className.split(" ").filter((c2) => c2 !== "");
          if (className !== "" && classes.length) {
            ele.classList.remove(...classes);
          }
          return ele;
        }
        function toggleClass(ele, className, state = void 0) {
          if (state != void 0) {
            ele.classList.toggle(className, state);
          } else if (state === true) {
            addClass(ele, className);
          } else {
            removeClass(ele, className);
          }
          return ele;
        }
        function emit(ele, eventName, detail = {}) {
          const event = new CustomEvent(eventName, {
            cancelable: true,
            bubbles: true,
            detail
          });
          ele.dispatchEvent(event);
          return event;
        }
        function eventDelegate(ele, eventName, selector, listener, payload = {}) {
          ele.addEventListener(eventName, (e) => {
            if (e.target.closest(selector)) {
              e.data = Object.assign({}, e.data || {}, payload);
              listener(e);
            }
          }, payload);
        }
        function setElementOffset(elem, options) {
          let curPosition;
          let curTop;
          let curLeft;
          let calculatePosition;
          let position = elem.style.position;
          let curElem = elem;
          let props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          let curOffset = getElementOffset(curElem);
          let curCSSTop = elem.style.top;
          let curCSSLeft = elem.style.left;
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = getElementPosition(curElem);
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            for (const k in props) {
              curElem.style.setProperty(k, props[k] + "px");
            }
          }
        }
        function getElementOffset(el) {
          const box = el.getBoundingClientRect();
          const docElem = document.documentElement;
          return {
            top: box.top + window.pageYOffset - docElem.clientTop,
            left: box.left + window.pageXOffset - docElem.clientLeft
          };
        }
        function getElementPosition(el) {
          const { top, left } = el.getBoundingClientRect();
          const { marginTop, marginLeft } = getComputedStyle(el);
          return {
            top: top - parseInt(marginTop, 10),
            left: left - parseInt(marginLeft, 10)
          };
        }
        const defaultOpts = {
          beforeShow: noop2,
          move: noop2,
          change: noop2,
          show: noop2,
          hide: noop2,
          color: "",
          type: "component",
          showInput: false,
          allowEmpty: true,
          showButtons: true,
          clickoutFiresChange: true,
          showInitial: false,
          showPalette: true,
          showPaletteOnly: false,
          hideAfterPaletteSelect: false,
          togglePaletteOnly: false,
          showSelectionPalette: true,
          localStorageKey: "",
          appendTo: "body",
          maxSelectionSize: 8,
          locale: "en",
          cancelText: "cancel",
          chooseText: "choose",
          togglePaletteMoreText: "more",
          togglePaletteLessText: "less",
          clearText: "Clear Color Selection",
          noColorSelectedText: "No Color Selected",
          preferredFormat: "name",
          containerClassName: "",
          replacerClassName: "",
          showAlpha: true,
          theme: "sp-light",
          palette: [
            ["#000000", "#444444", "#5b5b5b", "#999999", "#bcbcbc", "#eeeeee", "#f3f6f4", "#ffffff"],
            ["#f44336", "#744700", "#ce7e00", "#8fce00", "#2986cc", "#16537e", "#6a329f", "#c90076"],
            ["#f4cccc", "#fce5cd", "#fff2cc", "#d9ead3", "#d0e0e3", "#cfe2f3", "#d9d2e9", "#ead1dc"],
            ["#ea9999", "#f9cb9c", "#ffe599", "#b6d7a8", "#a2c4c9", "#9fc5e8", "#b4a7d6", "#d5a6bd"],
            ["#e06666", "#f6b26b", "#ffd966", "#93c47d", "#76a5af", "#6fa8dc", "#8e7cc3", "#c27ba0"],
            ["#cc0000", "#e69138", "#f1c232", "#6aa84f", "#45818e", "#3d85c6", "#674ea7", "#a64d79"],
            ["#990000", "#b45f06", "#bf9000", "#38761d", "#134f5c", "#0b5394", "#351c75", "#741b47"],
            ["#660000", "#783f04", "#7f6000", "#274e13", "#0c343d", "#073763", "#20124d", "#4c1130"]
          ],
          selectionPalette: [],
          disabled: false,
          offset: null
        }, spectrums = [], replaceInput = html([
          "<div class='sp-replacer'>",
          "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
          "<div class='sp-dd'>&#9660;</div>",
          "</div>"
        ].join("")), markup = function() {
          return [
            "<div class='sp-container sp-hidden'>",
            "<div class='sp-palette-container'>",
            "<div class='sp-palette sp-thumb sp-cf'></div>",
            "<div class='sp-palette-button-container sp-cf'>",
            "<button type='button' class='sp-palette-toggle'></button>",
            "</div>",
            "</div>",
            "<div class='sp-picker-container'>",
            "<div class='sp-top sp-cf'>",
            "<div class='sp-fill'></div>",
            "<div class='sp-top-inner'>",
            "<div class='sp-color'>",
            "<div class='sp-sat'>",
            "<div class='sp-val'>",
            "<div class='sp-dragger'></div>",
            "</div>",
            "</div>",
            "</div>",
            "<div class='sp-clear sp-clear-display'>",
            "</div>",
            "<div class='sp-hue'>",
            "<div class='sp-slider'></div>",
            "</div>",
            "</div>",
            "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
            "</div>",
            "<div class='sp-input-container sp-cf'>",
            "<input class='sp-input' type='text' spellcheck='false'  />",
            "</div>",
            "<div class='sp-initial sp-thumb sp-cf'></div>",
            "<div class='sp-button-container sp-cf'>",
            "<button class='sp-cancel' href='#'></button>",
            "<button type='button' class='sp-choose'></button>",
            "</div>",
            "</div>",
            "</div>"
          ].join("");
        }();
        function paletteTemplate(p, color2, className, opts) {
          const html2 = [];
          for (let i2 = 0; i2 < p.length; i2++) {
            const current = p[i2];
            if (current) {
              const tiny = tinycolor(current);
              let c2 = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
              c2 += tinycolor.equals(color2, current) ? " sp-thumb-active" : "";
              const formattedString = tiny.toString(opts.preferredFormat || "rgb");
              const swatchStyle = "background-color:" + tiny.toRgbString();
              html2.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c2 + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';"></span></span>');
            } else {
              html2.push('<span class="sp-thumb-el sp-clear-display" ><span class="sp-clear-palette-only" style="background-color: transparent;"></span></span>');
            }
          }
          return "<div class='sp-cf " + className + "'>" + html2.join("") + "</div>";
        }
        function hideAll() {
          for (let i2 = 0; i2 < spectrums.length; i2++) {
            if (spectrums[i2]) {
              spectrums[i2].hide();
            }
          }
        }
        function instanceOptions(options, element) {
          options = Object.assign({}, options);
          options.locale = options.locale || window.navigator.language;
          if (typeof options.locale === "string") {
            if (options.locale) {
              let parts = options.locale.split("-").map((p) => p.toLowerCase());
              if (parts[0] === parts[1]) {
                parts = [parts[0]];
              }
              options.locale = parts.join("-");
            }
            if (options.locale !== "en" && Spectrum2.localization[options.locale]) {
              options = Object.assign({}, options, Spectrum2.localization[options.locale]);
            }
          } else {
            options = Object.assign({}, options, options.locale);
          }
          const opts = Object.assign({}, defaultOpts, element.dataset, options);
          opts.callbacks = {
            "move": bind(opts.move, element),
            "change": bind(opts.change, element),
            "show": bind(opts.show, element),
            "hide": bind(opts.hide, element),
            "beforeShow": bind(opts.beforeShow, element)
          };
          return opts;
        }
        function spectrum(element, options) {
          let opts = instanceOptions(options, element), type = opts.type, flat = type === "flat", showSelectionPalette = opts.showSelectionPalette, localStorageKey = opts.localStorageKey, theme = opts.theme, callbacks = opts.callbacks, resize = throttle(reflow, 10), visible = false, isDragging = false, dragWidth = 0, dragHeight = 0, dragHelperHeight = 0, slideHeight = 0, alphaWidth = 0, alphaSlideHelperWidth = 0, slideHelperHeight = 0, currentHue = 0, currentSaturation = 0, currentValue = 0, currentAlpha = 1, palette = [], paletteArray = [], paletteLookup = {}, selectionPalette = opts.selectionPalette.slice(0), maxSelectionSize = opts.maxSelectionSize, draggingClass = "sp-dragging", abortNextInputChange = false, shiftMovementDirection = null;
          const doc = element.ownerDocument;
          const container = html(markup, doc);
          container.classList.add(theme);
          doc.body.appendChild(container);
          doc.body;
          let boundElement = element, disabled = false, pickerContainer = container.querySelector(".sp-picker-container"), dragger = container.querySelector(".sp-color"), dragHelper = container.querySelector(".sp-dragger"), slider = container.querySelector(".sp-hue"), slideHelper = container.querySelector(".sp-slider"), alphaSliderInner = container.querySelector(".sp-alpha-inner"), alphaSlider = container.querySelector(".sp-alpha"), alphaSlideHelper = container.querySelector(".sp-alpha-handle"), textInput = container.querySelector(".sp-input"), paletteContainer = container.querySelector(".sp-palette"), initialColorContainer = container.querySelector(".sp-initial"), cancelButton = container.querySelector(".sp-cancel"), clearButton = container.querySelector(".sp-clear"), chooseButton = container.querySelector(".sp-choose"), toggleButton = container.querySelector(".sp-palette-toggle"), isInput = boundElement.nodeName === "INPUT", isInputTypeColor = isInput && boundElement.getAttribute("type") === "color", shouldReplace = isInput && (type === "color" || isInputTypeColor), replacer = shouldReplace ? (() => {
            addClass(replaceInput, theme);
            addClass(replaceInput, opts.replacerClassName);
            return replaceInput;
          })() : null, offsetElement = shouldReplace ? replacer : boundElement, previewElement = replacer === null || replacer === void 0 ? void 0 : replacer.querySelector(".sp-preview-inner"), initialColor = opts.color || isInput && boundElement.value, colorOnShow = "", currentPreferredFormat = opts.preferredFormat, clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange, isEmpty = !initialColor, allowEmpty = opts.allowEmpty;
          let originalInputContainer;
          let colorizeElement;
          let colorizeElementInitialColor;
          let colorizeElementInitialBackground;
          const thisId = boundElement.getAttribute("id") || "";
          if (thisId !== void 0 && thisId.length > 0) {
            const labels = document.querySelectorAll(`label[for="${thisId}"]`);
            labels.forEach((label) => {
              label.addEventListener("click", function(e) {
                e.preventDefault();
                show();
                return false;
              });
            });
          }
          function applyOptions() {
            if (opts.showPaletteOnly) {
              opts.showPalette = true;
            }
            if (toggleButton) {
              toggleButton.textContent = opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText;
            }
            if (opts.palette) {
              palette = opts.palette.slice(0);
              paletteArray = Array.isArray(palette[0]) ? palette : [palette];
              paletteLookup = {};
              for (let i2 = 0; i2 < paletteArray.length; i2++) {
                for (let j = 0; j < paletteArray[i2].length; j++) {
                  const rgb2 = tinycolor(paletteArray[i2][j]).toRgbString();
                  paletteLookup[rgb2] = true;
                }
              }
              if (opts.showPaletteOnly && !initialColor) {
                initialColor = palette[0][0] === "" ? palette[0][0] : Object.keys(paletteLookup)[0];
              }
            }
            toggleClass(container, "sp-flat", flat);
            toggleClass(container, "sp-input-disabled", !opts.showInput);
            toggleClass(container, "sp-alpha-enabled", opts.showAlpha);
            toggleClass(container, "sp-clear-enabled", allowEmpty);
            toggleClass(container, "sp-buttons-disabled", !opts.showButtons);
            toggleClass(container, "sp-palette-buttons-disabled", !opts.togglePaletteOnly);
            toggleClass(container, "sp-palette-disabled", !opts.showPalette);
            toggleClass(container, "sp-palette-only", opts.showPaletteOnly);
            toggleClass(container, "sp-initial-disabled", !opts.showInitial);
            addClass(container, opts.containerClassName);
            reflow();
          }
          function offsetElementStart(e) {
            if (!disabled) {
              show();
            }
            e.stopPropagation();
            const target = e.target;
            if (!target.matches("input")) {
              e.preventDefault();
            }
          }
          function initialize() {
            var _a;
            applyOptions();
            const inputStyle = window.getComputedStyle(boundElement);
            originalInputContainer = html('<span class="sp-original-input-container"></span>');
            ["margin"].forEach((cssProp) => {
              originalInputContainer.style;
              originalInputContainer.style.setProperty(cssProp, inputStyle.getPropertyValue(cssProp));
            });
            if (inputStyle.display === "block") {
              originalInputContainer.style.display = "flex";
            }
            boundElement.style.display = "";
            if (shouldReplace) {
              insertAfter(boundElement, replacer);
              boundElement.style.display = "none";
            } else if (type === "text") {
              addClass(originalInputContainer, "sp-colorize-container");
              addClass(boundElement, "spectrum sp-colorize");
              wrap(boundElement, originalInputContainer);
            } else if (type === "component") {
              addClass(boundElement, "spectrum");
              wrap(boundElement, originalInputContainer);
              const addOn = html([
                "<div class='sp-colorize-container sp-add-on'>",
                "<div class='sp-colorize'></div> ",
                "</div>"
              ].join(""));
              addOn.style.width = boundElement.offsetHeight + "px";
              addOn.style.borderRadius = inputStyle.borderRadius;
              addOn.style.border = inputStyle.border;
              boundElement.classList.add("with-add-on");
              boundElement.before(addOn);
            }
            colorizeElement = (_a = boundElement.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector(".sp-colorize");
            colorizeElementInitialColor = (colorizeElement === null || colorizeElement === void 0 ? void 0 : colorizeElement.style.color) || "";
            colorizeElementInitialBackground = (colorizeElement === null || colorizeElement === void 0 ? void 0 : colorizeElement.style.backgroundColor) || "";
            if (!allowEmpty) {
              clearButton.style.display = "none";
            }
            if (flat) {
              boundElement.after(container);
              boundElement.style.display = "none";
            } else {
              let appendTo = opts.appendTo === "parent" ? boundElement.parentElement : opts.appendTo;
              if (!appendTo) {
                appendTo = document.body;
              }
              if (typeof appendTo !== "string") {
                appendTo.append(container);
              }
            }
            updateSelectionPaletteFromStorage();
            offsetElement === null || offsetElement === void 0 ? void 0 : offsetElement.addEventListener("click", offsetElementStart);
            offsetElement === null || offsetElement === void 0 ? void 0 : offsetElement.addEventListener("touchstart", offsetElementStart);
            if (boundElement.matches(":disabled") || opts.disabled) {
              disable();
            }
            container.addEventListener("click", (e) => e.stopPropagation());
            [textInput, boundElement].forEach(function(input) {
              if (!("value" in input)) {
                return;
              }
              input.addEventListener("change", () => {
                setFromTextInput(input.value);
              });
              input.addEventListener("paste", () => {
                setTimeout(() => {
                  setFromTextInput(input.value);
                }, 1);
              });
              input.addEventListener("keydown", (e) => {
                if (e.keyCode === 13) {
                  setFromTextInput(input.value);
                  if (input === boundElement) {
                    hide();
                  }
                }
              });
            });
            cancelButton.textContent = opts.cancelText;
            cancelButton.addEventListener("click", function(e) {
              e.stopPropagation();
              e.preventDefault();
              revert();
              hide();
            });
            clearButton.setAttribute("title", opts.clearText);
            clearButton.addEventListener("click", function(e) {
              e.stopPropagation();
              e.preventDefault();
              isEmpty = true;
              move();
              if (flat) {
                updateOriginalInput(true);
              }
            });
            chooseButton.textContent = opts.chooseText;
            chooseButton.addEventListener("click", (e) => {
              e.stopPropagation();
              e.preventDefault();
              if (isValid()) {
                updateOriginalInput(true);
                hide();
              }
            });
            toggleButton.textContent = opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText;
            toggleButton.addEventListener("click", (e) => {
              e.stopPropagation();
              e.preventDefault();
              opts.showPaletteOnly = !opts.showPaletteOnly;
              if (!opts.showPaletteOnly && !flat) {
                container.style.left = "-=" + (outerWidthWithMargin(pickerContainer) + 5);
              }
              applyOptions();
            });
            draggable(alphaSlider, function(dragX, dragY, e) {
              currentAlpha = dragX / alphaWidth;
              isEmpty = false;
              if (e.shiftKey) {
                currentAlpha = Math.round(currentAlpha * 10) / 10;
              }
              move();
            }, dragStart, dragStop);
            draggable(slider, function(dragX, dragY) {
              currentHue = dragY / slideHeight;
              isEmpty = false;
              if (!opts.showAlpha) {
                currentAlpha = 1;
              }
              move();
            }, dragStart, dragStop);
            draggable(dragger, function(dragX, dragY, e) {
              if (!e.shiftKey) {
                shiftMovementDirection = null;
              } else if (!shiftMovementDirection) {
                const oldDragX = currentSaturation * dragWidth;
                const oldDragY = dragHeight - currentValue * dragHeight;
                const furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                shiftMovementDirection = furtherFromX ? "x" : "y";
              }
              const setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
              const setValue = !shiftMovementDirection || shiftMovementDirection === "y";
              if (setSaturation) {
                currentSaturation = dragX / dragWidth;
              }
              if (setValue) {
                currentValue = (dragHeight - dragY) / dragHeight;
              }
              isEmpty = false;
              if (!opts.showAlpha) {
                currentAlpha = 1;
              }
              move();
            }, dragStart, dragStop);
            if (!!initialColor) {
              set2(initialColor);
              updateUI();
              currentPreferredFormat = tinycolor(initialColor).getFormat() || opts.preferredFormat;
              addColorToSelectionPalette(initialColor);
            } else if (initialColor === "") {
              set2(initialColor);
              updateUI();
            } else {
              updateUI();
            }
            if (flat) {
              show();
            }
            function paletteElementClick(e) {
              var _a2, _b;
              if (e.data && e.data.ignore) {
                const el = e.target.closest(".sp-thumb-el");
                set2(((_a2 = el === null || el === void 0 ? void 0 : el.dataset) === null || _a2 === void 0 ? void 0 : _a2.color) || "");
                move();
              } else {
                const el = e.target.closest(".sp-thumb-el");
                set2(((_b = el === null || el === void 0 ? void 0 : el.dataset) === null || _b === void 0 ? void 0 : _b.color) || "");
                move();
                if (opts.hideAfterPaletteSelect) {
                  updateOriginalInput(true);
                  hide();
                } else {
                  updateOriginalInput();
                }
              }
              return false;
            }
            const paletteEvents = ["click", "touchstart"];
            for (const paletteEvent of paletteEvents) {
              eventDelegate(paletteContainer, paletteEvent, ".sp-thumb-el", paletteElementClick);
              eventDelegate(initialColorContainer, paletteEvent, ".sp-thumb-el:nth-child(1)", paletteElementClick, { ignore: true });
            }
          }
          function updateSelectionPaletteFromStorage() {
            if (localStorageKey) {
              try {
                const localStorage2 = window.localStorage;
                const oldPalette = localStorage2[localStorageKey].split(",#");
                if (oldPalette.length > 1) {
                  delete localStorage2[localStorageKey];
                  for (const c2 of oldPalette) {
                    addColorToSelectionPalette(c2);
                  }
                }
              } catch (e) {
              }
              try {
                selectionPalette = window.localStorage[localStorageKey].split(";");
              } catch (e) {
              }
            }
          }
          function addColorToSelectionPalette(color2) {
            if (showSelectionPalette) {
              const rgb2 = tinycolor(color2).toRgbString();
              if (!paletteLookup[rgb2] && !selectionPalette.includes(rgb2)) {
                selectionPalette.push(rgb2);
                while (selectionPalette.length > maxSelectionSize) {
                  selectionPalette.shift();
                }
              }
              if (localStorageKey) {
                try {
                  window.localStorage[localStorageKey] = selectionPalette.join(";");
                } catch (e) {
                }
              }
            }
          }
          function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
              for (var i2 = 0; i2 < selectionPalette.length; i2++) {
                var rgb2 = tinycolor(selectionPalette[i2]).toRgbString();
                if (!paletteLookup[rgb2]) {
                  unique.push(selectionPalette[i2]);
                }
              }
            }
            return unique.reverse().slice(0, opts.maxSelectionSize);
          }
          function drawPalette() {
            const currentColor = get();
            const html2 = paletteArray.map((palette2, i2) => {
              return paletteTemplate(palette2, currentColor, "sp-palette-row sp-palette-row-" + i2, opts);
            });
            updateSelectionPaletteFromStorage();
            if (selectionPalette) {
              html2.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }
            paletteContainer.innerHTML = html2.join("");
          }
          function drawInitial() {
            if (opts.showInitial) {
              const initial = colorOnShow;
              const current = get();
              initialColorContainer.innerHTML = paletteTemplate([initial, current], current, "sp-palette-row-initial", opts);
            }
          }
          function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
              reflow();
            }
            isDragging = true;
            addClass(container, draggingClass);
            shiftMovementDirection = null;
            emit(boundElement, "dragstart", { color: get() });
          }
          function dragStop() {
            isDragging = false;
            removeClass(container, draggingClass);
            emit(boundElement, "dragstop", { color: get() });
          }
          function setFromTextInput(value) {
            if (abortNextInputChange) {
              abortNextInputChange = false;
              return;
            }
            if ((value === null || value === "") && allowEmpty) {
              set2("");
              move();
              updateOriginalInput();
            } else {
              const tiny = tinycolor(value);
              if (tiny.isValid()) {
                set2(tiny);
                move();
                updateOriginalInput();
              } else {
                textInput.classList.add("sp-validation-error");
              }
            }
          }
          function toggle() {
            if (visible) {
              hide();
            } else {
              show();
            }
          }
          function show() {
            if (visible) {
              reflow();
              return;
            }
            const event = emit(boundElement, "beforeShow", { color: get() });
            if (callbacks.beforeShow(event) === false || event.defaultPrevented) {
              return;
            }
            hideAll();
            visible = true;
            doc.addEventListener("keydown", onkeydown);
            doc.addEventListener("click", clickout);
            window.addEventListener("resize", resize);
            replacer === null || replacer === void 0 ? void 0 : replacer.classList.add("sp-active");
            container.classList.remove("sp-hidden");
            reflow();
            updateUI();
            colorOnShow = get();
            drawInitial();
            const e = emit(boundElement, "show", { color: colorOnShow });
            callbacks.show(e);
          }
          function onkeydown(e) {
            if (e.keyCode === 27) {
              hide();
            }
          }
          function clickout(e) {
            if (e.button == 2) {
              return;
            }
            if (isDragging) {
              return;
            }
            if (clickoutFiresChange) {
              updateOriginalInput(true);
            } else {
              revert();
            }
            hide();
          }
          function hide() {
            if (!visible || flat) {
              return;
            }
            visible = false;
            doc.removeEventListener("keydown", onkeydown);
            doc.removeEventListener("click", clickout);
            window.removeEventListener("resize", resize);
            replacer === null || replacer === void 0 ? void 0 : replacer.classList.remove("sp-active");
            container.classList.add("sp-hidden");
            const event = emit(boundElement, "hide", { color: get() });
            callbacks.hide(event);
          }
          function revert() {
            set2(colorOnShow, true);
            updateOriginalInput(true);
          }
          function set2(color2, ignoreFormatChange = false) {
            if (tinycolor.equals(color2, get())) {
              updateUI();
              return;
            }
            var newColor, newHsv;
            if ((!color2 || color2 === void 0) && allowEmpty) {
              isEmpty = true;
            } else {
              isEmpty = false;
              newColor = tinycolor(color2);
              newHsv = newColor.toHsv();
              currentHue = newHsv.h % 360 / 360;
              currentSaturation = newHsv.s;
              currentValue = newHsv.v;
              currentAlpha = newHsv.a;
            }
            updateUI();
            if (newColor && newColor.isValid() && !ignoreFormatChange) {
              currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
            }
          }
          function get(opts2 = {}) {
            if (allowEmpty && isEmpty) {
              return "";
            }
            return tinycolor.fromRatio({
              h: currentHue,
              s: currentSaturation,
              v: currentValue,
              a: Math.round(currentAlpha * 1e3) / 1e3
            }, { format: opts2.format || currentPreferredFormat });
          }
          function isValid() {
            return !textInput.classList.contains("sp-validation-error");
          }
          function move() {
            updateUI();
            const event = emit(boundElement, "move", { color: get() });
            callbacks.move(event);
          }
          function updateUI() {
            textInput.classList.remove("sp-validation-error");
            updateHelperLocations();
            const flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.style.backgroundColor = flatColor.toHexString();
            let format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
              if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                format = "rgb";
              }
            }
            let realColor = get({ format }), displayColor = "";
            if (previewElement) {
              previewElement.classList.remove("sp-clear-display");
              previewElement.style.backgroundColor = "transparent";
            }
            if (realColor === "") {
              previewElement === null || previewElement === void 0 ? void 0 : previewElement.classList.add("sp-clear-display");
            } else {
              const realHex = realColor.toHexString();
              const realRgb = realColor.toRgbString();
              if (previewElement) {
                if (realColor.getAlpha() === 1) {
                  previewElement.style.backgroundColor = realRgb;
                } else {
                  previewElement.style.backgroundColor = "transparent";
                  previewElement.style.filter = realColor.toFilter();
                }
              }
              if (opts.showAlpha) {
                const rgb2 = realColor.toRgb();
                rgb2.a = 0;
                const realAlpha = tinycolor(rgb2).toRgbString();
                alphaSliderInner.style.background = `linear-gradient(to right, ${realAlpha}, ${realHex})`;
              }
              displayColor = realColor.toString(format);
            }
            if (opts.showInput) {
              textInput.value = displayColor;
            }
            boundElement.value = displayColor;
            if (opts.type == "text" || opts.type == "component") {
              const color2 = realColor;
              if (color2 && colorizeElement) {
                const textColor = color2.isLight() || color2.getAlpha() < 0.4 ? "black" : "white";
                colorizeElement.style.backgroundColor = color2.toRgbString();
                colorizeElement.style.color = textColor;
              } else if (colorizeElement) {
                colorizeElement.style.backgroundColor = colorizeElementInitialBackground;
                colorizeElement.style.color = colorizeElementInitialColor;
              }
            }
            if (opts.showPalette) {
              drawPalette();
            }
            drawInitial();
          }
          function updateHelperLocations() {
            if (allowEmpty && isEmpty) {
              alphaSlideHelper.style.display = "none";
              slideHelper.style.display = "none";
              dragHelper.style.display = "none";
            } else {
              alphaSlideHelper.style.display = "block";
              slideHelper.style.display = "block";
              dragHelper.style.display = "block";
              let dragX = currentSaturation * dragWidth;
              let dragY = dragHeight - currentValue * dragHeight;
              dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));
              dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));
              dragHelper.style.top = dragY + "px";
              dragHelper.style.left = dragX + "px";
              const alphaX = currentAlpha * alphaWidth;
              alphaSlideHelper.style.left = alphaX - alphaSlideHelperWidth / 2 + "px";
              const slideY = currentHue * slideHeight;
              slideHelper.style.top = slideY - slideHelperHeight + "px";
            }
          }
          function updateOriginalInput(fireCallback = false) {
            let color2 = get(), hasChanged = !tinycolor.equals(color2, colorOnShow);
            if (color2) {
              color2.toString(currentPreferredFormat);
              addColorToSelectionPalette(color2);
            }
            if (fireCallback && hasChanged) {
              abortNextInputChange = true;
              const event = emit(boundElement, "change", { color: color2 });
              callbacks.change(event);
            }
          }
          function reflow() {
            if (!visible) {
              return;
            }
            dragWidth = dragger.getBoundingClientRect().width;
            dragHeight = dragger.getBoundingClientRect().height;
            dragHelperHeight = dragHelper.getBoundingClientRect().height;
            slider.getBoundingClientRect().width;
            slideHeight = slider.getBoundingClientRect().height;
            slideHelperHeight = slideHelper.getBoundingClientRect().height;
            alphaWidth = alphaSlider.getBoundingClientRect().width;
            alphaSlideHelperWidth = alphaSlideHelper.getBoundingClientRect().width;
            if (!flat) {
              container.style.position = "absolute";
              if (opts.offset) {
                setElementOffset(container, opts.offset);
              } else {
                setElementOffset(container, getOffset(container, offsetElement));
              }
            }
            updateHelperLocations();
            if (opts.showPalette) {
              drawPalette();
            }
            emit(boundElement, "reflow");
          }
          function destroy() {
            boundElement.style.display = "";
            boundElement.classList.remove("spectrum", "with-add-on", "sp-colorize");
            offsetElement.removeEventListener("click", offsetElementStart);
            offsetElement.removeEventListener("touchstart", offsetElementStart);
            container.remove();
            replacer === null || replacer === void 0 ? void 0 : replacer.remove();
            if (colorizeElement) {
              colorizeElement.style.backgroundColor = colorizeElementInitialBackground;
              colorizeElement.style.color = colorizeElementInitialColor;
            }
            const originalInputContainer2 = boundElement.closest(".sp-original-input-container");
            if (originalInputContainer2) {
              originalInputContainer2.after(boundElement);
              originalInputContainer2.remove();
            }
            spectrums[spect.id] = null;
          }
          function option(optionName = void 0, optionValue = void 0) {
            if (optionName === void 0) {
              return Object.assign({}, opts);
            }
            if (optionValue === void 0) {
              return opts[optionName];
            }
            opts[optionName] = optionValue;
            if (optionName === "preferredFormat") {
              currentPreferredFormat = opts.preferredFormat;
            }
            applyOptions();
          }
          function enable() {
            disabled = false;
            boundElement.disabled = false;
            offsetElement.classList.remove("sp-disabled");
          }
          function disable() {
            hide();
            disabled = true;
            boundElement.disabled = true;
            offsetElement.classList.add("sp-disabled");
          }
          function setOffset(coord) {
            opts.offset = coord;
            reflow();
          }
          initialize();
          let spect = {
            id: 0,
            show,
            hide,
            toggle,
            reflow,
            option,
            enable,
            disable,
            offset: setOffset,
            set: function(c2) {
              set2(c2);
              updateOriginalInput();
            },
            get,
            destroy,
            container
          };
          spect.id = spectrums.push(spect) - 1;
          return spect;
        }
        function getOffset(picker, input) {
          const extraY = 0;
          const dpWidth = picker.offsetWidth;
          const dpHeight = picker.offsetHeight;
          const inputHeight = input.offsetHeight;
          const doc = picker.ownerDocument;
          const docElem = doc.documentElement;
          const viewWidth = docElem.clientWidth + window.pageXOffset;
          const viewHeight = docElem.clientHeight + window.pageYOffset;
          const offset = getElementOffset(input);
          let offsetLeft = offset.left;
          let offsetTop = offset.top;
          offsetTop += inputHeight;
          offsetLeft -= Math.min(offsetLeft, offsetLeft + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offsetLeft + dpWidth - viewWidth) : 0);
          offsetTop -= Math.min(offsetTop, offsetTop + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);
          return {
            top: offsetTop,
            left: offsetLeft
          };
        }
        function noop2() {
        }
        function bind(func, obj) {
          const slice = Array.prototype.slice;
          const args = slice.call(arguments, 2);
          return function() {
            return func.apply(obj, args.concat(slice.call(arguments)));
          };
        }
        function draggable(element, onmove, onstart, onstop) {
          onmove = onmove || noop2;
          onstart = onstart || noop2;
          onstop = onstop || noop2;
          const doc = document;
          let dragging = false;
          let offset = {};
          let maxHeight = 0;
          let maxWidth = 0;
          const hasTouch = "ontouchstart" in window;
          const duringDragEvents = {};
          duringDragEvents["selectstart"] = prevent;
          duringDragEvents["dragstart"] = prevent;
          duringDragEvents["touchmove"] = move;
          duringDragEvents["mousemove"] = move;
          duringDragEvents["touchend"] = stop;
          duringDragEvents["mouseup"] = stop;
          function prevent(e) {
            if (e.stopPropagation) {
              e.stopPropagation();
            }
            if (e.preventDefault) {
              e.preventDefault();
            }
            e.returnValue = false;
          }
          function move(e) {
            if (dragging) {
              const t0 = "touches" in e && e.touches[0];
              const pageX = t0 && t0.pageX || e.pageX;
              const pageY = t0 && t0.pageY || e.pageY;
              const dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
              const dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
              if (hasTouch) {
                prevent(e);
              }
              onmove.apply(element, [dragX, dragY, e]);
            }
          }
          function start(e) {
            const rightclick = e.which ? e.which == 3 : e.button === 2;
            if (!rightclick && !dragging) {
              if (onstart.apply(element, arguments) !== false) {
                dragging = true;
                maxHeight = element.getBoundingClientRect().height;
                maxWidth = element.getBoundingClientRect().width;
                offset = getElementOffset(element);
                for (const eventName in duringDragEvents) {
                  doc.addEventListener(eventName, duringDragEvents[eventName]);
                }
                doc.body.classList.add("sp-dragging");
                move(e);
                prevent(e);
              }
            }
          }
          function stop() {
            if (dragging) {
              for (const eventName in duringDragEvents) {
                doc.removeEventListener(eventName, duringDragEvents[eventName]);
              }
              doc.body.classList.remove("sp-dragging");
              setTimeout(function() {
                onstop.apply(element, arguments);
              }, 0);
            }
            dragging = false;
          }
          element.addEventListener("touchstart", start);
          element.addEventListener("mousedown", start);
        }
        class Spectrum2 {
          static create(selector, options = {}) {
            const ele = this.wrap(selector);
            if (!ele) {
              let msg = "Unable to find element";
              if (typeof selector === "string") {
                msg += " - Selector: " + selector;
              }
              throw Error(msg);
            }
            return new this(ele, options);
          }
          static createIfExists(selector, options = {}) {
            const ele = this.wrap(selector);
            if (!ele) {
              return null;
            }
            return new this(ele, options);
          }
          static getInstance(selector, options = {}) {
            const ele = this.wrap(selector);
            return ele.__spectrum = ele.__spectrum || this.createIfExists(ele, options);
          }
          static hasInstance(selector) {
            const ele = this.wrap(selector);
            return ele.__spectrum !== void 0;
          }
          static createMultiple(selector, options = {}) {
            const instances2 = [];
            this.wrapList(selector).forEach((ele) => {
              instances2.push(this.create(ele, options));
            });
            return instances2;
          }
          static getInstanceMultiple(selector, options = {}) {
            const instances2 = [];
            this.wrapList(selector).forEach((ele) => {
              instances2.push(this.getInstance(ele, options));
            });
            return instances2;
          }
          static wrap(selector) {
            if (typeof selector === "string") {
              return document.querySelector(selector);
            } else if (selector.jquery) {
              return selector[0];
            } else {
              return selector;
            }
          }
          static wrapList(selector) {
            if (typeof selector === "string") {
              return Array.from(document.querySelectorAll(selector));
            } else if (selector.jquery) {
              return selector.toArray();
            } else {
              return Array.from(selector);
            }
          }
          static locale(locale, localization) {
            this.localization[locale] = localization;
            return this;
          }
          static registerJQuery($) {
            registerJQueryPlugin($);
          }
          constructor(ele, options = {}) {
            this.eventListeners = {};
            this.spectrum = spectrum(ele, options);
            this.ele = ele;
            this.options = options;
          }
          get id() {
            return this.spectrum.id;
          }
          get container() {
            if (!this.ele.__spectrum) {
              return this.ele;
            }
            return this.spectrum.container;
          }
          show() {
            this.spectrum.show();
            return this;
          }
          hide() {
            this.spectrum.hide();
            return this;
          }
          toggle() {
            this.spectrum.toggle();
            return this;
          }
          reflow() {
            this.spectrum.reflow();
            return this;
          }
          option(optionName, optionValue) {
            return this.spectrum.option(optionName, optionValue);
          }
          enable() {
            this.spectrum.enable();
            return this;
          }
          disable() {
            this.spectrum.disable();
            return this;
          }
          offset(coord) {
            this.spectrum.offset(coord);
            return this;
          }
          set(color2, ignoreFormatChange = false) {
            this.spectrum.set(color2, ignoreFormatChange);
            return this;
          }
          get() {
            return this.spectrum.get();
          }
          destroy() {
            this.destroyInnerObject();
            delete this.ele.__spectrum;
            return this;
          }
          rebuild(options) {
            this.destroyInnerObject();
            if (options) {
              this.options = Object.assign({}, this.options, options);
            }
            this.spectrum = spectrum(this.ele, this.options);
            return this;
          }
          destroyInnerObject() {
            this.spectrum.destroy();
            this.off();
          }
          listeners(eventName) {
            return this.eventListeners[eventName] || [];
          }
          on(eventName, listener, options = void 0) {
            this.ele.addEventListener(eventName, listener, options);
            this.eventListeners[eventName] = this.eventListeners[eventName] || [];
            this.eventListeners[eventName].push(listener);
            return () => {
              this.off(eventName, listener);
            };
          }
          once(eventName, listener, options = void 0) {
            const cancel = this.on(eventName, (e) => {
              listener(e);
              cancel();
            }, options);
            return cancel;
          }
          off(eventName = void 0, listener = void 0) {
            if (eventName && !this.eventListeners[eventName]) {
              return;
            }
            if (!eventName) {
              this.eventListeners = {};
              return;
            }
            if (listener) {
              this.eventListeners[eventName] = this.eventListeners[eventName].filter((l) => l === listener);
              this.ele.removeEventListener(eventName, listener);
            } else {
              for (const listener2 of this.eventListeners[eventName]) {
                this.ele.removeEventListener(eventName, listener2);
              }
              this.eventListeners[eventName] = [];
            }
          }
        }
        Spectrum2.defaultOptions = defaultOpts;
        Spectrum2.draggable = draggable;
        Spectrum2.localization = {};
        Spectrum2.palette = [];
        const jQuery = window.jQuery;
        if (jQuery) {
          registerJQueryPlugin(jQuery);
        }
        function registerJQueryPlugin($) {
          $.fn.spectrum = function(action = void 0, ...args) {
            if (typeof action === "string") {
              let returnValue = this;
              this.each(function() {
                const spect = this.__spectrum;
                if (spect) {
                  const method = spect[action];
                  if (!method) {
                    throw new Error("Spectrum: no such method: '" + action + "'");
                  }
                  if (action === "get") {
                    returnValue = spect.get();
                  } else if (action === "container") {
                    returnValue = $(spect.container);
                  } else if (action === "option") {
                    returnValue = spect.option.apply(spect, args);
                  } else if (action === "destroy") {
                    spect.destroy();
                  } else {
                    spect[action](...args);
                  }
                }
              });
              return returnValue;
            }
            return this.each(function() {
              const options = $.extend({}, $(this).data(), action);
              if (!$(this).is("input")) {
                options.type = "color";
              } else if (options.type == "flat") {
                options.type = "flat";
              } else if ($(this).attr("type") == "color") {
                options.type = "color";
              } else {
                options.type = options.type || "component";
              }
              if (Spectrum2.hasInstance(this)) {
                const sp = Spectrum2.getInstance(this);
                sp.options = options;
                sp.rebuild();
              } else {
                Spectrum2.getInstance(this, options);
              }
            });
          };
          $.fn.spectrum.load = true;
          $.fn.spectrum.loadOpts = {};
          $.fn.spectrum.draggable = draggable;
          $.fn.spectrum.defaults = defaultOpts;
          $.fn.spectrum.localization = Spectrum2.localization;
          $.fn.spectrum.palette = [];
          $.fn.spectrum.processNativeColorInputs = function() {
            const colorInputs = $("input[type=color]");
            if (colorInputs.length) {
              colorInputs.spectrum({
                preferredFormat: "hex6"
              });
            }
          };
        }
        return Spectrum2;
      });
    }
  });

  // node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "node_modules/hammerjs/hammer.js"(exports, module) {
      (function(window2, document2, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round2 = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn2, timeout, context) {
          return setTimeout(bindFn(fn2, context), timeout);
        }
        function invokeArrayArg(arg, fn2, context) {
          if (Array.isArray(arg)) {
            each2(arg, context[fn2], context);
            return true;
          }
          return false;
        }
        function each2(obj, iterator, context) {
          var i2;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined2) {
            i2 = 0;
            while (i2 < obj.length) {
              iterator.call(context, obj[i2], i2, obj);
              i2++;
            }
          } else {
            for (i2 in obj) {
              obj.hasOwnProperty(i2) && iterator.call(context, obj[i2], i2, obj);
            }
          }
        }
        function deprecate(method, name, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
          return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window2.console && (window2.console.warn || window2.console.log);
            if (log) {
              log.call(window2.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined2 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index2 = 1; index2 < arguments.length; index2++) {
              var source = arguments[index2];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend4 = deprecate(function extend5(dest, src, merge3) {
          var keys = Object.keys(src);
          var i2 = 0;
          while (i2 < keys.length) {
            if (!merge3 || merge3 && dest[keys[i2]] === undefined2) {
              dest[keys[i2]] = src[keys[i2]];
            }
            i2++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge2 = deprecate(function merge3(dest, src) {
          return extend4(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn2, context) {
          return function boundFn() {
            return fn2.apply(context, arguments);
          };
        }
        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each2(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each2(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node, parent) {
          while (node) {
            if (node == parent) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }
        function inStr(str2, find) {
          return str2.indexOf(find) > -1;
        }
        function splitStr(str2) {
          return str2.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i2 = 0;
            while (i2 < src.length) {
              if (findByKey && src[i2][findByKey] == find || !findByKey && src[i2] === find) {
                return i2;
              }
              i2++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i2 = 0;
          while (i2 < src.length) {
            var val = key ? src[i2][key] : src[i2];
            if (inArray(values, val) < 0) {
              results.push(src[i2]);
            }
            values[i2] = val;
            i2++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i2 = 0;
          while (i2 < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i2];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i2++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window2;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window2;
        var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START = 1;
        var INPUT_MOVE = 2;
        var INPUT_END = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input(manager, callback2) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback2;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input.prototype = {
          handler: function() {
          },
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter2(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i2 = 0;
          while (i2 < input.pointers.length) {
            pointers[i2] = {
              clientX: round2(input.pointers[i2].clientX),
              clientY: round2(input.pointers[i2].clientY)
            };
            i2++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter2(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter2(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round2(pointers[0].clientX),
              y: round2(pointers[0].clientY)
            };
          }
          var x = 0, y = 0, i2 = 0;
          while (i2 < pointersLength) {
            x += pointers[i2].clientX;
            y += pointers[i2].clientY;
            i2++;
          }
          return {
            x: round2(x / pointersLength),
            y: round2(y / pointersLength)
          };
        }
        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }
        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }
          if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }
        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP = {
          mousedown: INPUT_START,
          mousemove: INPUT_MOVE,
          mouseup: INPUT_END
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input.apply(this, arguments);
        }
        inherit(MouseInput, Input, {
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START,
          pointermove: INPUT_MOVE,
          pointerup: INPUT_END,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window2.MSPointerEvent && !window2.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput, Input, {
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input.apply(this, arguments);
        }
        inherit(TouchInput, Input, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i2, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START) {
            i2 = 0;
            while (i2 < targetTouches.length) {
              targetIds[targetTouches[i2].identifier] = true;
              i2++;
            }
          }
          i2 = 0;
          while (i2 < changedTouches.length) {
            if (targetIds[changedTouches[i2].identifier]) {
              changedTargetTouches.push(changedTouches[i2]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i2].identifier];
            }
            i2++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input, {
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i2 = lts.indexOf(lastTouch);
              if (i2 > -1) {
                lts.splice(i2, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
          for (var i2 = 0; i2 < this.lastTouches.length; i2++) {
            var t = this.lastTouches[i2];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }
        TouchAction.prototype = {
          set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          },
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          compute: function() {
            var actions = [];
            each2(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window2.CSS && window2.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          defaults: {},
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index2 = inArray(this.requireFail, otherRecognizer);
            if (index2 > -1) {
              this.requireFail.splice(index2, 1);
            }
            return this;
          },
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          canEmit: function() {
            var i2 = 0;
            while (i2 < this.requireFail.length) {
              if (!(this.requireFail[i2].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i2++;
            }
            return true;
          },
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          process: function(inputData) {
          },
          getTouchAction: function() {
          },
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          defaults: {
            pointers: 1
          },
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer2(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
          return new Manager(element, options);
        }
        Hammer2.VERSION = "2.0.7";
        Hammer2.defaults = {
          domEvents: false,
          touchAction: TOUCH_ACTION_COMPUTE,
          enable: true,
          inputTarget: null,
          inputClass: null,
          preset: [
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager(element, options) {
          this.options = assign({}, Hammer2.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each2(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager.prototype = {
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i2 = 0;
            while (i2 < recognizers.length) {
              recognizer = recognizers[i2];
              if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i2++;
            }
          },
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i2 = 0; i2 < recognizers.length; i2++) {
              if (recognizers[i2].options.event == recognizer) {
                return recognizers[i2];
              }
            }
            return null;
          },
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index2 = inArray(recognizers, recognizer);
              if (index2 !== -1) {
                recognizers.splice(index2, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each2(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each2(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i2 = 0;
            while (i2 < handlers.length) {
              handlers[i2](data);
              i2++;
            }
          },
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each2(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer2, {
          INPUT_START,
          INPUT_MOVE,
          INPUT_END,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager,
          Input,
          TouchAction,
          TouchInput,
          MouseInput,
          PointerEventInput,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each: each2,
          merge: merge2,
          extend: extend4,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer2;
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Hammer2;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = Hammer2;
        } else {
          window2[exportName] = Hammer2;
        }
      })(window, document, "Hammer");
    }
  });

  // js/Visiomatic.js
  var Visiomatic_exports = {};
  __export(Visiomatic_exports, {
    catalog: () => catalog_exports,
    control: () => control_exports,
    crs: () => crs_exports,
    layer: () => layer_exports,
    util: () => util_exports,
    vector: () => vector_exports
  });

  // js/catalog/index.js
  var catalog_exports = {};
  __export(catalog_exports, {
    Catalog: () => Catalog,
    catalogs: () => catalogs_exports
  });

  // js/catalog/Catalog.js
  var import_leaflet = __toESM(require_leaflet_src());
  var Catalog = import_leaflet.Class.extend({
    options: {
      name: "A catalog",
      attribution: "",
      color: "yellow",
      properties: ["mag"],
      propertyMask: void 0,
      units: [""],
      magLim: 20,
      magIndex: 0,
      magScaleType: "mag",
      regionType: "box",
      service: "Vizier@CDS",
      className: "logo-catalog-vizier",
      serviceURL: "https://vizier.unistra.fr/viz-bin",
      catalogURL: "/",
      objectURL: "/",
      authenticate: "false",
      nmax: 1e4,
      format: "text",
      draw: void 0
    },
    initialize: function(options) {
      import_leaflet.Util.setOptions(this, options);
      for (var key in this.options) {
        if (this.options[key] !== void 0) {
          this[key] = this.options[key];
        }
      }
      this.url = this.serviceURL + this.catalogURL;
      if (this.objectURL) {
        this.objURL = this.objectURL.startsWith("http") ? this.objectURL : this.serviceURL + this.objectURL;
      }
    },
    _csvToGeoJSON: function(str2) {
      const badreg = new RegExp("#|--|objName|string|^$"), lines = str2.split("\n"), geo = { type: "FeatureCollection", features: [] };
      for (var i2 in lines) {
        var line = lines[i2];
        if (badreg.test(line) === false) {
          var feature = {
            type: "Feature",
            id: "",
            properties: {
              items: []
            },
            geometry: {
              type: "Point",
              coordinates: [0, 0]
            }
          }, geometry = feature.geometry, properties = feature.properties;
          const cell = line.split(/[,;\t]/);
          feature.id = cell[0];
          geometry.coordinates[0] = parseFloat(cell[1]);
          geometry.coordinates[1] = parseFloat(cell[2]);
          const items = cell.slice(3);
          for (var j in items) {
            properties.items.push(this.readProperty(items[j]));
          }
          geo.features.push(feature);
        }
      }
      return geo;
    },
    readProperty: function(item) {
      const fitem = parseFloat(item);
      return isNaN(fitem) ? "--" : fitem;
    },
    toGeoJSON: function(data) {
      return this._csvToGeoJSON(data);
    },
    popup: function(feature) {
      var str2 = "<div>";
      if (this.objURL) {
        str2 += 'ID: <a href="' + import_leaflet.Util.template(this.objURL, (0, import_leaflet.extend)({
          id: feature.id,
          ra: feature.geometry.coordinates[0].toFixed(6),
          dec: feature.geometry.coordinates[1].toFixed(6)
        })) + '" target="_blank">' + feature.id + "</a></div>";
      } else {
        str2 += "ID: " + feature.id + "</div>";
      }
      str2 += '<TABLE style="margin:auto;"><TBODY style="vertical-align:top;text-align:left;">';
      var items = feature.properties.items;
      for (var i2 in this.properties) {
        if (this.propertyMask === void 0 || this.propertyMask[i2] === true) {
          str2 += "<TR><TD>" + this.properties[i2] + ":</TD><TD>" + (typeof items[i2] === "number" ? items[i2].toPrecision(4) : items[i2].toString()) + " ";
          if (this.units[i2]) {
            str2 += this.units[i2];
          }
          str2 += "</TD></TR>";
        }
      }
      str2 += "</TBODY></TABLE>";
      return str2;
    },
    draw: function(feature, latlng) {
      var refmag = feature.properties.items[this.magIndex];
      return (0, import_leaflet.circleMarker)(latlng, {
        radius: refmag ? 5 + (this.magScaleType === "mag" ? this.magLim - refmag : 2.5 * (this.magScaleType === "log" ? refmag - this.magLim : Math.log(refmag / this.magLim + 1))) : 8
      });
    },
    style: function(feature) {
      return { color: this.color, weight: 2 };
    },
    filter: function(feature) {
      return true;
    }
  });

  // js/catalog/catalogs.js
  var catalogs_exports = {};
  __export(catalogs_exports, {
    abell: () => abell,
    allWISE: () => allWISE,
    first: () => first,
    gaiaDR3: () => gaiaDR3,
    galexAIS: () => galexAIS,
    gleam: () => gleam,
    nvss: () => nvss,
    panstarrs1: () => panstarrs1,
    ppmXL: () => ppmXL,
    sdss: () => sdss,
    skybot: () => skybot,
    tgss: () => tgss,
    twomass: () => twomass,
    unWISE: () => unWISE,
    urat1: () => urat1
  });
  var import_leaflet4 = __toESM(require_leaflet_src());

  // js/vector/index.js
  var vector_exports = {};
  __export(vector_exports, {
    Ellipse: () => Ellipse,
    EllipseMarker: () => EllipseMarker,
    ellipse: () => ellipse,
    ellipseMarker: () => ellipseMarker
  });

  // js/vector/Ellipse.js
  var import_leaflet3 = __toESM(require_leaflet_src());

  // js/vector/EllipseMarker.js
  var import_leaflet2 = __toESM(require_leaflet_src());
  var EllipseMarker = import_leaflet2.Path.extend({
    CANVAS: true,
    SVG: false,
    options: {
      majAxis: 10,
      minAxis: 10,
      posAngle: 0,
      fill: true
    },
    initialize: function(latlng, options) {
      import_leaflet2.Util.setOptions(this, options);
      this._majAxis = this.options.majAxis;
      this._minAxis = this.options.majAxis;
      this._posAngle = this.options.posAngle;
      this._latlng = (0, import_leaflet2.latLng)(latlng);
      const deg = Math.PI / 180, cpa = Math.cos(this._posAngle * deg), spa = Math.sin(this._posAngle * deg), cpa2 = cpa * cpa, spa2 = spa * spa, a2 = this._majAxis * this._majAxis, b2 = this._minAxis * this._minAxis;
      let mx2 = a2 * cpa2 + b2 * spa2, my2 = a2 * spa2 + b2 * cpa2, mxy = (a2 - b2) * cpa * spa, c2 = mx2 * my2 - mxy * mxy;
      this._limX = Math.sqrt(mx2);
      this._limY = Math.sqrt(my2);
      if (c2 <= 0) {
        mx2 += 1;
        my2 += 1;
        c2 = mx2 * my2 - mxy * mxy;
      }
      this._cXX = my2 / c2;
      this._cYY = mx2 / c2;
      this._cXY = -2 * mxy / c2;
    },
    setLatLng: function(latlng) {
      this._latlng = (0, import_leaflet2.latLng)(latlng);
      this.redraw();
      return this.fire("move", { latlng: this._latlng });
    },
    getLatLng: function() {
      return this._latlng;
    },
    setParams: function(ellipseParams) {
      this.options.majAxis = this._majAxis = ellipseParams.majAxis;
      this.options.minAxis = this._minAxis = ellipseParams.minAxis;
      this.options.posAngle = this._posAngle = ellipseParams.posAngle;
      return this.redraw();
    },
    getParams: function() {
      const ellipseParams = {
        majAxis: this._majAxis,
        minAxis: this._minAxis,
        posAngle: this._posAngle
      };
      return ellipseParams;
    },
    _project: function() {
      this._point = this._map.latLngToLayerPoint(this._latlng);
      this._updateBounds();
    },
    _updateBounds: function() {
      const w = this._clickTolerance(), p = [this._limX + w, this._limY + w];
      this._pxBounds = new import_leaflet2.Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function() {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function() {
      this._renderer._updateEllipse(this);
    },
    _empty: function() {
      return this._majAxis && !this._renderer._bounds.intersects(this._pxBounds);
    },
    _containsPoint: function(p) {
      const dp = p.subtract(this._point), ct = this._clickTolerance(), dx = Math.abs(dp.x) - ct, dy = Math.abs(dp.y) - ct;
      return this._cXX * (dx > 0 ? dx * dx : 0) + this._cYY * (dy > 0 ? dy * dy : 0) + this._cXY * (dp.x * dp.y) <= 1;
    }
  });
  var ellipseMarker = function(latlng, options) {
    return new EllipseMarker(latlng, options);
  };
  import_leaflet2.Canvas.include({
    _updateEllipse: function(layer) {
      if (layer._empty()) {
        return;
      }
      var p = layer._point, ctx = this._ctx, r = layer._minAxis, s = layer._majAxis / layer._minAxis;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(layer._posAngle * Math.PI / 180);
      ctx.scale(1, s);
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2, false);
      ctx.restore();
      this._fillStroke(ctx, layer);
    }
  });
  import_leaflet2.SVG.include({
    _updateEllipse: function(layer) {
      const deg = Math.PI / 180, p = layer._point, r = layer._minAxis, r2 = layer._majAxis, dx = r * Math.cos(layer._posAngle * deg), dy = r * Math.sin(layer._posAngle * deg), arc = "a" + r + "," + r2 + " " + layer._posAngle + " 1,0 ";
      const d2 = layer._empty() ? "M0 0" : "M" + (p.x - dx) + "," + (p.y - dy) + arc + dx * 2 + "," + dy * 2 + " " + arc + -dx * 2 + "," + -dy * 2 + " ";
      this._setPath(layer, d2);
    }
  });

  // js/vector/Ellipse.js
  var Ellipse = EllipseMarker.extend({
    options: {
      fill: true
    },
    initialize: function(latlng, options) {
      import_leaflet3.Util.setOptions(this, options);
      const deg = Math.PI / 180, cpa = Math.cos(this.options.posAngle * deg), spa = Math.sin(this.options.posAngle * deg), cpa2 = cpa * cpa, spa2 = spa * spa, a2 = this.options.majAxis * this.options.majAxis, b2 = this.options.minAxis * this.options.minAxis;
      this._latlng = (0, import_leaflet3.latLng)(latlng);
      this._mLat2 = a2 * cpa2 + b2 * spa2;
      this._mLng2 = a2 * spa2 + b2 * cpa2;
      this._mLatLng = (a2 - b2) * cpa * spa;
    },
    getBounds: function() {
      const half = [this._limX, this._limY];
      return new import_leaflet3.LatLngBounds(
        this._map.layerPointToLatLng(this._point.subtract(half)),
        this._map.layerPointToLatLng(this._point.add(half))
      );
    },
    _project: function() {
      const map4 = this._map, crs = map4.options.crs;
      this._point = map4.latLngToLayerPoint(this._latlng);
      if (!this._majAxis1) {
        const lng = this._latlng.lng, lat = this._latlng.lat, deg = Math.PI / 180, clat = Math.cos(lat * deg), dl = lat < 90 ? 1e-3 : -1e-3, point8 = crs.project(this._latlng), dpointdlat = crs.project((0, import_leaflet3.latLng)(lat + dl, lng)).subtract(point8), dpointdlng = crs.project(
          (0, import_leaflet3.latLng)(
            lat,
            lng + dl * 1 / (clat > dl ? clat : dl)
          )
        ).subtract(point8), c11 = dpointdlat.x / dl, c12 = dpointdlng.x / dl, c21 = dpointdlat.y / dl, c22 = dpointdlng.y / dl;
        let mx2 = c11 * c11 * this._mLat2 + c12 * c12 * this._mLng2 + 2 * c11 * c12 * this._mLatLng, my2 = c21 * c21 * this._mLat2 + c22 * c22 * this._mLng2 + 2 * c21 * c22 * this._mLatLng, mxy = c11 * c21 * this._mLat2 + c12 * c22 * this._mLng2 + (c11 * c22 + c12 * c21) * this._mLatLng, a1 = 0.5 * (mx2 + my2), a2 = Math.sqrt(0.25 * (mx2 - my2) * (mx2 - my2) + mxy * mxy), a3 = mx2 * my2 - mxy * mxy;
        this._majAxis = this._majAxis1 = Math.sqrt(a1 + a2);
        this._minAxis = this._minAxis1 = a1 > a2 ? Math.sqrt(a1 - a2) : 0;
        this._posAngle = 0.5 * Math.atan2(2 * mxy, mx2 - my2) / deg;
        this._limX = this._limX1 = Math.sqrt(mx2);
        this._limY = this._limY1 = Math.sqrt(my2);
        if (a3 <= 0) {
          mx2 += 1;
          my2 += 1;
          a3 = mx2 * my2 - mxy * mxy;
        }
        this._cXX1 = my2 / a3;
        this._cYY1 = mx2 / a3;
        this._cXY1 = -2 * mxy / a3;
      }
      const scale2 = crs.scale(map4._zoom), invscale2 = 1 / (scale2 * scale2);
      this._majAxis = this._majAxis1 * scale2;
      this._minAxis = this._minAxis1 * scale2;
      this._limX = this._limX1 * scale2;
      this._limY = this._limY1 * scale2;
      this._cXX = this._cXX1 * invscale2;
      this._cYY = this._cYY1 * invscale2;
      this._cXY = this._cXY1 * invscale2;
      this._updateBounds();
    }
  });
  var ellipse = function(latlng, options) {
    return new Ellipse(latlng, options);
  };

  // js/catalog/catalogs.js
  var abell = new Catalog({
    service: "Vizier@CDS",
    name: "Abell clusters",
    className: "logo-catalog-vizier",
    attribution: "Rich Clusters of Galaxies (Abell et al. 1989) ",
    color: "orange",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VII/110A&-out=ACO,_RAJ2000,_DEJ2000,m10,Rich,Dclass&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=m10",
    properties: ["m<sub>10</sub>", "Richness", "D<sub>class</sub>"],
    units: ["", "", ""],
    objectURL: "/VizieR-5?-source=VII/110A&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var allWISE = new Catalog({
    service: "Vizier@CDS",
    name: "AllWISE",
    attribution: "AllWISE Data Release (Cutri et al. 2013)",
    color: "red",
    magLim: 18,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/328/allwise&-out=AllWISE,_RAJ2000,_DEJ2000,W1mag,W2mag,W3mag,W4mag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=W1mag",
    properties: [
      "W1<sub>mag</sub> (3.4\xB5m)",
      "W2<sub>mag</sub> (4.6\xB5m)",
      "W3<sub>mag</sub> (12\xB5m)",
      "W4<sub>mag</sub> (22\xB5m)"
    ],
    units: ["", "", "", ""],
    objectURL: "/VizieR-5?-source=II/328/allwise&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var first = new Catalog({
    service: "Vizier@CDS",
    name: "FIRST",
    className: "logo-catalog-vizier",
    attribution: "The FIRST Survey Catalog (Helfand et al. 2015)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/92/first14&-out=FIRST,_RAJ2000,_DEJ2000,Fpeak,fMaj,fMin,fPA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Fpeak",
    properties: ["F<sub>peak</sub>(1.4GHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=VIII/92/first14&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var gaiaDR3 = new Catalog({
    service: "Vizier@CDS",
    name: "Gaia DR3",
    className: "logo-catalog-vizier",
    attribution: "Third Gaia Data Release (2022)",
    color: "green",
    magLim: 21,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/355/gaiadr3&-out=Source,RA_ICRS,DE_ICRS,Gmag,BPmag,RPmag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Gmag",
    properties: [
      "G",
      "B<sub>P</sub>",
      "R<sub>P</sub>",
      "&#956;<sub>&#593;</sub> cos &#948;",
      "&#956;<sub>&#948;</sub>"
    ],
    units: ["", "", "", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/355/gaiadr3&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var galexAIS = new Catalog({
    service: "Vizier@CDS",
    name: "GALEX AIS",
    className: "logo-catalog-vizier",
    attribution: "GALEX catalogs of UV sources: All-sky Imaging Survey (Bianchi et al. 2011)",
    color: "magenta",
    magLim: 21,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/312/ais&-out=objid,_RAJ2000,_DEJ2000,FUV,NUV&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=FUV",
    properties: ["FUV<sub>AB</sub>", "NUV<sub>AB</sub>"],
    units: ["", ""],
    objectURL: "/VizieR-5?-source=II/312/ais&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var gleam = new Catalog({
    service: "Vizier@CDS",
    name: "GLEAM",
    className: "logo-catalog-vizier",
    attribution: "GaLactic and Extragalactic All-sky Murchison Wide Field Array (GLEAM) low-frequency extragalactic catalogue (Hurley-Walker et al. 2017)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/100/gleamegc&-out=GLEAM,RAJ2000,DEJ2000,Fintwide,awide,bwide,pawide&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Fintwide",
    properties: ["F<sub>int</sub>(170-231MHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["Jy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=-source=VIII/100/gleamegc&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 3600,
        minAxis: feature.properties.items[2] / 3600,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var nvss = new Catalog({
    service: "Vizier@CDS",
    name: "NVSS",
    className: "logo-catalog-vizier",
    attribution: "1.4GHz NRAO VLA Sky Survey (NVSS) (Condon et al. 1998)",
    color: "magenta",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=VIII/65/NVSS&-out=NVSS,_RAJ2000,_DEJ2000,S1.4,MajAxis,MinAxis,PA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-S1.4",
    properties: ["S<sub>1.4GHz</sub>", "Major axis", "Minor axis", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-5?-source=VIII/65/NVSS&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var panstarrs1 = new Catalog({
    service: "Vizier@CDS",
    name: "PanSTARRS 1",
    className: "logo-catalog-vizier",
    attribution: "Pan-STARRS release 1 (PS1) Survey (Chambers et al. 2016)",
    color: "yellow",
    magLim: 24,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/349&-out=objID,RAJ2000,DEJ2000,gKmag,rKmag,iKmag,zKmag,yKmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=rmag",
    properties: ["g", "r", "i", "z", "y"],
    units: ["", "", "", "", ""],
    objectURL: "/VizieR-5?-source=II/349/ps1&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var ppmXL = new Catalog({
    service: "Vizier@CDS",
    name: "PPMXL",
    className: "logo-catalog-vizier",
    attribution: "PPM-Extended, positions and proper motions (Roeser et al. 2008)",
    color: "green",
    magLim: 20,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/317&-out=PPMXL,RAJ2000,DEJ2000,Jmag,Hmag,Kmag,b1mag,b2mag,r1mag,r2mag,imag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Jmag",
    properties: [
      "J",
      "H",
      "K",
      "b<sub>1</sub>",
      "b<sub>2</sub>",
      "r<sub>1</sub>",
      "r<sub>2</sub>",
      "i",
      "&#956;<sub>&#593;</sub> cos &#948;",
      "&#956;<sub>&#948;</sub>"
    ],
    units: ["", "", "", "", "", "", "", "", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/317&-c={ra},{dec},eq=J2000&-c.rs=0.01"
  });
  var sdss = new Catalog({
    service: "Vizier@CDS",
    name: "SDSS release 12",
    className: "logo-catalog-vizier",
    attribution: "SDSS Photometric Catalog, Release 12 (Alam et al. 2015)",
    color: "yellow",
    magLim: 25,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=V/147&-out=SDSS12,RA_ICRS,DE_ICRS,umag,gmag,rmag,imag,zmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=rmag",
    properties: ["u", "g", "r", "i", "z"],
    units: ["", "", "", "", ""],
    objectURL: "/VizieR-5?-source=V/147/sdss12&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var tgss = new Catalog({
    service: "Vizier@CDS",
    name: "TGSS",
    className: "logo-catalog-vizier",
    attribution: "The GMRT 150 MHz all-sky radio survey. TGSS ADR1 (Intema et al. 2017)",
    color: "blue",
    magLim: 30,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=J/A%2bA/598/A78/table3&-out=TGSSADR,RAJ2000,DEJ2000,Stotal,Maj,Min,PA&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-Stotal",
    properties: ["F<sub>peak</sub>(150MHz)", "Major axis FWHM", "Minor axis FWHM", "Position angle"],
    units: ["mJy", "&#8243;", "&#8243;", "&#176;"],
    objectURL: "/VizieR-3?-source=-source=J/A%2bA/598/A78/table3&-c={ra},{dec},eq=J2000&-c.rs=0.2",
    draw: function(feature, latlng) {
      return ellipse(latlng, {
        majAxis: feature.properties.items[1] / 7200,
        minAxis: feature.properties.items[2] / 7200,
        posAngle: feature.properties.items[3] === "--" ? 0 : feature.properties.items[3]
      });
    }
  });
  var twomass = new Catalog({
    service: "Vizier@CDS",
    name: "2MASS",
    className: "logo-catalog-vizier",
    attribution: "2MASS All-Sky Catalog of Point Sources (Cutri et al. 2003)",
    color: "red",
    magLim: 17,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/246&-out=2MASS,RAJ2000,DEJ2000,Jmag,Hmag,Kmag&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=Jmag",
    properties: ["J", "H", "K"],
    units: ["", "", ""],
    objectURL: "/VizieR-5?-source=II/246&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var unWISE = new Catalog({
    service: "Vizier@CDS",
    name: "UnWISE",
    attribution: "The band-merged unWISE Catalog (Schlafly et al. 2019)",
    color: "red",
    magLim: 40,
    magScaleType: "linear",
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=II/363/unwise&-out=objID,_RAJ2000,_DEJ2000,FW1,FW2&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=-FW1",
    properties: ["F<sub>W1</sub> (3.4\xB5m)", "F<sub>W2</sub> (4.6\xB5m)"],
    units: [
      '<a href="https://vizier.cds.unistra.fr/viz-bin/VizieR?-6N&-out.form=H0&//*&-5N&<&quot;Label&quot;&catid%3D2363&tabid%3D1&colid%3D8" target=\u201D_blank\u201D>nMgy (Vega)</a>',
      '<a href="https://vizier.cds.unistra.fr/viz-bin/VizieR?-6N&-out.form=H0&//*&-5N&<&quot;Label&quot;&catid%3D2363&tabid%3D1&colid%3D9" target=\u201D_blank\u201D>nMgy (Vega)</a>'
    ],
    objectURL: "/VizieR-5?-source=II/363/unwise&-c={ra},{dec},eq=J2000&-c.rs=0.2"
  });
  var urat1 = new Catalog({
    service: "Vizier@CDS",
    name: "URAT1",
    className: "logo-catalog-vizier",
    attribution: "The first U.S. Naval Observatory Astrometric Robotic Telescope Catalog (Zacharias et al. 2015)",
    color: "yellow",
    magLim: 17,
    regionType: "box",
    catalogURL: "/asu-tsv?&-mime=csv&-source=I/329&-out=URAT1,RAJ2000,DEJ2000,f.mag,pmRA,pmDE&-out.meta=&-c.eq={sys}&-c={lng},{lat}&-c.bd={dlng},{dlat}&-out.max={nmax}&-sort=f.mag",
    properties: ["f<sub>mag</sub>", "&#956;<sub>&#593;</sub> cos &#948;", "&#956;<sub>&#948;</sub>"],
    units: ["", "mas/yr", "mas/yr"],
    objectURL: "/VizieR-5?-source=I/329&-c={ra},{dec},eq=J2000&-c.rs=0.1"
  });
  var skybot = new Catalog({
    service: "SkyBot@IMCCE",
    name: "SkyBot",
    className: "logo-catalog-imcce",
    attribution: "SkyBoT: a VO service to identify Solar System objects (Berthier et al. 2006)",
    color: "orange",
    magLim: 30,
    magIndex: 1,
    regionType: "box",
    serviceURL: "https://vo.imcce.fr/webservices/skybot/",
    catalogURL: "skybotconesearch_query.php?-mime=text&-from=VisiOmatic&-output=basic&-objFilter=111&-refsys=EQJ2000&-ep={jd}&-loc={observer}&-ra={lng}&-dec={lat}&-bd={dlng}x{dlat}",
    properties: ["Class", "V", "Position uncertainty", "&#956;<sub>&#593;</sub> cos &#948;", "&#956;<sub>&#948;</sub>", "Geocentric distance", "Heliocentric distance"],
    units: ["", "", "&#8243;", "&#8243;/h", "&#8243;/h", "au", "au"],
    objectURL: "https://vizier.unistra.fr/viz-bin/VizieR-5?-source=B/astorb/astorb&Name==={id}",
    format: "text",
    draw: function(feature, latlng) {
      const prop = feature.properties.items, djd = (this.jd[1] - this.jd[0]) * 24, clat = Math.abs(Math.cos(latlng.lat * Math.PI / 180)), invclat = clat > 0 ? 1 / clat : 1e-3, dlng = invclat * djd * prop[3] / 7200, dlat = djd * prop[4] / 7200;
      return (0, import_leaflet4.polyline)([
        [latlng.lat - dlat, latlng.lng - dlng],
        [latlng.lat + dlat, latlng.lng + dlng]
      ]);
    },
    style: function(feature) {
      return { color: this.color, weight: 8 };
    },
    toGeoJSON: function(str2) {
      const badreg = /#|No\s|^$/, sexare = /^([-+]?)(\d+)\s(\d+)\s(\d+\.?\d*)/, lines = str2.split("\n"), geo = { type: "FeatureCollection", features: [] };
      for (var i2 in lines) {
        var line = lines[i2];
        if (badreg.test(line) === false) {
          var feature = {
            type: "Feature",
            id: "",
            properties: {
              items: []
            },
            geometry: {
              type: "Point",
              coordinates: [0, 0]
            }
          }, geometry = feature.geometry, properties = feature.properties;
          const cell = line.split(" | ");
          feature.id = cell[1];
          ra = sexare.exec(cell[2]);
          dec = sexare.exec(cell[3]);
          geometry.coordinates = [
            Number(ra[2]) * 15 + Number(ra[3]) / 4 + Number(ra[4]) / 240,
            Number(dec[1] + "1") * (Number(dec[2]) + Number(dec[3]) / 60 + Number(dec[4]) / 3600)
          ];
          properties.items.push(cell[4]);
          properties.items.push(this.readProperty(cell[5]));
          properties.items.push(this.readProperty(cell[6]));
          const items = cell.slice(8);
          for (var j in items) {
            properties.items.push(this.readProperty(items[j]));
          }
          geo.features.push(feature);
        }
      }
      return geo;
    }
  });

  // js/control/index.js
  var control_exports = {};
  __export(control_exports, {
    CatalogUI: () => CatalogUI,
    ChannelUI: () => ChannelUI,
    Coords: () => Coords,
    DocUI: () => DocUI,
    ExtraMap: () => ExtraMap,
    FullScreen: () => FullScreen,
    ImageUI: () => ImageUI,
    PreferencesUI: () => PreferencesUI,
    ProfileUI: () => ProfileUI,
    RegionUI: () => RegionUI,
    Reticle: () => Reticle,
    Scale: () => Scale2,
    Sidebar: () => Sidebar,
    SnapshotUI: () => SnapshotUI,
    catalogUI: () => catalogUI,
    channelUI: () => channelUI,
    coords: () => coords,
    docUI: () => docUI,
    extraMap: () => extraMap,
    fullScreen: () => fullScreen,
    imageUI: () => imageUI,
    preferencesUI: () => preferencesUI,
    profileUI: () => profileUI,
    regionUI: () => regionUI,
    reticle: () => reticle,
    scale: () => scale,
    sidebar: () => sidebar,
    snapshotUI: () => snapshotUI
  });

  // js/control/logo.js
  var import_leaflet5 = __toESM(require_leaflet_src());
  import_leaflet5.Control.Attribution.include({
    _update: function() {
      if (!this._map) {
        return;
      }
      const attribs = [];
      for (var i2 in this._attributions) {
        if (this._attributions[i2]) {
          attribs.push(i2);
        }
      }
      const prefixAndAttribs = [];
      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }
      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(", "));
      }
      this._container.innerHTML = prefixAndAttribs.join(" &#169; ");
    }
  });
  import_leaflet5.Map.addInitHook(function() {
    if (this.options.visiomaticLogo !== false && this.options.attributionControl) {
      this.attributionControl.setPrefix(
        '<a id="logo-visiomatic" class="leaflet-control-attribution-logo "href="http://visiomatic.org" target="_blank">&nbsp;</a>'
      );
    }
  });

  // js/control/CatalogUI.js
  var import_leaflet11 = __toESM(require_leaflet_src());

  // js/util/index.js
  var util_exports = {};
  __export(util_exports, {
    RGB: () => RGB,
    VUtil: () => VUtil,
    rgb: () => rgb
  });

  // js/util/RGB.js
  var import_leaflet6 = __toESM(require_leaflet_src());
  var RGB = function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  };
  RGB.prototype = {
    clone: function() {
      return new RGB(this.r, this.g, this.b);
    },
    toStr: function() {
      let r = Math.round(this.r * 255), g = Math.round(this.g * 255), b = Math.round(this.b * 255);
      if (r < 0) {
        r = 0;
      } else if (r > 255) {
        r = 255;
      }
      if (g < 0) {
        g = 0;
      } else if (g > 255) {
        g = 255;
      }
      if (b < 0) {
        b = 0;
      } else if (b > 255) {
        b = 255;
      }
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    isOn: function() {
      return this.r > 0 || this.g > 0 || this.b > 0 ? true : false;
    }
  };
  var rgb = function(r, g, b) {
    if (r instanceof RGB) {
      return r;
    }
    if (typeof r === "string") {
      const bigint = parseInt("0x" + r.slice(1), 16);
      return new RGB(
        (bigint >> 16 & 255) / 255,
        (bigint >> 8 & 255) / 255,
        (bigint & 255) / 255
      );
    }
    if (import_leaflet6.Util.isArray(r)) {
      return new RGB(r[0], r[1], r[2]);
    }
    if (r === void 0 || r === null) {
      return r;
    }
    return new RGB(r, g, b);
  };

  // js/util/VUtil.js
  var import_leaflet7 = __toESM(require_leaflet_src());
  var VUtil = {
    REG_PDEC: "(\\d+\\.\\d*)",
    REG_FLOAT: "([-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)",
    requestURL: function(url, purpose, action, context, timeout) {
      var httpRequest;
      if (window.XMLHttpRequest) {
        httpRequest = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        try {
          httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
          try {
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e2) {
          }
        }
      }
      if (!httpRequest) {
        alert("Giving up: Cannot create an XMLHTTP instance for " + purpose);
        return false;
      }
      if (timeout) {
        httpRequest.timeout = timeout * 1e3;
        httpRequest.ontimeout = function() {
          alert("Time out while " + purpose);
        };
      }
      httpRequest.open("GET", url);
      if (context && context.options.credentials) {
        httpRequest.withCredentials = true;
      }
      if (context && context.options.authenticate === "csrftoken") {
        httpRequest.setRequestHeader("X-CSRFToken", this.getCookie("csrftoken"));
      }
      if (action) {
        httpRequest.onreadystatechange = function() {
          action(context, httpRequest);
        };
      }
      httpRequest.send();
    },
    parseURL: function(url) {
      const dict = {};
      url.replace(
        new RegExp("([^?=&]+)(=([^&]*))?", "g"),
        function($0, $1, $2, $3) {
          dict[$1] = $3;
        }
      );
      return dict;
    },
    updateURL: function(url, keyword, value) {
      const re = new RegExp("([?&])" + keyword + "=.*?(&|$)", "i"), separator = url.indexOf("?") !== -1 ? "&" : "?";
      return url.match(re) ? url.replace(re, "$1" + keyword + "=" + value + "$2") : url + separator + keyword + "=" + value;
    },
    checkDomain: function(url) {
      if (url.indexOf("//") === 0) {
        url = location.protocol + url;
      }
      return url.toLowerCase().replace(/([a-z])?:\/\//, "$1").split("/")[0];
    },
    isExternal: function(url) {
      return (url.indexOf(":") > -1 || url.indexOf("//") > -1) && this.checkDomain(location.href) !== this.checkDomain(url);
    },
    getCookie: function(cname) {
      const name = cname + "=", ca = document.cookie.split(";");
      for (var i2 = 0; i2 < ca.length; i2++) {
        var c2 = ca[i2];
        while (c2.charAt(0) === " ") {
          c2 = c2.substring(1);
        }
        if (c2.indexOf(name) === 0) {
          return c2.substring(name.length, c2.length);
        }
      }
      return "";
    },
    copyToClipboard: function(text) {
      if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
        const textarea = document.createElement("textarea");
        textarea.textContent = text;
        textarea.style.position = "fixed";
        document.body.appendChild(textarea);
        textarea.select();
        try {
          return document.execCommand("copy");
        } catch (ex) {
          console.warn("Copy to clipboard failed.", ex);
          return false;
        } finally {
          document.body.removeChild(textarea);
        }
      }
    },
    flashElement: function(elem) {
      import_leaflet7.DomUtil.addClass(elem, "leaflet-control-flash");
      setTimeout(function() {
        import_leaflet7.DomUtil.removeClass(elem, "leaflet-control-flash");
      }, 400);
    },
    readFITSKey: function(keyword, str2) {
      const key = keyword.trim().toUpperCase().substr(0, 8), nspace = 8 - key.length, keyreg = new RegExp(key + (nspace > 0 ? "\\ {" + nspace.toString() + "}" : "") + "=\\ *(?:'((?:\\ *[^'\\ ]+)*)\\ *'|([-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?))"), match = keyreg.exec(str2);
      if (!match) {
        return null;
      } else if (match[1]) {
        return match[1];
      } else {
        return match[2];
      }
    }
  };

  // js/control/UI.js
  var import_leaflet10 = __toESM(require_leaflet_src());
  var import_spectrum_vanilla = __toESM(require_spectrum());

  // js/control/widget/FlipSwitch.js
  var import_leaflet8 = __toESM(require_leaflet_src());
  var FlipSwitch = import_leaflet8.Evented.extend({
    options: {
      title: "Click to switch",
      checked: false,
      className: "leaflet-flipswitch"
    },
    initialize: function(parent, options) {
      options = import_leaflet8.Util.setOptions(this, options);
      const _this = this, className = options.className, button = import_leaflet8.DomUtil.create("div", className, parent), input = this._input = L.DomUtil.create("input", className, button), label = import_leaflet8.DomUtil.create("label", className, button);
      input.type = "checkbox";
      input.name = options.className;
      input.checked = options.checked;
      label.htmlFor = input.id = options.id;
      if (options.title) {
        label.title = options.title;
      }
      import_leaflet8.DomUtil.create("span", className + "-inner", label);
      import_leaflet8.DomUtil.create("span", className + "-button", label);
      import_leaflet8.DomEvent.disableClickPropagation(button).disableScrollPropagation(button);
      import_leaflet8.DomEvent.on(input, "change", function() {
        this.fire("change");
      }, this);
      return button;
    },
    value: function(val) {
      if (val === void 0) {
        return this._input.checked;
      } else {
        this._input.checked = val ? true : false;
        return this;
      }
    }
  });

  // js/control/widget/Spinbox.js
  var import_leaflet9 = __toESM(require_leaflet_src());
  var Spinbox = import_leaflet9.Evented.extend({
    options: {
      title: "Enter value",
      dmin: void 0,
      dmax: void 0,
      step: void 0,
      initValue: void 0,
      repButton: true,
      clickEvent: "click",
      instantUpdate: false,
      className: "leaflet-spinbox"
    },
    initialize: function(parent, options) {
      options = import_leaflet9.Util.setOptions(this, options);
      const _this = this, drag = this._drag = {
        startEvent: "touchstart mousedown",
        stopEvent: "touchend mouseup mouseout touchcancel",
        move: false,
        start: false,
        end: false,
        pos: false,
        target: false,
        delta: false,
        tmp: false,
        cnt: 0,
        step: options.step,
        prec: this._prec(options.step)
      }, wrap = this._wrap = import_leaflet9.DomUtil.create(
        "div",
        options.className,
        parent
      ), input = this._input = import_leaflet9.DomUtil.create(
        "input",
        options.className + "-input",
        wrap
      ), down = this._down = import_leaflet9.DomUtil.create(
        "div",
        options.className + "-down",
        wrap
      ), downIcon = this._downIcon = import_leaflet9.DomUtil.create(
        "div",
        options.className + "-down-icon",
        down
      ), up = this._up = import_leaflet9.DomUtil.create(
        "div",
        options.className + "-up",
        wrap
      ), upIcon = this._upIcon = import_leaflet9.DomUtil.create(
        "div",
        options.className + "-up-icon",
        up
      );
      input.type = "number";
      input.step = 0.1;
      import_leaflet9.DomEvent.disableClickPropagation(wrap).disableScrollPropagation(wrap);
      if (input.disabled === true) {
        options.disabled = true;
      }
      if (options.dmin === void 0) {
        options.dmin = -Number.MAX_VALUE;
      }
      if (options.dmax === void 0) {
        options.dmax = Number.MAX_VALUE;
      }
      if (options.step === void 0) {
        options.step = 1;
      }
      if (options.initValue === void 0) {
        options.initValue = (options.dmin + options.dmax) / 2;
      }
      this.value(options.initValue);
      input.title = options.title;
      down.title = "Decrease number by " + options.step;
      up.title = "Increase number by " + options.step;
      import_leaflet9.DomEvent.on(this._input, "change", function() {
        this.value(Math.min(
          Math.max(parseFloat(this._input.value), this.options.dmin),
          this.options.dmax
        ));
        this.fire("change");
      }, this);
      if (options.repButton === false) {
        import_leaflet9.DomEvent.on(down, options.clickEvent, function(e) {
          e.preventDefault();
          this._offset(e.currentTarget, -1);
        }, this);
        import_leaflet9.DomEvent.on(up, options.clickEvent, function(e) {
          e.preventDefault();
          this._offset(e.currentTarget, 1);
        }, this);
      } else {
        import_leaflet9.DomEvent.on(down, drag.startEvent, function(e) {
          input.blur();
          drag.move = true;
          drag.cnt = 0;
          drag.step = options.step;
          drag.prec = this._prec(drag.step);
          drag.delta = -1;
          this._offset(e.currentTarget, -1);
          if (!this.runButton) {
            drag.target = e.currentTarget;
            this.runButton = setTimeout(function() {
              _this._sboxRun();
            }, 500);
          }
        }, this);
        import_leaflet9.DomEvent.on(up, drag.startEvent, function(e) {
          input.blur();
          drag.move = true;
          drag.cnt = 0;
          drag.step = options.step;
          drag.prec = this._prec(drag.step);
          drag.delta = 1;
          this._offset(e.currentTarget, 1);
          if (!this.runButton) {
            drag.target = e.currentTarget;
            this.runButton = setTimeout(function() {
              _this._sboxRun();
            }, 500);
          }
        }, this);
        import_leaflet9.DomEvent.on(down, drag.stopEvent, function(e) {
          if (drag.move) {
            e.preventDefault();
            clearTimeout(this.runButton);
            this.runButton = false;
            drag.move = false;
            if (options.instantUpdate === false) {
              this.fire("change");
            }
          }
        }, this);
        import_leaflet9.DomEvent.on(up, drag.stopEvent, function(e) {
          if (drag.move) {
            e.preventDefault();
            clearTimeout(this.runButton);
            this.runButton = false;
            drag.move = false;
            if (options.instantUpdate === false) {
              this.fire("change");
            }
          }
        }, this);
      }
      if (options.disabled) {
        this.disable();
      }
      return wrap;
    },
    value: function(val) {
      if (val === void 0) {
        return parseFloat(this._input.value);
      } else {
        this._input.value = Number(val.toPrecision(10));
        return this;
      }
    },
    step: function(val) {
      if (val === void 0) {
        return this.options.step;
      } else {
        this.options.step = val;
        return this;
      }
    },
    disable: function() {
      const cname = "disabled";
      this._input.disabled = true;
      this._input.blur();
      import_leaflet9.DomUtil.addClass(this._wrap, cname);
      import_leaflet9.DomUtil.addClass(this._down, cname);
      import_leaflet9.DomUtil.addClass(this._up, cname);
      this.options.disabled = true;
    },
    enable: function() {
      const cname = "disabled";
      this._input.disabled = false;
      import_leaflet9.DomUtil.removeClass(this._wrap, cname);
      import_leaflet9.DomUtil.removeClass(this._down, cname);
      import_leaflet9.DomUtil.removeClass(this._up, cname);
      this.options.disabled = false;
    },
    _sboxRun: function() {
      const _this = this, options = this.options, drag = this._drag;
      let timer = 150;
      if (drag.cnt === 20) {
        timer = 50;
        drag.step = 10 * options.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 40) {
        timer = 10;
        drag.step = 100 * options.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 60) {
        drag.step = 1e3 * options.step;
        drag.prec = this._prec(drag.step);
      } else if (drag.cnt === 80) {
        drag.step = 1e4 * options.step;
        drag.prec = this._prec(drag.step);
      }
      drag.didRun = true;
      this._offset(this, drag.delta);
      drag.cnt++;
      this.runButton = setTimeout(function() {
        _this._sboxRun();
      }, timer);
    },
    _prec: function(step) {
      const dprec = -0.4342944 * Math.log(step);
      return dprec > 0 ? Math.ceil(dprec) : 0;
    },
    _offset: function(obj, direction) {
      const options = this.options, input = this._input, drag = this._drag;
      if (!this.disabled) {
        if (direction < 1) {
          var tmp = (parseFloat(input.value) - drag.step).toFixed(
            drag.prec
          );
          if (tmp >= options.dmin) {
            input.value = tmp;
            if (options.instantUpdate === true) {
              this.fire("change");
            }
          }
        } else {
          var tmp = (parseFloat(input.value) + drag.step).toFixed(
            drag.prec
          );
          if (tmp <= options.dmax) {
            input.value = tmp;
            if (options.instantUpdate === true) {
              this.fire("change");
            }
          }
        }
      }
    }
  });

  // js/control/UI.js
  var UI = import_leaflet10.Control.extend({
    options: {
      title: "a control related to VisiOmatic",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(baseLayers, options) {
      import_leaflet10.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-image";
      this._layers = baseLayers;
    },
    addTo: function(dest) {
      if (dest._sidebar) {
        this._sidebar = dest;
        this._map = dest._map;
        this._dialog = import_leaflet10.DomUtil.create("div", this._className + "-dialog");
        dest.addTab(
          this._id,
          this._className,
          this.options.title,
          this._dialog,
          this._sideClass
        );
        this._map.on("layeradd", this._checkVisiomatic, this);
        return dest;
      } else {
        return import_leaflet10.Control.prototype.addTo.call(this, dest);
      }
    },
    onAdd: function(map4) {
      const className = this._className, id = this._id, container = this._container = import_leaflet10.DomUtil.create(
        "div",
        className + " leaflet-bar"
      );
      container.setAttribute("aria-haspopup", true);
      import_leaflet10.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
      this._dialog = import_leaflet10.DomUtil.create("div", className + "-dialog", container);
      if (this.options.collapsed) {
        if (!import_leaflet10.Browser.android) {
          import_leaflet10.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
        }
        const toggle = this._toggle = import_leaflet10.DomUtil.create(
          "a",
          className + "-toggle leaflet-bar",
          container
        );
        toggle.href = "#";
        toggle.id = id + "-toggle";
        toggle.title = this.options.title;
        if (import_leaflet10.Browser.touch) {
          import_leaflet10.DomEvent.on(toggle, "click", import_leaflet10.DomEvent.stop, this).on(toggle, "click", this._expand, this);
        } else {
          import_leaflet10.DomEvent.on(toggle, "focus", this._expand, this);
        }
        this._map.on("click", this._collapse, this);
      } else {
        this._expand();
      }
      this._map.on("layeradd", this._checkVisiomatic, this);
      return this._container;
    },
    _checkVisiomatic: function(e) {
      const layer = e.layer;
      if (!layer || !layer.visioDefault) {
        return;
      }
      this._layer = layer;
      if (this._reloadFlag) {
        layer.once("load", this._resetDialog, this);
      } else {
        this._initDialog();
        this._reloadFlag = true;
      }
    },
    _initDialog: function() {
    },
    _resetDialog: function() {
      this._dialog.innerHTML = "";
      this._initDialog();
    },
    _addDialogBox: function(id) {
      const box = import_leaflet10.DomUtil.create(
        "div",
        this._className + "-box",
        this._dialog
      );
      if (id) {
        box.id = id;
      }
      return box;
    },
    _addDialogLine: function(label, dialogBox) {
      const line = import_leaflet10.DomUtil.create(
        "div",
        this._className + "-line",
        dialogBox
      ), text = import_leaflet10.DomUtil.create("div", this._className + "-label", line);
      text.innerHTML = label;
      return line;
    },
    _addDialogElement: function(line) {
      return import_leaflet10.DomUtil.create("div", this._className + "-element", line);
    },
    _expand: function() {
      import_leaflet10.DomUtil.addClass(this._container, this._className + "-expanded");
    },
    _collapse: function() {
      this._container.className = this._container.className.replace(
        " " + this._className + "-expanded",
        ""
      );
    },
    getActiveBaseLayer: function() {
      return this._activeBaseLayer;
    },
    _findActiveBaseLayer: function() {
      const layers = this._layers;
      this._prelayer = void 0;
      for (var l in layers) {
        var layer = layers[l];
        if (!layer.overlay) {
          if (!layer._map) {
            this._prelayer = layer;
          } else if (this._map.hasLayer(layer) && layer.visioDefault) {
            return layer;
          }
        }
      }
      return void 0;
    },
    _addButton: function(className, parent, subClassName = void 0, title2 = void 0, fn2 = void 0) {
      const button = import_leaflet10.DomUtil.create("div", className, parent), icon = import_leaflet10.DomUtil.create("div", className + "-icon", button);
      button.target = "_blank";
      if (subClassName) {
        button.id = className + "-" + subClassName;
      }
      if (fn2) {
        import_leaflet10.DomEvent.on(button, "click touch", fn2, this);
      }
      if (title2) {
        button.title = title2;
      }
      return button;
    },
    _addRadioButton: function(className, parent, value, checked, title2 = void 0, fn2 = void 0) {
      const label = import_leaflet10.DomUtil.create("label", className, parent), input = import_leaflet10.DomUtil.create("input", className, label), div = import_leaflet10.DomUtil.create("div", className, label);
      input.type = "radio";
      input.name = className;
      input.value = value;
      input.checked = checked;
      if (fn2) {
        import_leaflet10.DomEvent.on(input, "click touch", function() {
          fn2(value);
        }, this);
      }
      label.htmlFor = input.id = className + "-" + value;
      if (title2) {
        label.title = title2;
      }
      return input;
    },
    _addSelectMenu: function(className, parent, items, disabled = void 0, selected = void 0, title2 = void 0, fn2 = void 0) {
      const div = import_leaflet10.DomUtil.create("div", className, parent), select = import_leaflet10.DomUtil.create("select", className, div), choose = document.createElement("option"), opt = select.opt = [];
      choose.text = "choose";
      choose.disabled = true;
      if (!selected || selected < 0) {
        choose.selected = true;
      }
      select.add(choose, null);
      for (var i2 in items) {
        var index2 = parseInt(i2, 10);
        opt[index2] = document.createElement("option");
        opt[index2].text = items[index2];
        opt[index2].style["background-color"] = "orange";
        opt[index2].value = index2;
        if (disabled && disabled[index2]) {
          opt[index2].disabled = true;
        } else if (index2 === selected) {
          opt[index2].selected = true;
        }
        select.add(opt[index2], null);
      }
      if (this._container && !import_leaflet10.Browser.android && this.options.collapsed) {
        import_leaflet10.DomEvent.on(select, "mousedown", function() {
          import_leaflet10.DomEvent.off(
            this._container,
            "mouseout",
            this._collapse,
            this
          );
          this.collapsedOff = true;
        }, this);
        import_leaflet10.DomEvent.on(this._container, "mouseover", function() {
          if (this.collapsedOff) {
            import_leaflet10.DomEvent.on(
              this._container,
              "mouseout",
              this._collapse,
              this
            );
            this.collapsedOff = false;
          }
        }, this);
      }
      if (fn2) {
        import_leaflet10.DomEvent.on(select, "change keyup", fn2, this);
      }
      if (title2) {
        div.title = title2;
      }
      return select;
    },
    _addColorPicker: function(className, parent, subClassName, defaultColor, storageKey, title2 = void 0, fn2 = void 0) {
      const _this = this, colpick = import_leaflet10.DomUtil.create("color", className, parent), sp = import_spectrum_vanilla.default.create(
        colpick,
        {
          color: defaultColor,
          type: "color",
          allowEmpty: false,
          appendTo: this._map._container,
          cancelText: "CANCEL",
          chooseText: "OK",
          localStorageKey: storageKey,
          showAlpha: false,
          showInput: true,
          change: (e) => {
            const color2 = e.detail.color ? e.detail.color.toHexString() : null;
            colpick.style.backgroundColor = colpick.value = color2;
            if (fn2) {
              fn2(color2);
            }
            ;
          }
        }
      );
      colpick.type = "text";
      colpick.style.backgroundColor = colpick.value = defaultColor;
      colpick.id = className + "-" + subClassName;
      if (title2) {
        colpick.title = title2;
      }
      return colpick;
    },
    _addSwitchInput: function(layer, attr, box, label, title2 = void 0, checked) {
      const line = this._addDialogLine(label, box), elem = this._addDialogElement(line), flip = elem.flip = new FlipSwitch(elem, {
        checked,
        title: title2
      });
      flip.on("change", function() {
        layer._setAttr(attr, flip.value());
      }, this);
      return elem;
    },
    _addNumericalInput: function(layer, attr, box, label, title2 = void 0, initValue, step, min = void 0, max = void 0, fn2 = void 0) {
      const line = this._addDialogLine(label, box), elem = this._addDialogElement(line), spinbox = elem.spinbox = new Spinbox(elem, {
        step,
        dmin: min,
        dmax: max,
        initValue,
        title: title2
      });
      spinbox.on("change", function() {
        VUtil.flashElement(spinbox._input);
        layer._setAttr(attr, spinbox.value(), fn2);
      }, this);
      return elem;
    },
    _updateInput: function(elem, value) {
      if (elem.spinbox) {
        elem.spinbox.value(value);
      } else if (elem.flip) {
        elem.flip.value(value);
      }
    },
    _spinboxStep: function(min, max) {
      const step = parseFloat((Math.abs(max === min ? max : max - min) * 1e-3).toPrecision(1));
      return step === 0 ? 1 : step;
    },
    _updateLayerList: function() {
      if (!this._dialog) {
        return this;
      }
      if (this._layerList) {
        import_leaflet10.DomUtil.empty(this._layerList);
      } else {
        this._layerList = import_leaflet10.DomUtil.create(
          "div",
          "visiomatic-control-layerlist",
          this._dialog
        );
      }
      for (var i2 in this._layers) {
        this._addLayerItem(this._layers[i2]);
      }
      return this;
    },
    _addLayerItem: function(obj) {
      const _this = this, layerItem = import_leaflet10.DomUtil.create("div", "visiomatic-control-layer"), inputdiv = import_leaflet10.DomUtil.create(
        "div",
        "visiomatic-control-layerswitch",
        layerItem
      );
      if (obj.layer.notReady) {
        import_leaflet10.DomUtil.create("div", "visiomatic-control-activity", inputdiv);
      } else {
        const checked = this._map.hasLayer(obj.layer), newInput = document.createElement("input");
        newInput.type = "checkbox";
        newInput.className = "visiomatic-control-selector";
        newInput.defaultChecked = checked;
        newInput.layerId = import_leaflet10.Util.stamp(obj.layer);
        import_leaflet10.DomEvent.on(newInput, "click", function() {
          const inputs = this._layerList.getElementsByTagName("input"), inputsLen = inputs.length;
          this._handlingClick = true;
          for (i = 0; i < inputsLen; i++) {
            var input = inputs[i];
            if (!("layerId" in input)) {
              continue;
            }
            var obj2 = this._layers[input.layerId];
            if (input.checked && !this._map.hasLayer(obj2.layer)) {
              obj2.layer.addTo(this._map);
            } else if (!input.checked && this._map.hasLayer(obj2.layer)) {
              this._map.removeLayer(obj2.layer);
            }
          }
          this._handlingClick = false;
        }, this);
        inputdiv.appendChild(newInput);
      }
      const layerName = import_leaflet10.DomUtil.create(
        "div",
        "visiomatic-control-layername",
        layerItem
      );
      layerName.innerHTML = " " + obj.name;
      layerName.style.textShadow = "0px 0px 5px " + obj.layer.nameColor;
      import_leaflet10.DomEvent.on(
        layerName,
        "click touch",
        () => {
          obj.layer.bringToFront();
        },
        this
      );
      this._addButton(
        "visiomatic-control-trash",
        layerItem,
        void 0,
        "Delete layer",
        function() {
          _this.removeLayer(obj.layer);
          if (!obj.notReady) {
            _this._map.removeLayer(obj.layer);
          }
        }
      );
      this._layerList.appendChild(layerItem);
      return layerItem;
    },
    addLayer: function(layer, name, index2) {
      layer.on("add remove", this._onLayerChange, this);
      const id = import_leaflet10.Util.stamp(layer);
      this._layers[id] = {
        layer,
        name,
        index: index2
      };
      return this._updateLayerList();
    },
    removeLayer: function(layer) {
      layer.off("add remove", this._onLayerChange, this);
      layer.fire("trash", { index: this._layers[import_leaflet10.Util.stamp(layer)].index });
      layer.off("trash");
      delete this._layers[import_leaflet10.Util.stamp(layer)];
      return this._updateLayerList();
    },
    _onLayerChange: function(e) {
      if (!this._handlingClick) {
        this._updateLayerList();
      }
      const obj = this._layers[import_leaflet10.Util.stamp(e.target)], type = e.type === "add" ? "overlayadd" : "overlayremove";
      this._map.fire(type, obj);
    }
  });

  // js/control/CatalogUI.js
  var CatalogUI = UI.extend({
    defaultCatalogs: [
      gaiaDR3,
      twomass,
      sdss,
      panstarrs1,
      unWISE,
      skybot
    ],
    options: {
      title: "Catalog overlays",
      nativeCelSys: true,
      color: "#FFFF00",
      timeOut: 30,
      authenticate: false,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(catalogs, options) {
      import_leaflet11.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-catalog";
      this._layers = {};
      this._handlingClick = false;
      this._sideClass = "catalog";
      this._catalogs = catalogs ? catalogs : this.defaultCatalogs;
    },
    _initDialog: function() {
      const className = this._className, catalogs = this._catalogs, box = this._addDialogBox(), line = this._addDialogLine("", box), elem = this._addDialogElement(line), colpick = this._addColorPicker(
        className + "-color",
        elem,
        "catalog",
        this.options.color,
        "visiomaticCatalog",
        title = "Click to set catalog color"
      );
      const catselect = this._addSelectMenu(
        this._className + "-select",
        elem,
        catalogs.map(
          function(catalog) {
            return catalog.name;
          }
        ),
        void 0,
        -1,
        "Select Catalog",
        function() {
          let className2 = catalogs[catselect.selectedIndex - 1].className;
          if (className2 === void 0) {
            className2 = "";
          }
          import_leaflet11.DomUtil.setClass(
            catselect,
            this._className + "-select " + className2
          );
          return;
        }
      );
      import_leaflet11.DomEvent.on(catselect, "change keyup", function() {
        const catalog = catalogs[catselect.selectedIndex - 1];
        catselect.title = catalog.attribution + " from " + catalog.service;
      }, this);
      const elem2 = this._addDialogElement(line);
      this._addButton(
        className + "-button",
        elem2,
        "catalog",
        "Query catalog",
        function() {
          const index2 = catselect.selectedIndex - 1;
          if (index2 >= 0) {
            const catalog = catalogs[index2];
            catalog.color = colpick.value;
            catselect.selectedIndex = 0;
            catselect.title = "Select Catalog";
            import_leaflet11.DomUtil.setClass(catselect, this._className + "-select ");
            this._getCatalog(catalog, this.options.timeOut);
          }
        }
      );
    },
    _resetDialog: function() {
    },
    _getCatalog: async function(catalog, timeout) {
      const _this = this, map4 = this._map, wcs2 = map4.options.crs, sysflag = !wcs2.equatorialFlag && !this.options.nativeCelSys, center = sysflag ? wcs2.celSysToEq(map4.getCenter()) : map4.getCenter(), b = map4.getPixelBounds(), z = map4.getZoom(), templayer = new import_leaflet11.LayerGroup(null);
      templayer.notReady = true;
      this.addLayer(templayer, catalog.name);
      if (catalog.authenticate) {
        this.options.authenticate = catalog.authenticate;
      } else {
        this.options.authenticate = false;
      }
      const lngfac = Math.abs(Math.cos(center.lat * Math.PI / 180)), c2 = sysflag ? [
        wcs2.celSysToEq(map4.unproject(b.min, z)),
        wcs2.celSysToEq(map4.unproject((0, import_leaflet11.point)(b.min.x, b.max.y), z)),
        wcs2.celSysToEq(map4.unproject(b.max, z)),
        wcs2.celSysToEq(map4.unproject((0, import_leaflet11.point)(b.max.x, b.min.y), z))
      ] : [
        map4.unproject(b.min, z),
        map4.unproject((0, import_leaflet11.point)(b.min.x, b.max.y), z),
        map4.unproject(b.max, z),
        map4.unproject((0, import_leaflet11.point)(b.max.x, b.min.y), z)
      ];
      var response2, sys;
      if (!wcs2.equatorialFlag && this.options.nativeCelSys) {
        switch (wcs2.celSysCode) {
          case "ecliptic":
            sys = "E2000.0";
            break;
          case "galactic":
            sys = "G";
            break;
          case "supergalactic":
            sys = "S";
            break;
          default:
            sys = "J2000.0";
            break;
        }
      } else {
        sys = "J2000.0";
      }
      const jdmean = 0.5 * (wcs2.jd[0] + wcs2.jd[1]), observer = wcs2.obslatlng[0] == 0 && wcs2.obslatlng[1] == 0 ? "500" : wcs2.obslatlng[0].toFixed(4) + "," + wcs2.obslatlng[1].toFixed(4) + ",0";
      if (catalog.regionType === "box") {
        let dlng = (Math.max(
          wcs2._deltaLng(c2[0], center),
          wcs2._deltaLng(c2[1], center),
          wcs2._deltaLng(c2[2], center),
          wcs2._deltaLng(c2[3], center)
        ) - Math.min(
          wcs2._deltaLng(c2[0], center),
          wcs2._deltaLng(c2[1], center),
          wcs2._deltaLng(c2[2], center),
          wcs2._deltaLng(c2[3], center)
        )) * lngfac, dlat = Math.max(c2[0].lat, c2[1].lat, c2[2].lat, c2[3].lat) - Math.min(c2[0].lat, c2[1].lat, c2[2].lat, c2[3].lat);
        if (dlat < 1e-4) {
          dlat = 1e-4;
        }
        if (dlng < 1e-4) {
          dlng = 1e-4;
        }
        response2 = await fetch(
          import_leaflet11.Util.template(catalog.url, import_leaflet11.Util.extend({
            sys,
            jd: jdmean,
            observer: 568,
            lng: center.lng.toFixed(6),
            lat: center.lat.toFixed(6),
            dlng: dlng.toFixed(4),
            dlat: dlat.toFixed(4),
            nmax: catalog.nmax + 1,
            maglim: catalog.maglim
          }))
        );
      } else {
        const dr = Math.max(
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center),
          wcs2.distance(c2[0], center)
        );
        response2 = await fetch(
          import_leaflet11.Util.template(catalog.url, import_leaflet11.Util.extend({
            sys,
            jd: jdmean,
            observer: 568,
            lng: center.lng.toFixed(6),
            lat: center.lat.toFixed(6),
            dr: dr.toFixed(4),
            drm: (dr * 60).toFixed(4),
            nmax: catalog.nmax + 1
          }))
        );
      }
      if (response2.status == 200) {
        this._loadCatalog(catalog, templayer, await response2);
      } else {
        this.removeLayer(templayer);
        alert("Error " + response2.status + " while querying " + catalog.service + ".");
      }
    },
    _loadCatalog: async function(catalog, templayer, response2) {
      const wcs2 = this._map.options.crs;
      catalog.jd = wcs2.jd;
      const geo = catalog.toGeoJSON(
        catalog.format == "json" ? await response2.json() : await response2.text()
      ), geocatalog = (0, import_leaflet11.geoJson)(geo, {
        onEachFeature: function(feature, layer) {
          if (feature.properties && feature.properties.items) {
            layer.bindPopup(catalog.popup(feature));
          }
        },
        coordsToLatLng: function(coords2) {
          if (wcs2.equatorialFlag) {
            return new L.LatLng(coords2[1], coords2[0], coords2[2]);
          } else {
            const latLng11 = wcs2.eqToCelSys(
              L.latLng(coords2[1], coords2[0])
            );
            return new L.LatLng(latLng11.lat, latLng11.lng, coords2[2]);
          }
        },
        filter: function(feature) {
          return catalog.filter(feature);
        },
        pointToLayer: function(feature, latlng) {
          return catalog.draw(feature, latlng);
        },
        style: function(feature) {
          return catalog.style(feature);
        }
      });
      let excessflag = false;
      geocatalog.nameColor = catalog.color;
      geocatalog.addTo(this._map);
      this.removeLayer(templayer);
      if (geo.features.length > catalog.nmax) {
        geo.features.pop();
        excessflag = true;
      }
      this.addLayer(geocatalog, catalog.name + " (" + geo.features.length.toString() + (excessflag ? "+ entries)" : " entries)"));
      if (excessflag) {
        alert(
          "Selected area is too large: " + catalog.name + " sample has been truncated to the brightest " + catalog.nmax + " sources."
        );
      }
    }
  });
  var catalogUI = function(catalogs, options) {
    return new CatalogUI(catalogs, options);
  };

  // js/control/ChannelUI.js
  var import_leaflet12 = __toESM(require_leaflet_src());
  var ChannelUI = UI.extend({
    options: {
      title: "Channel mixing",
      mixingMode: void 0,
      cMap: "grey",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options) {
      import_leaflet12.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-channel";
      this._sideClass = "channel";
      this._settings = [];
      this._initsettings = [];
    },
    saveSettings: function(layer, settings, mode) {
      if (!settings[mode]) {
        settings[mode] = {};
      }
      const visio = layer.visio, setting = settings[mode];
      setting.channel = visio.channel;
      setting.cMap = visio.cMap;
      setting.rgb = [];
      for (let c2 in visio.rgb) {
        setting.rgb[c2] = visio.rgb[c2].clone();
      }
    },
    loadSettings: function(layer, settings, mode, keepChannel) {
      const setting = settings[mode];
      if (!setting) {
        return;
      }
      const visio = layer.visio, vrgb = visio.rgb, srgb = setting.rgb;
      if (!keepChannel) {
        visio.channel = setting.channel;
      }
      visio.cMap = setting.cMap;
      for (let c2 in srgb) {
        vrgb[c2] = srgb[c2].clone();
      }
    },
    _initDialog: function() {
      const _this = this, layer = this._layer, className = this._className, dialog = this._dialog;
      this.saveSettings(layer, this._initsettings, "mono");
      this.saveSettings(layer, this._initsettings, "color");
      this.saveSettings(layer, this._settings, "mono");
      this.saveSettings(layer, this._settings, "color");
      this._mode = this.options.mixingMode ? this.options.mixingMode : layer.visio.mixingMode;
      const box = this._addDialogBox(), modeline = this._addDialogLine("Mode:", box), modelem = this._addDialogElement(modeline), modeinput = import_leaflet12.DomUtil.create("div", className + "-radios", modelem);
      this._addRadioButton(
        className + "-radio",
        modeinput,
        "mono",
        this._mode === "mono",
        "Select mono-channel palettized mode",
        function() {
          _this.saveSettings(layer, _this._settings, _this._mode);
          for (let elem = box.lastChild; elem !== modeline; elem = box.lastChild) {
            box.removeChild(elem);
          }
          for (let elem = dialog.lastChild; elem !== box; elem = dialog.lastChild) {
            dialog.removeChild(elem);
          }
          _this._channelList = void 0;
          _this.loadSettings(layer, _this._settings, "mono");
          _this._initMonoDialog(layer, box);
          _this._mode = "mono";
        }
      );
      this._addRadioButton(
        className + "-radio",
        modeinput,
        "color",
        this._mode !== "mono",
        "Select color mixing mode",
        function() {
          _this.saveSettings(layer, _this._settings, _this._mode);
          for (let elem = box.lastChild; elem !== modeline; elem = box.lastChild) {
            box.removeChild(elem);
          }
          for (let elem = dialog.lastChild; elem !== box; elem = dialog.lastChild) {
            dialog.removeChild(elem);
          }
          _this.loadSettings(layer, _this._settings, "color");
          _this._channelList = void 0;
          _this._initColorDialog(layer, box);
          _this._mode = "color";
        }
      );
      if (_this._mode === "mono") {
        _this._initMonoDialog(layer, box);
      } else {
        _this._initColorDialog(layer, box);
      }
    },
    _initMonoDialog: function(layer, box) {
      const _this = this, channels = layer.visio.channelLabels, className = this._className;
      const line = this._addDialogLine("Channel:", box), elem = this._addDialogElement(line);
      layer.updateMono();
      this._chanSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        layer.visio.channelLabels,
        void 0,
        layer.visio.channel,
        "Select image channel",
        function() {
          layer.visio.channel = parseInt(
            this._chanSelect.selectedIndex - 1,
            10
          );
          this._updateChannel(layer, layer.visio.channel);
          layer.redraw();
        }
      );
      const line2 = this._addDialogLine("LUT:", box), elem2 = this._addDialogElement(line2);
      const cmapinput = import_leaflet12.DomUtil.create("div", className + "-cmaps", elem2), cbutton = [], cmaps = ["grey", "jet", "cold", "hot"], _changeMap = function(value) {
        layer._setAttr("cMap", value);
      };
      for (let c2 in cmaps) {
        cbutton[c2] = this._addRadioButton(
          "leaflet-cmap",
          cmapinput,
          cmaps[c2],
          cmaps[c2] === this.options.cMap,
          '"' + cmaps[c2].charAt(0).toUpperCase() + cmaps[c2].substr(1) + '" color-map',
          _changeMap
        );
      }
      this._addMinMax(layer, layer.visio.channel, box);
      layer.redraw();
    },
    _initColorDialog: function(layer, box) {
      const _this = this, visio = layer.visio, className = this._className, line = this._addDialogLine("Channel:", box), elem = this._addDialogElement(line), colpick = this._chanColPick = this._addColorPicker(
        className + "-color",
        elem,
        "channel",
        layer.getChannelColor(visio.channel),
        "visiomaticChannel",
        title = "Click to set channel color",
        fn = (colorStr) => {
          this._updateChannelMix(layer, visio.channel, rgb(colorStr));
        }
      );
      layer._setAttr("cMap", "grey");
      layer.updateMix();
      this._chanSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        visio.channelLabels,
        void 0,
        visio.channel,
        "Select image channel",
        function() {
          visio.channel = this._chanSelect.selectedIndex - 1;
          this._updateChannel(layer, visio.channel, updateColor = true);
        }
      );
      this._addMinMax(layer, visio.channel, box);
      const line2 = this._addDialogLine("Colors:", box), elem2 = this._addDialogElement(line2);
      this._addButton(
        className + "-button",
        elem2,
        "colormix-reset",
        "Reset color mix",
        function() {
          _this.loadSettings(layer, _this._initsettings, "color", true);
          layer.updateMix();
          this._updateColPick(layer, layer.visio.channel);
          this._updateChannelList(layer);
          layer.redraw();
        }
      );
      this._addButton(
        className + "-button",
        elem2,
        "colormix-auto",
        "Re-color active channels",
        function() {
          const nchan = visio.nChannel, vrgb = visio.rgb, defcol = layer.visioDefault.channelColors;
          let nchanon = 0;
          for (const c2 in vrgb) {
            nchanon++;
          }
          if (nchanon >= defcol.length) {
            nchanon = defcol.length - 1;
          }
          let cc = 0;
          for (const c2 in vrgb) {
            if (cc < nchanon) {
              vrgb[c2] = rgb(defcol[nchanon][cc++]);
            }
          }
          layer.updateMix();
          this._updateColPick(layer, layer.visio.channel);
          this._updateChannelList(layer);
          layer.redraw();
        }
      );
      _this._updateChannelList(layer);
      layer.redraw();
    },
    _addMinMax: function(layer, channel, box) {
      const visio = layer.visio, step = this._spinboxStep(
        visio.minValue[channel],
        visio.maxValue[channel]
      );
      this._minElem = this._addNumericalInput(
        layer,
        "minValue[" + channel + "]",
        box,
        "Min:",
        "Lower clipping limit in " + visio.channelUnits[channel],
        visio.minValue[channel],
        step
      );
      this._maxElem = this._addNumericalInput(
        layer,
        "maxValue[" + channel + "]",
        box,
        "Max:",
        "Upper clipping limit in " + visio.channelUnits[channel],
        visio.maxValue[channel],
        step
      );
    },
    _updateChannel: function(layer, channel, color2 = false) {
      const _this = this, visio = layer.visio, step = this._spinboxStep(
        visio.minValue[channel],
        visio.maxValue[channel]
      );
      _this._chanSelect.selectedIndex = channel + 1;
      if (updateColor) {
        this._updateColPick(layer, channel);
      }
      this._minElem.spinbox.value(visio.minValue[channel]).step(step).off("change").on("change", function() {
        layer._setAttr(
          "minValue[" + channel + "]",
          _this._minElem.spinbox.value()
        );
      }, this);
      this._maxElem.spinbox.value(visio.maxValue[channel]).step(step).off("change").on("change", function() {
        layer._setAttr(
          "maxValue[" + channel + "]",
          _this._maxElem.spinbox.value()
        );
      }, this);
    },
    _updateChannelMix: function(layer, channel, channel_rgb) {
      layer.rgbToMix(channel, channel_rgb);
      this._updateChannelList(layer);
      layer.redraw();
    },
    _updateChannelList: function(layer) {
      const visio = layer.visio, chanLabels = visio.channelLabels;
      let chanList = this._channelList, chanElems = this._channelElems, trashElems = this._trashElems;
      if (chanList) {
        import_leaflet12.DomUtil.empty(this._channelList);
      } else {
        chanList = this._channelList = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chanlist",
          this._dialog
        );
      }
      chanElems = this._channelElems = [];
      trashElems = this._trashElems = [];
      for (c in visio.rgb) {
        var chan = parseInt(c, 10), vrgb = visio.rgb[chan], chanElem = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-channel",
          chanList
        ), color2 = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chancolor",
          chanElem
        );
        color2.style.backgroundColor = vrgb.toStr();
        this._activateChanElem(color2, layer, chan);
        var label = import_leaflet12.DomUtil.create(
          "div",
          this._className + "-chanlabel",
          chanElem
        );
        label.innerHTML = chanLabels[c];
        this._activateChanElem(label, layer, chan);
        var trashElem = this._addButton(
          "visiomatic-control-trash",
          chanElem,
          void 0,
          "Delete channel"
        );
        this._activateTrashElem(trashElem, layer, chan);
        chanElems.push(chanElem);
        trashElems.push(trashElem);
      }
    },
    _updateColPick: function(layer, channel) {
      const rgbStr = layer.getChannelColor(channel);
      this._chanColPick.style.backgroundColor = this._chanColPick.value = rgbStr;
    },
    _activateTrashElem: function(trashElem, layer, channel) {
      import_leaflet12.DomEvent.on(trashElem, "click touch", function() {
        this._updateChannelMix(layer, channel, false);
        if (layer === this._layer && channel === layer.visio.channel) {
          this._updateColPick(layer, channel);
        }
      }, this);
    },
    _activateChanElem: function(chanElem, layer, channel) {
      import_leaflet12.DomEvent.on(chanElem, "click touch", function() {
        layer.visio.channel = channel;
        this._updateChannel(layer, channel, updateColor = true);
      }, this);
    }
  });
  var channelUI = function(options) {
    return new ChannelUI(options);
  };

  // js/control/Coords.js
  var import_leaflet13 = __toESM(require_leaflet_src());
  var Coords = import_leaflet13.Control.extend({
    options: {
      title: "Center coordinates. Click to change",
      position: "topright",
      coordinates: [
        {
          type: "world",
          label: "RA, Dec",
          units: "HMS",
          nativeCelSys: false
        },
        {
          type: "pixel",
          label: "x, y",
          units: "",
          nativeCelSys: false
        }
      ],
      centerQueryKey: "center",
      fovQueryKey: "fov",
      sesameURL: "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame"
    },
    onAdd: function(map4) {
      const _this = this, className = "leaflet-control-coords";
      this._wcsdialog = import_leaflet13.DomUtil.create("div", className + "-dialog");
      this._map.on("layeradd", this._checkVisiomatic, this);
      return this._wcsdialog;
    },
    _checkVisiomatic: function(e) {
      const layer = e.layer;
      if (!layer || !layer.visioDefault) {
        return;
      }
      this._layer = layer;
      if (this._reloadFlag) {
        layer.once("load", this._resetDialog, this);
      } else {
        this._initDialog();
        this._reloadFlag = true;
      }
    },
    _initDialog: function() {
      const _this = this, wcs2 = this._map.options.crs, projections = wcs2.projections, coordinates = this.options.coordinates, className = "leaflet-control-coords", dialog = this._wcsdialog;
      if (projections) {
        const extSelect = this._wcsext = import_leaflet13.DomUtil.create(
          "select",
          className + "-ext",
          dialog
        ), extOpt = [];
        import_leaflet13.DomEvent.disableClickPropagation(extSelect);
        extSelect.id = "leaflet-ext-select";
        extSelect.title = "Switch detector";
        for (var p in projections) {
          extOpt[p] = document.createElement("option");
          extOpt[p].text = projections[p].name;
          var extIndex = parseInt(p, 10);
          extOpt[p].value = extIndex;
          if (extIndex === 0) {
            extOpt[p].selected = true;
          }
          extSelect.add(extOpt[p], null);
        }
        import_leaflet13.DomEvent.on(extSelect, "change", function(e) {
          const map4 = _this._map, wcs3 = map4.options.crs;
          map4.panTo(wcs3.unproject(
            wcs3.projections[extSelect.value].centerPnt
          ));
        });
      }
      const coordSelect = import_leaflet13.DomUtil.create(
        "select",
        className + "-select",
        dialog
      ), coordOpt = [];
      import_leaflet13.DomEvent.disableClickPropagation(coordSelect);
      this._currentCoord = 0;
      coordSelect.id = "leaflet-coord-select";
      coordSelect.title = "Switch coordinate system";
      for (var c2 in coordinates) {
        coordOpt[c2] = document.createElement("option");
        coordOpt[c2].text = coordinates[c2].label;
        var coordIndex = parseInt(c2, 10);
        coordOpt[c2].value = coordIndex;
        if (coordIndex === 0) {
          coordOpt[c2].selected = true;
        }
        coordSelect.add(coordOpt[c2], null);
      }
      import_leaflet13.DomEvent.on(coordSelect, "change", function(e) {
        _this._currentCoord = coordSelect.value;
        _this._onDrag();
      });
      if (projections) {
        coordSelect.style["border-radius"] = "0px";
      }
      const input = this._wcsinput = import_leaflet13.DomUtil.create(
        "input",
        className + "-input",
        dialog
      );
      import_leaflet13.DomEvent.disableClickPropagation(input);
      input.type = "text";
      input.title = this.options.title;
      if ("webkitSpeechRecognition" in window) {
        input.setAttribute("x-webkit-speech", "x-webkit-speech");
      }
      map.on("move zoomend", this._onDrag, this);
      import_leaflet13.DomEvent.on(input, "focus", function() {
        this.setSelectionRange(0, this.value.length);
      }, input);
      import_leaflet13.DomEvent.on(input, "change", function() {
        this.panTo(this._wcsinput.value);
      }, this);
      const clipboardbutton = import_leaflet13.DomUtil.create(
        "div",
        className + "-clipboard",
        dialog
      ), clipboardicon = import_leaflet13.DomUtil.create(
        "div",
        className + "-clipboard-icon",
        clipboardbutton
      );
      clipboardbutton.title = "Copy to clipboard";
      import_leaflet13.DomEvent.on(clipboardbutton, "click", function() {
        const stateObj = {}, latlng = map.getCenter();
        let url = location.href;
        VUtil.flashElement(this._wcsinput);
        url = VUtil.updateURL(
          url,
          this.options.centerQueryKey,
          wcs2.latLngToHMSDMS(latlng)
        );
        url = VUtil.updateURL(
          url,
          this.options.fovQueryKey,
          wcs2.zoomToFov(map, map.getZoom(), latlng).toPrecision(4)
        );
        history.pushState(stateObj, "", url);
        VUtil.copyToClipboard(url);
      }, this);
      this._onDrag();
    },
    onRemove: function(map4) {
      map4.off("drag", this._onDrag);
    },
    _onDrag: function(e) {
      const wcs2 = this._map.options.crs, coordinate = this.options.coordinates[this._currentCoord];
      let extindex = -1;
      let pnt = wcs2.untransform(
        this._map._getCenterLayerPoint().add(
          this._map.getPixelOrigin()
        ),
        this._map._zoom
      );
      if (wcs2.projections) {
        extindex = wcs2.multiPntToIndex(pnt);
        this._wcsext.options[extindex].selected = true;
        pnt = wcs2.projections[extindex]._multiToPix(pnt);
      }
      if (coordinate.type == "pixel") {
        const prec = wcs2.nzoom - this._map._zoom > 0 ? 0 : 2;
        this._wcsinput.value = pnt.x.toFixed(prec) + " , " + pnt.y.toFixed(prec);
      } else {
        let latlng = extindex >= 0 ? wcs2.projections[extindex].unproject(pnt) : this._map.getCenter();
        if (wcs2.pixelFlag) {
          this._wcsinput.value = latlng.lng.toFixed(0) + " , " + latlng.lat.toFixed(0);
        } else {
          if (!coordinate.nativeCelSys && !wcs2.equatorialFlag) {
            latlng = wcs2.celSysToEq(latlng);
          } else if (coordinate.nativeCelSys && wcs2.equatorialFlag) {
            latlng = wcs2.eqToCelSys(latlng);
          }
          switch (coordinate.units) {
            case "HMS":
              this._wcsinput.value = wcs2.latLngToHMSDMS(latlng);
              break;
            case "deg":
              this._wcsinput.value = latlng.lng.toFixed(5) + " , " + latlng.lat.toFixed(5);
              break;
            default:
              this._wcsinput.value = latlng.lng.toFixed(1) + " , " + latlng.lat.toFixed(1);
              break;
          }
        }
      }
    },
    panTo: function(str2) {
      const wcs2 = this._map.options.crs, coordinate = this.options.coordinates[this._currentCoord];
      let latlng = wcs2.parseCoords(str2);
      if (latlng) {
        if (wcs2.pixelFlag) {
          this._map.panTo(latlng);
        } else {
          if (!coordinate.nativeCelSys && !wcs2.equatorialFlag) {
            latlng = wcs2.eqToCelSys(latlng);
          } else if (coordinate.nativeCelSys && wcs2.equatorialFlag) {
            latlng = wcs2.celSysToEq(latlng);
          }
          this._map.panTo(latlng);
        }
      } else {
        VUtil.requestURL(
          this.options.sesameURL + "/-oI/A?" + str2,
          "getting coordinates for " + str2,
          this._getCoordinates,
          this,
          10
        );
      }
    },
    _getCoordinates: function(self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const str2 = httpRequest.responseText, latlng = _self._map.options.crs.parseCoords(str2);
          if (latlng) {
            self2._map.panTo(latlng);
            self2._onDrag();
          } else {
            alert(str2 + ": Unknown location");
          }
        } else {
          alert("There was a problem with the request to the Sesame service at CDS");
        }
      }
    }
  });
  var coords = function(options) {
    return new Coords(options);
  };
  import_leaflet13.Map.mergeOptions({
    positionControl: false
  });
  import_leaflet13.Map.addInitHook(function() {
    if (this.options.positionControl) {
      this.positionControl = new Coords(this.options.positionControl);
      this.addControl(this.positionControl);
    }
  });

  // js/control/DocUI.js
  var import_leaflet14 = __toESM(require_leaflet_src());
  var DocUI = UI.extend({
    options: {
      title: "Documentation",
      pdflink: void 0,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(url, options) {
      import_leaflet14.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-doc";
      this._sideClass = "doc";
      this._url = url;
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, frameBox = import_leaflet14.DomUtil.create(
        "div",
        this._className + "-framebox",
        this._dialog
      ), iframe = this._iframe = import_leaflet14.DomUtil.create(
        "iframe",
        this._className + "-doc",
        frameBox
      );
      iframe.src = this._url;
      iframe.frameborder = 0;
      this._navHistory = [];
      this._navPos = 0;
      this._ignore = false;
      import_leaflet14.DomEvent.on(iframe, "load hashchange", this._onloadNav, this);
      const box = this._addDialogBox("visiomatic-doc-dialog"), line = this._addDialogLine("Navigate:", box), elem = this._addDialogElement(line);
      this._homeButton = this._addButton(
        className + "-button",
        elem,
        "home",
        "Navigate home",
        this._homeNav
      );
      this._backButton = this._addButton(
        className + "-button",
        elem,
        "back",
        "Navigate backward",
        this._backNav
      );
      this._forwardButton = this._addButton(
        className + "-button",
        elem,
        "forward",
        "Navigate forward",
        this._forwardNav
      );
      if (this.options.pdflink) {
        const pdfButton = this._addButton(
          className + "-button",
          elem,
          "pdf",
          "Download PDF version"
        );
        pdfButton.href = this.options.pdflink;
      }
    },
    _updateNav: function(newPos) {
      if (newPos !== this._navPos) {
        this._navPos = newPos;
        this._navIgnore = true;
        this._iframe.src = this._navHistory[this._navPos - 1];
        this._disableNav();
      }
    },
    _disableNav: function() {
      this._backButton.disabled = this._navPos === 1;
      this._forwardButton.disabled = this._navPos >= this._navHistory.length;
    },
    _backNav: function() {
      if (!this._backButton.disabled) {
        this._updateNav(Math.max(1, this._navPos - 1));
      }
    },
    _forwardNav: function() {
      if (!this._forwardButton.disabled) {
        this._updateNav(Math.min(this._navHistory.length, this._navPos + 1));
      }
    },
    _homeNav: function() {
      if (!this._backButton.disabled) {
        this._updateNav(1);
      }
    },
    _onloadNav: function() {
      if (true) {
        const as = this._iframe.contentDocument.getElementsByTagName("a");
        for (var i2 = 0; i2 < as.length; i2++) {
          if (VUtil.isExternal(as[i2].href)) {
            as[i2].setAttribute("target", "_blank");
          }
        }
        this._iframeLoad1 = true;
      }
      if (!this._navIgnore) {
        const href = this._iframe.contentWindow.location.href;
        if (href !== this._navHistory[this._navPos - 1]) {
          this._navHistory.splice(this._navPos, this._navHistory.length - this._navPos);
          this._navHistory.push(href);
          this._navPos = this._navHistory.length;
          this._disableNav();
        }
      } else {
        this._navIgnore = false;
      }
    }
  });
  var docUI = function(url, options) {
    return new DocUI(url, options);
  };

  // js/control/ExtraMap.js
  var import_leaflet15 = __toESM(require_leaflet_src());
  var ExtraMap = import_leaflet15.Control.extend({
    options: {
      title: "Navigation mini-map. Grab to navigate",
      position: "topright",
      width: 150,
      height: 150,
      collapsedWidth: 24,
      collapsedHeight: 24,
      toggleDisplay: true,
      autoToggleDisplay: false,
      zoomLevelFixed: false,
      zoomLevelOffset: -5,
      zoomAnimation: false,
      aimingRectOptions: {
        color: "#FFFFFF",
        weight: 1,
        clickable: false
      },
      shadowRectOptions: {
        color: "#FDC82F",
        weight: 1,
        opacity: 0,
        fillOpacity: 0,
        clickable: false
      },
      strings: { hideText: "Hide map", showText: "Show map" }
    },
    initialize: function(layer, options) {
      import_leaflet15.Util.setOptions(this, options);
      this.options.aimingRectOptions.clickable = false;
      this.options.shadowRectOptions.clickable = false;
      this._layer = layer;
    },
    onAdd: function(map4) {
      this._mainMap = map4;
      this._container = import_leaflet15.DomUtil.create("div", "leaflet-control-extramap");
      this._container.style.width = this.options.width + "px";
      this._container.style.height = this.options.height + "px";
      this._container.title = this.options.title;
      import_leaflet15.DomEvent.disableClickPropagation(this._container);
      import_leaflet15.DomEvent.on(this._container, "mousewheel", import_leaflet15.DomEvent.stopPropagation);
      this._extraMap = new import_leaflet15.Map(this._container, {
        attributionControl: false,
        zoomControl: false,
        zoomAnimation: this.options.zoomAnimation,
        autoToggleDisplay: this.options.autoToggleDisplay,
        touchZoom: !this._isZoomLevelFixed(),
        scrollWheelZoom: !this._isZoomLevelFixed(),
        doubleClickZoom: !this._isZoomLevelFixed(),
        boxZoom: !this._isZoomLevelFixed()
      });
      this._layer.addTo(this._extraMap);
      this._userToggledDisplay = false;
      this._minimized = false;
      if (this.options.toggleDisplay) {
        this._addToggleButton();
      }
      this._mainMap.whenReady(import_leaflet15.Util.bind(function() {
        this._extraMap.whenReady(import_leaflet15.Util.bind(function() {
          this._aimingRect = (0, import_leaflet15.rectangle)(
            this._mainMap.getBounds(),
            this.options.aimingRectOptions
          ).addTo(this._extraMap);
          this._shadowRect = (0, import_leaflet15.rectangle)(
            this._mainMap.getBounds(),
            this.options.shadowRectOptions
          ).addTo(this._extraMap);
          this._mainMap.on("moveend", this._onMainMapMoved, this);
          this._mainMap.on("move", this._onMainMapMoving, this);
          this._extraMap.on(
            "movestart",
            this._onExtraMapMoveStarted,
            this
          );
          this._extraMap.on("move", this._onExtraMapMoving, this);
          this._extraMap.on("moveend", this._onExtraMapMoved, this);
          this._extraMap.setView(
            this._mainMap.getCenter(),
            this._decideZoom(true)
          );
          this._setDisplay(this._decideMinimized());
        }, this));
      }, this));
      return this._container;
    },
    onRemove: function(map4) {
      this._mainMap.off("moveend", this._onMainMapMoved, this);
      this._mainMap.off("move", this._onMainMapMoving, this);
      this._extraMap.off("moveend", this._onExtraMapMoved, this);
      this._extraMap.removeLayer(this._layer);
    },
    changeLayer: function(layer) {
      this._extraMap.removeLayer(this._layer);
      this._layer = layer;
      this._extraMap.addLayer(this._layer);
    },
    _addToggleButton: function() {
      this._toggleDisplayButton = this.options.toggleDisplay ? this._addButton(
        "",
        this.options.strings.hideText,
        "leaflet-control-extramap-toggle-display leaflet-control-extramap-toggle-display-" + this.options.position,
        this._container,
        this._toggleDisplayButtonClicked,
        this
      ) : void 0;
      this._toggleDisplayButton.style.width = this.options.collapsedWidth + "px";
      this._toggleDisplayButton.style.height = this.options.collapsedHeight + "px";
    },
    _addButton: function(html, title2, className, container, fn2, context) {
      const link = import_leaflet15.DomUtil.create("a", className, container);
      link.innerHTML = html;
      link.href = "#";
      link.title = title2;
      const stop = import_leaflet15.DomEvent.stopPropagation;
      import_leaflet15.DomEvent.on(link, "click", stop).on(link, "mousedown", stop).on(link, "dblclick", stop).on(link, "click", import_leaflet15.DomEvent.preventDefault).on(link, "click", fn2, context);
      return link;
    },
    _toggleDisplayButtonClicked: function() {
      this._userToggledDisplay = true;
      if (!this._minimized) {
        this._minimize();
        this._toggleDisplayButton.title = this.options.strings.showText;
      } else {
        this._restore();
        this._toggleDisplayButton.title = this.options.strings.hideText;
      }
    },
    _setDisplay: function(minimize) {
      if (minimize !== this._minimized) {
        if (!this._minimized) {
          this._minimize();
        } else {
          this._restore();
        }
      }
    },
    _minimize: function() {
      if (this.options.toggleDisplay) {
        this._container.style.width = this.options.collapsedWidth + "px";
        this._container.style.height = this.options.collapsedHeight + "px";
        this._toggleDisplayButton.className += " minimized-" + this.options.position;
      } else {
        this._container.style.display = "none";
      }
      this._minimized = true;
    },
    _restore: function() {
      if (this.options.toggleDisplay) {
        this._container.style.width = this.options.width + "px";
        this._container.style.height = this.options.height + "px";
        this._toggleDisplayButton.className = this._toggleDisplayButton.className.replace("minimized-" + this.options.position, "");
      } else {
        this._container.style.display = "block";
      }
      this._minimized = false;
    },
    _onMainMapMoved: function(e) {
      if (!this._extraMapMoving) {
        this._mainMapMoving = true;
        this._extraMap.setView(
          this._mainMap.getCenter(),
          this._decideZoom(true)
        );
        this._setDisplay(this._decideMinimized());
      } else {
        this._extraMapMoving = false;
      }
      this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onMainMapMoving: function(e) {
      this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onExtraMapMoveStarted: function(e) {
      const lastAimingRect = this._aimingRect.getBounds(), sw = this._extraMap.latLngToContainerPoint(
        lastAimingRect.getSouthWest()
      ), ne = this._extraMap.latLngToContainerPoint(
        lastAimingRect.getNorthEast()
      );
      this._lastAimingRectPosition = { sw, ne };
    },
    _onExtraMapMoving: function(e) {
      if (!this._mainMapMoving && this._lastAimingRectPosition) {
        this._shadowRect.setBounds(new import_leaflet15.LatLngBounds(
          this._extraMap.containerPointToLatLng(
            this._lastAimingRectPosition.sw
          ),
          this._extraMap.containerPointToLatLng(
            this._lastAimingRectPosition.ne
          )
        ));
        this._shadowRect.setStyle({ opacity: 1, fillOpacity: 0.3 });
      }
    },
    _onExtraMapMoved: function(e) {
      if (!this._mainMapMoving) {
        this._extraMapMoving = true;
        this._mainMap.setView(
          this._extraMap.getCenter(),
          this._decideZoom(false)
        );
        this._shadowRect.setStyle({ opacity: 0, fillOpacity: 0 });
      } else {
        this._mainMapMoving = false;
      }
    },
    _isZoomLevelFixed: function() {
      const zoomLevelFixed = this.options.zoomLevelFixed;
      return this._isDefined(zoomLevelFixed) && this._isInteger(zoomLevelFixed);
    },
    _decideZoom: function(fromMaintoExtra) {
      if (!this._isZoomLevelFixed()) {
        if (fromMaintoExtra) {
          return this._mainMap.getZoom() + this.options.zoomLevelOffset;
        } else {
          const currentDiff = this._extraMap.getZoom() - this._mainMap.getZoom(), proposedZoom = this._extraMap.getZoom() - this.options.zoomLevelOffset;
          var toRet;
          if (currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._extraMap.getMinZoom() - this.options.zoomLevelOffset) {
            if (this._extraMap.getZoom() > this._lastExtraMapZoom) {
              toRet = this._mainMap.getZoom() + 1;
              this._extraMap.setZoom(this._extraMap.getZoom() - 1);
            } else {
              toRet = this._mainMap.getZoom();
            }
          } else {
            toRet = proposedZoom;
          }
          this._lastExtraMapZoom = this._extraMap.getZoom();
          return toRet;
        }
      } else {
        if (fromMaintoExtra) {
          return this.options.zoomLevelFixed;
        } else {
          return this._mainMap.getZoom();
        }
      }
    },
    _decideMinimized: function() {
      if (this._userToggledDisplay) {
        return this._minimized;
      }
      if (this.options.autoToggleDisplay) {
        if (this._mainMap.getBounds().contains(this._extraMap.getBounds())) {
          return true;
        }
        return false;
      }
      return this._minimized;
    },
    _isInteger: function(value) {
      return typeof value === "number";
    },
    _isDefined: function(value) {
      return typeof value !== "undefined";
    }
  });
  var extraMap = function(layer, options) {
    return new ExtraMap(layer, options);
  };
  import_leaflet15.Map.mergeOptions({
    extraMapControl: false
  });
  import_leaflet15.Map.addInitHook(function() {
    if (this.options.extraMapControl) {
      this.extraMapControl = new ExtraMap().addTo(this);
    }
  });

  // js/control/FullScreen.js
  var import_leaflet16 = __toESM(require_leaflet_src());
  var fullScreenApi = {
    supportsFullScreen: false,
    isFullScreen: function() {
      return false;
    },
    requestFullScreen: function() {
    },
    cancelFullScreen: function() {
    },
    fullScreenEventName: "",
    prefix: ""
  };
  var browserPrefixes = "webkit moz o ms khtml".split(" ");
  if (typeof document.exitFullscreen !== "undefined") {
    fullScreenApi.supportsFullScreen = true;
  } else {
    for (i2 = 0, il = browserPrefixes.length; i2 < il; i2++) {
      fullScreenApi.prefix = browserPrefixes[i2];
      if (typeof document[fullScreenApi.prefix + "CancelFullScreen"] !== "undefined") {
        fullScreenApi.supportsFullScreen = true;
        break;
      }
    }
  }
  var i2;
  var il;
  if (fullScreenApi.supportsFullScreen) {
    fullScreenApi.fullScreenEventName = fullScreenApi.prefix + "fullscreenchange";
    fullScreenApi.isFullScreen = function() {
      switch (this.prefix) {
        case "":
          return document.fullScreen;
        case "webkit":
          return document.webkitIsFullScreen;
        default:
          return document[this.prefix + "FullScreen"];
      }
    };
    fullScreenApi.requestFullScreen = function(el) {
      return this.prefix === "" ? el.requestFullscreen() : el[this.prefix + "RequestFullScreen"]();
    };
    fullScreenApi.cancelFullScreen = function(el) {
      return this.prefix === "" ? document.exitFullscreen() : document[this.prefix + "CancelFullScreen"]();
    };
  }
  window.fullScreenApi = fullScreenApi;
  var FullScreen = import_leaflet16.Control.extend({
    options: {
      title: "Toggle full screen mode",
      position: "topleft",
      forceSeparateButton: false
    },
    onAdd: function(map4) {
      const className = "leaflet-control-zoom-fullscreen";
      var container;
      if (map4.zoomControl && !this.options.forceSeparateButton) {
        container = map4.zoomControl._container;
      } else {
        container = import_leaflet16.DomUtil.create("div", "leaflet-bar");
      }
      this._addButton(
        this.options.title,
        className,
        container,
        this.toogleFullScreen,
        map4
      );
      return container;
    },
    _addButton: function(title2, className, container, fn2, context) {
      const link = import_leaflet16.DomUtil.create("a", className, container);
      link.href = "#";
      link.title = title2;
      import_leaflet16.DomEvent.addListener(link, "click", import_leaflet16.DomEvent.stopPropagation).addListener(link, "click", import_leaflet16.DomEvent.preventDefault).addListener(link, "click", fn2, context);
      import_leaflet16.DomEvent.addListener(container, fullScreenApi.fullScreenEventName, import_leaflet16.DomEvent.stopPropagation).addListener(container, fullScreenApi.fullScreenEventName, import_leaflet16.DomEvent.preventDefault).addListener(container, fullScreenApi.fullScreenEventName, this._handleEscKey, context);
      return link;
    },
    toogleFullScreen: function() {
      this._exitFired = false;
      const container = this._container;
      if (this._isFullscreen) {
        if (fullScreenApi.supportsFullScreen) {
          fullScreenApi.cancelFullScreen(container);
        } else {
          import_leaflet16.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
        }
        this.invalidateSize();
        this.fire("exitFullscreen");
        this._exitFired = true;
        this._isFullscreen = false;
      } else {
        if (fullScreenApi.supportsFullScreen) {
          fullScreenApi.requestFullScreen(container);
        } else {
          import_leaflet16.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
        }
        this.invalidateSize();
        this.fire("enterFullscreen");
        this._isFullscreen = true;
      }
    },
    _handleEscKey: function() {
      if (!fullScreenApi.isFullScreen(this) && !this._exitFired) {
        this.fire("exitFullscreen");
        this._exitFired = true;
        this._isFullscreen = false;
      }
    }
  });
  var fullScreen = function(options) {
    return new FullScreen(options);
  };
  import_leaflet16.Map.addInitHook(function() {
    if (this.options.fullScreenControl) {
      this.fullScreenControl = fullscreen(this.options.fullScreenControlOptions);
      this.addControl(this.fullScreenControl);
    }
  });

  // js/control/ImageUI.js
  var import_leaflet17 = __toESM(require_leaflet_src());
  var ImageUI = UI.extend({
    options: {
      title: "Image preferences",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options) {
      import_leaflet17.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-image";
      this._sideClass = "image";
      this._initsettings = {};
    },
    saveSettings: function(layer, settings) {
      if (!settings) {
        return;
      }
      const visio = layer.visio;
      settings.invertCMap = visio.invertCMap;
      settings.contrast = visio.contrast;
      settings.colorSat = visio.colorSat;
      settings.gamma = visio.gamma;
      settings.quality = visio.quality;
    },
    loadSettings: function(layer, settings) {
      if (!settings) {
        return;
      }
      const visio = layer.visio;
      visio.invertCMap = settings.invertCMap;
      this._updateInput(this._input.invertCMap, settings.invertCMap);
      visio.contrast = settings.contrast;
      this._updateInput(this._input.contrast, settings.contrast);
      visio.colorSat = settings.colorSat;
      this._updateInput(this._input.colorSat, settings.colorSat);
      visio.gamma = settings.gamma;
      this._updateInput(this._input.gamma, settings.gamma);
      visio.quality = settings.quality;
      this._updateInput(this._input.quality, settings.quality);
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, visio = layer.visio, map4 = this._map;
      this._input = {};
      this.saveSettings(layer, this._initsettings);
      this._input.invertCMap = this._addSwitchInput(
        layer,
        "invertCMap",
        this._dialog,
        "Invert:",
        "Invert color map(s)",
        visio.invertCMap
      );
      this._input.contrast = this._addNumericalInput(
        layer,
        "contrast",
        this._dialog,
        "Contrast:",
        "Adjust Contrast. 1.0: normal",
        visio.contrast,
        0.05,
        0,
        100
      );
      this._input.colorSat = this._addNumericalInput(
        layer,
        "colorSat",
        this._dialog,
        "Color Sat.:",
        "Adjust Color Saturation. 0: B&W, 1.0: normal",
        visio.colorSat,
        0.05,
        0,
        5,
        layer.updateMix
      );
      this._input.gamma = this._addNumericalInput(
        layer,
        "gamma",
        this._dialog,
        "Gamma:",
        "Adjust Gamma correction. The standard value is 2.2",
        visio.gamma,
        0.05,
        0.5,
        5
      );
      this._input.quality = this._addNumericalInput(
        layer,
        "quality",
        this._dialog,
        "JPEG quality:",
        "Adjust JPEG compression quality. 1: lowest, 100: highest",
        visio.quality,
        1,
        1,
        100
      );
      const line = this._addDialogLine("Reset:", this._dialog), elem = this._addDialogElement(line);
      this._addButton(
        className + "-button",
        elem,
        "image-reset",
        "Reset image settings",
        function() {
          _this.loadSettings(layer, _this._initsettings);
          if (layer.visio === "color") {
            layer.updateMix();
          }
          layer.redraw();
        }
      );
    }
  });
  var imageUI = function(options) {
    return new ImageUI(options);
  };

  // js/control/PreferencesUI.js
  var import_leaflet18 = __toESM(require_leaflet_src());
  var PreferencesUI = UI.extend({
    options: {
      title: "Preferences",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options) {
      import_leaflet18.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-preferences";
      this._sideClass = "preferences";
    },
    _initDialog: function() {
      const className = this._className, line = this._addDialogLine("Theme:", this._dialog), elem = this._addDialogElement(line), prefix = "visiomatic-theme-", defaultTheme = localStorage.getItem("visiomaticDefaultTheme");
      this._themeList = getComputedStyle(document.documentElement).getPropertyValue("--visiomatic-theme-names").split(/\s+/);
      this._themeClassList = this._themeList.map(
        (theme) => prefix + theme.toLowerCase()
      );
      this._defaultTheme = defaultTheme ? defaultTheme : getComputedStyle(document.documentElement).getPropertyValue("--visiomatic-theme-default");
      this._themeIndex = this._themeList.findIndex(
        (theme) => theme === this._defaultTheme
      );
      import_leaflet18.DomUtil.addClass(
        this._map._container,
        this._themeClassList[this._themeIndex]
      );
      this._themeSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        this._themeList,
        void 0,
        this._themeIndex,
        "Select theme",
        () => {
          const index2 = parseInt(
            this._themeSelect.selectedIndex - 1,
            10
          );
          import_leaflet18.DomUtil.removeClass(
            this._map._container,
            this._themeClassList[this._themeIndex]
          );
          import_leaflet18.DomUtil.addClass(
            this._map._container,
            this._themeClassList[index2]
          );
          this._themeIndex = index2;
          localStorage.setItem(
            "visiomaticDefaultTheme",
            this._themeList[index2]
          );
          this._map.fire("themeChange");
        }
      );
    }
  });
  var preferencesUI = function(options) {
    return new PreferencesUI(options);
  };

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str2) {
    var len = str2.length;
    var ret;
    if (str2[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str2[1]] * 17,
          g: 255 & map$1[str2[2]] * 17,
          b: 255 & map$1[str2[3]] * 17,
          a: len === 5 ? map$1[str2[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str2[1]] << 4 | map$1[str2[2]],
          g: map$1[str2[3]] << 4 | map$1[str2[4]],
          b: map$1[str2[5]] << 4 | map$1[str2[6]],
          a: len === 9 ? map$1[str2[7]] << 4 | map$1[str2[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb2 = hsl2rgbn(h, 1, 0.5);
    let i2;
    if (w + b > 1) {
      i2 = 1 / (w + b);
      w *= i2;
      b *= i2;
    }
    for (i2 = 0; i2 < 3; i2++) {
      rgb2[i2] *= 1 - w - b;
      rgb2[i2] += w;
    }
    return rgb2;
  }
  function hueValue(r, g, b, d2, max) {
    if (r === max) {
      return (g - b) / d2 + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d2 + 2;
    }
    return (r - g) / d2 + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d2;
    if (max !== min) {
      d2 = max - min;
      s = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
      h = hueValue(r, g, b, d2, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c2) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c2)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str2) {
    const m = HUE_RE.exec(str2);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  var map2 = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map2);
    let i2, j, k, ok, nk;
    for (i2 = 0; i2 < keys.length; i2++) {
      ok = nk = keys[i2];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map2[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str2) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str2.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str2) {
    const m = RGB_RE.exec(str2);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i2, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str2) {
    if (str2.charAt(0) === "r") {
      return rgbParse(str2);
    }
    return hueParse(str2);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb2 = this._rgb;
      rgb2.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb2 = this._rgb;
      const val = round(rgb2.r * 0.3 + rgb2.g * 0.59 + rgb2.b * 0.11);
      rgb2.r = rgb2.g = rgb2.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb2 = this._rgb;
      rgb2.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i2, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i2 = len - 1; i2 >= 0; i2--) {
          fn2.call(thisArg, loopable[i2], i2);
        }
      } else {
        for (i2 = 0; i2 < len; i2++) {
          fn2.call(thisArg, loopable[i2], i2);
        }
      }
    } else if (isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i2 = 0; i2 < len; i2++) {
        fn2.call(thisArg, loopable[keys[i2]], keys[i2]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i2, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
      v0 = a0[i2];
      v1 = a1[i2];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone2(source) {
    if (isArray(source)) {
      return source.map(clone2);
    }
    if (isObject(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone2(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone2(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i2 = 0; i2 < ilen; ++i2) {
      current = sources[i2];
      if (!isObject(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone2(sval);
    }
  }
  var keyResolvers = {
    "": (v) => v,
    x: (o) => o.x,
    y: (o) => o.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str2) {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i2;
    for (i2 = 1; i2 < sqrt; i2++) {
      if (value % i2 === 0) {
        result.push(i2);
        result.push(value / i2);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i2, ilen, value;
    for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
      value = array[i2][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
      start++;
    }
    while (end > start && values[end - 1] > max) {
      end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn2, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(Math.min(
          _lookupByKey(_parsed, iScale.axis, min).lo,
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        ), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        ), start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
    }
    return {
      start,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t) => t === 0 || t === 1;
  var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  var effects = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t) => Math.sin(t * HALF_PI),
    easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic(t) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack(t) {
      const s = 1.70158;
      return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack(t) {
      let s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
    easeOutBounce(t) {
      const m = 7.5625;
      const d2 = 2.75;
      if (t < 1 / d2) {
        return m * t * t;
      }
      if (t < 2 / d2) {
        return m * (t -= 1.5 / d2) * t + 0.75;
      }
      if (t < 2.5 / d2) {
        return m * (t -= 2.25 / d2) * t + 0.9375;
      }
      return m * (t -= 2.625 / d2) * t + 0.984375;
    },
    easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
      const k = keys[i2];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i2, j, jlen, thing, nestedThing;
    for (i2 = 0; i2 < ilen; i2++) {
      thing = arrayOfThings[i2];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i2 = 0; i2 < gcLen; i2++) {
        delete data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point8, area, margin) {
    margin = margin || 0.5;
    return !area || point8 && point8.x > area.left - margin && point8.x < area.right + margin && point8.y > area.top - margin && point8.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top = y - metrics.actualBoundingBoxAscent;
      const bottom = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i2, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i2 = 0; i2 < lines.length; ++i2) {
      line = lines[i2];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i2, ilen, value;
    for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
      value = inputs[i2];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i2], 0, EPSILON)) {
        mK[i2] = mK[i2 + 1] = 0;
        continue;
      }
      alphaK = mK[i2] / deltaK[i2];
      betaK = mK[i2 + 1] / deltaK[i2];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i2] = alphaK * tauK * deltaK[i2];
      mK[i2 + 1] = betaK * tauK * deltaK[i2];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i2, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i2 = 0; i2 < pointsLen; ++i2) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i2 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
    let i2, ilen, point8, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
      if (!inArea) {
        continue;
      }
      point8 = points[i2];
      if (inAreaPrev) {
        point8.cp1x = capControlPoint(point8.cp1x, area.left, area.right);
        point8.cp1y = capControlPoint(point8.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point8.cp2x = capControlPoint(point8.cp2x, area.left, area.right);
        point8.cp2y = capControlPoint(point8.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i2, ilen, point8, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
        point8 = points[i2];
        controlPoints = splineCurve(prev, point8, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point8.cp1x = controlPoints.previous.x;
        point8.cp1y = controlPoints.previous.y;
        point8.cp2x = controlPoints.next.x;
        point8.cp2y = controlPoints.next.y;
        prev = point8;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i2 = 0; i2 < 4; i2++) {
      const pos = positions[i2];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c2 = _pointInLine(cp2, p2, t);
    const d2 = _pointInLine(a, b, t);
    const e = _pointInLine(b, c2, t);
    return _pointInLine(d2, e, t);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start, end, count, loop, style }) {
    return {
      start: start % count,
      end: end % count,
      loop: loop && (end - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds3) {
    const { property, start: startBound, end: endBound } = bounds3;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i2, ilen;
    if (loop) {
      start += count;
      end += count;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        if (!between(normalize(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end--;
      }
      start %= count;
      end %= count;
    }
    if (end < start) {
      end += count;
    }
    return {
      start,
      end,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds3) {
    if (!bounds3) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds3;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds3);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point8, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i2 = start, prev = start; i2 <= end; ++i2) {
      point8 = points[i2 % count];
      if (point8.skip) {
        continue;
      }
      value = normalize(point8[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i2 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i2,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i2;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds3) {
    const result = [];
    const segments = line.segments;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const sub = _boundSegment(segments[i2], line.points, bounds3);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end += start;
    }
    while (end > start && points[end % count].skip) {
      end--;
    }
    end %= count;
    return {
      start,
      end
    };
  }
  function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for (end = start + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start % count,
            end: (end - 1) % count,
            loop
          });
          start = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start,
          end,
          loop
        }
      ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i2 = start;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({
          start: s % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start = e % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev = points[start % count];
      let style;
      for (i2 = start + 1; i2 <= segment.end; i2++) {
        const pt = points[i2 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i2 - 1) % count,
          p1DataIndex: i2 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i2 - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start < i2 - 1) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i2 = items.length - 1;
        let draw3 = false;
        let item;
        for (; i2 >= 0; --i2) {
          item = items[i2];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw3 = true;
          } else {
            items[i2] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw3) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      for (; i2 >= 0; --i2) {
        items[i2].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i2 = 0; i2 < promises.length; i2++) {
        promises[i2][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i2;
      for (i2 = props.length - 1; i2 >= 0; --i2) {
        const prop = props[i2];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const anim = animations[keys[i2]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale2, allowedOverflow) {
    const opts = scale2 && scale2.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t, r, b, l;
    if (isObject(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      keys.push(metasets[i2].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i2, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      datasetIndex = +keys[i2];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i2, ilen, key;
    for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
      key = keys[i2];
      adata[i2] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale2, meta) {
    const stacked = scale2 && scale2.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale2) {
    const { min, max, minDefined, maxDefined } = scale2.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i2 = 0; i2 < ilen; ++i2) {
      const item = parsed[i2];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale2) {
      const meta = this._cachedMeta;
      return scale2 === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start === 0 && count === data.length ? true : meta._sorted;
      let prev = start > 0 && meta._parsed[start - 1];
      let i2, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start])) {
          parsed = this.parseArrayData(meta, data, start, count);
        } else if (isObject(data[start])) {
          parsed = this.parseObjectData(meta, data, start, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i2 = 0; i2 < count; ++i2) {
          meta._parsed[i2 + start] = cur = parsed[i2];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i2, ilen, index2;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        parsed[i2] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        item = data[index2];
        parsed[i2] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i2, ilen, index2, item;
      for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
        index2 = i2 + start;
        item = data[index2];
        parsed[i2] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale2, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale2.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale2.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range, scale2, parsed, stack) {
      const parsedValue = parsed[scale2.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale2.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
    }
    getMinMax(scale2, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale2 === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale2);
      const stack = createStack(canStack, meta, this.chart);
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i2, parsed;
      function _skip() {
        parsed = _parsed[i2];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale2.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i2 = 0; i2 < ilen; ++i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale2, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i2 = ilen - 1; i2 >= 0; --i2) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale2, parsed, stack);
          break;
        }
      }
      return range;
    }
    getAllParsedValues(scale2) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i2, ilen, value;
      for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
        value = parsed[i2][scale2.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i2;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start, count);
      }
      for (i2 = start; i2 < start + count; ++i2) {
        const element = elements2[i2];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i2 = 0; i2 < active.length; ++i2) {
        active[i2].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end = start + count;
      let i2;
      const move = (arr) => {
        arr.length += count;
        for (i2 = arr.length - 1; i2 >= end; i2--) {
          arr[i2] = arr[i2 - count];
        }
      };
      move(data);
      for (i2 = start; i2 < end; ++i2) {
        data[i2] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start, count);
      if (resetNewElements) {
        this.updateElements(data, start, count, "reset");
      }
    }
    updateElements(element, start, count, mode) {
    }
    _removeElements(start, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale2, type) {
    if (!scale2._cache.$bar) {
      const visibleMetas = scale2.getMatchingVisibleMetas(type);
      let values = [];
      for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
        values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale2));
      }
      scale2._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale2._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale2 = meta.iScale;
    const values = getAllScaleValues(scale2, meta.type);
    let min = scale2._length;
    let i2, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
      curr = scale2.getPixelForValue(values[i2]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i2 = 0, ilen = scale2.ticks.length; i2 < ilen; ++i2) {
      curr = scale2.getPixelForTick(i2);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i2) {
    const startValue = vScale.parse(entry[0], i2);
    const endValue = vScale.parse(entry[1], i2);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i2) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i2);
    } else {
      item[vScale.axis] = vScale.parse(entry, i2);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i2, ilen, item, entry;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      entry = data[i2];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
      parsed.push(parseValue(entry, item, vScale, i2));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end = "top";
    }
    if (reverse) {
      top = "end";
      bottom = "start";
    } else {
      top = "start";
      bottom = "end";
    }
    return {
      start,
      end,
      reverse,
      top,
      bottom
    };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start, end, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom;
      } else {
        res[parseEdge(bottom, start, end, reverse)] = true;
        edge = top;
      }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i2, ilen, item, obj;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        obj = data[i2];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
      }
      return parsed;
    }
    updateRangeFromParsed(range, scale2, parsed, stack) {
      super.updateRangeFromParsed(range, scale2, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale2 === this._cachedMeta.vScale) {
        range.min = Math.min(range.min, custom.min);
        range.max = Math.max(range.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      for (let i2 = start; i2 < start + count; i2++) {
        const parsed = this.getParsed(i2);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i2);
        const ipixels = this._calculateBarIndexPixels(i2, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
        }
        const options = properties.options || bars[i2].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i2], i2, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i2, ilen;
      for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start = 0;
        }
        start += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max), min);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale2 = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range.start + range.chunk * stackIndex + range.chunk / 2;
        size = Math.min(maxBarThickness, range.chunk * range.ratio);
      } else {
        center = scale2.getPixelForValue(this.getParsed(index2)[scale2.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i2 = 0;
      for (; i2 < ilen; ++i2) {
        if (this.getParsed(i2)[vScale.axis] !== null) {
          rects[i2].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
      const parsed = super.parsePrimitiveData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        parsed[i2]._custom = this.resolveDataElementOptions(i2 + start).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const parsed = super.parseArrayData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data[start + i2];
        parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const parsed = super.parseObjectData(meta, data, start, count);
      for (let i2 = 0; i2 < parsed.length; i2++) {
        const item = data[start + i2];
        parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max = 0;
      for (let i2 = data.length - 1; i2 >= 0; --i2) {
        max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max > 0 && max;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i2 = start; i2 < start + count; i2++) {
        const point8 = points[i2];
        const parsed = !reset && this.getParsed(i2);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point8.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point8, i2, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i3) => +data[i3];
        if (isObject(data[start])) {
          const { key = "value" } = this._parsing;
          getter = (i3) => +resolveObjectKey(data[i3], key);
        }
        let i2, ilen;
        for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
          meta._parsed[i2] = getter(i2);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max = -TAU;
      for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
        if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
          const controller = this.chart.getDatasetMeta(i2).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max = Math.max(max, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i2, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      let startAngle = this._getRotation();
      let i2;
      for (i2 = 0; i2 < start; ++i2) {
        startAngle += this._circumference(i2, reset);
      }
      for (i2 = start; i2 < start + count; ++i2) {
        const circumference = this._circumference(i2, reset);
        const arc = arcs[i2];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i2, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i2;
      for (i2 = 0; i2 < metaData.length; i2++) {
        const value = meta._parsed[i2];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max = 0;
      const chart = this.chart;
      let i2, ilen, meta, controller, options;
      if (!arcs) {
        for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
          if (chart.isDatasetVisible(i2)) {
            meta = chart.getDatasetMeta(i2);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        options = controller.resolveDataElementOptions(i2);
        if (options.borderAlign !== "inner") {
          max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max;
    }
    getMaxOffset(arcs) {
      let max = 0;
      for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
        const options = this.resolveDataElementOptions(i2);
        max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
      }
      return max;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i2 = 0; i2 < datasetIndex; ++i2) {
        if (this.chart.isDatasetVisible(i2)) {
          ringWeightOffset += this._getRingWeight(i2);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i2) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i2);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i2),
                  index: i2
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end = start + count;
      const pointsCount = points.length;
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i2 = 0; i2 < pointsCount; ++i2) {
        const point8 = points[i2];
        const properties = directUpdate ? point8 : {};
        if (i2 < start || i2 >= end) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i2);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point8.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point8, i2, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range.min) {
            range.min = parsed;
          }
          if (parsed > range.max) {
            range.max = parsed;
          }
        }
      });
      return range;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale2 = this._cachedMeta.rScale;
      const centerX = scale2.xCenter;
      const centerY = scale2.yCenter;
      const datasetStartAngle = scale2.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i2;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i2 = 0; i2 < start; ++i2) {
        angle += this._computeAngle(i2, mode, defaultAngle);
      }
      for (i2 = start; i2 < start + count; i2++) {
        const arc = arcs[i2];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i2) ? scale2.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i2, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i2) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i2);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i2),
                  index: i2
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const scale2 = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i2 = start; i2 < start + count; i2++) {
        const point8 = points[i2];
        const options = this.resolveDataElementOptions(i2, point8.active ? "active" : mode);
        const pointPosition = scale2.getPointPositionForValue(i2, this.getParsed(i2).r);
        const x = reset ? scale2.xCenter : pointPosition.x;
        const y = reset ? scale2.yCenter : pointPosition.y;
        const properties = {
          x,
          y,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y),
          options
        };
        this.updateElement(point8, i2, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      }
      this.updateElements(points, start, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i2 = start; i2 < start + count; ++i2) {
        const point8 = points[i2];
        const parsed = this.getParsed(i2);
        const properties = directUpdate ? point8 : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i2];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i2, point8.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point8, i2, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max = 0;
        for (let i2 = data.length - 1; i2 >= 0; --i2) {
          max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
        }
        return max > 0 && max;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    options;
    constructor(options) {
      this.options = options || {};
    }
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start = lookupMethod(data, axis, value - range);
          const end = lookupMethod(data, axis, value + range);
          return {
            lo: start.lo,
            hi: end.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const { index: index2, data } = metasets[i2];
      const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i2 = 0; i2 < data.length; ++i2) {
            items.push({
              element: data[i2],
              datasetIndex,
              index: i2
            });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i2, ilen, box, pos, stack, stackWeight;
    for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
      box = boxes[i2];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i2,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i2, ilen, layout;
    for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
      layout = layouts2[i2];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top),
      rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top.concat(bottom).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i2, ilen, layout, box, refit, changed;
    for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
      layout = boxes[i2];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element2, "defaults", {});
  __publicField(Element2, "defaultRoutes");
  function autoSkip(scale2, ticks) {
    const tickOpts = scale2.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale2);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first2 = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i2, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first2) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first2 - avgMajorSpacing, first2);
      for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
        skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale2) {
    const offset = scale2.options.offset;
    const tickLength = scale2._tickSize();
    const maxScale = scale2._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale2._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
      const factor = factors[i2];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (ticks[i2].major) {
        result.push(i2);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i2;
    spacing = Math.ceil(spacing);
    for (i2 = 0; i2 < ticks.length; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i2, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }
    for (i2 = Math.max(start, 0); i2 < end; i2++) {
      if (i2 === next) {
        newTicks.push(ticks[i2]);
        count++;
        next = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i2, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
      if (arr[i2] - arr[i2 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale2, edge, offset) => edge === "top" || edge === "left" ? scale2[edge] + offset : scale2[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i2 = 0;
    for (; i2 < len; i2 += increment) {
      result.push(arr[Math.floor(i2)]);
    }
    return result;
  }
  function getPixelForGridLine(scale2, index2, offsetGridLines) {
    const length = scale2.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start = scale2._startPixel;
    const end = scale2._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale2.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale2.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale2.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i2;
      if (gcLen > length) {
        for (i2 = 0; i2 < gcLen; ++i2) {
          delete cache.data[gc[i2]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale2) {
    return createContext(parent, {
      scale: scale2,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale2, offset, position, align) {
    const { top, left, bottom, right, chart } = scale2;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale2.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale2, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale2, position, offset);
      }
      titleY = _alignStartEnd(align, bottom, top);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range;
      if (minDefined && maxDefined) {
        return {
          min,
          max
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        range = metas[i2].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        tick = ticks[i2];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i2,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first: first2, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first2, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first2, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first2.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first2.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first2.width;
        } else if (align !== "inner") {
          paddingLeft = first2.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first2.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first2.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i2, ilen;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
        if (isNullOrUndef(ticks[i2].label)) {
          ticks.splice(i2, 1);
          ilen--;
          i2--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i2, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
      for (i2 = 0; i2 < length; i2 += increment) {
        label = ticks[i2].label;
        tickFont = this._resolveTickFontOptions(i2);
        ctx.font = fontString2 = tickFont.string;
        cache = caches[fontString2] = caches[fontString2] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i2, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i2 = 0; i2 < ticksLength; i2 += step) {
        const context = this.getContext(i2);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i2, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i2));
        pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i2);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i2 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i2 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i2];
          const width = labelSizes.widths[i2];
          let top = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top -= height / 2;
              break;
            case "bottom":
              top -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
          }
          backdrop = {
            left,
            top,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t) => t.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i2, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
          const item = items[i2];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title: title2, reverse } } = this;
      if (!title2.display) {
        return;
      }
      const font = toFont(title2.font);
      const padding = toPadding(title2.padding);
      const align = title2.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject(position)) {
        offset += padding.bottom;
        if (isArray(title2.text)) {
          offset += font.lineHeight * (title2.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title2.text, 0, 0, font, {
        color: title2.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        const meta = metas[i2];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
        const reg = this._typedRegistries[i2];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter2) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter2 ? this._descriptors(chart).filter(filter2) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin2 = descriptor.plugin;
        const method = plugin2[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin2) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i2 = 0; i2 < keys.length; i2++) {
      plugins2.push(registry.getPlugin(keys[i2]));
    }
    const local = config.plugins || [];
    for (let i2 = 0; i2 < local.length; i2++) {
      const plugin2 = local[i2];
      if (plugins2.indexOf(plugin2) === -1) {
        plugins2.push(plugin2);
        localIds[plugin2.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin2 of plugins2) {
      const id = plugin2.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin: plugin2,
        options: pluginOpts(chart.config, {
          plugin: plugin2,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin2);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin2.defaults) {
      scopes.push(plugin2.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale2 = scales2[key];
      mergeIf(scale2, [
        defaults.scales[scale2.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin2) {
      const id = plugin2.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin2.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.3.0";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function getDatasetArea(meta) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: xScale.left,
        right: xScale.right,
        top: yScale.top,
        bottom: yScale.bottom
      };
    }
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale2 = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale2 = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale2 = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale2.id] = scale2;
        }
        scale2.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale2) => {
        layouts.configure(this, scale2, scale2.options);
        layouts.addBox(this, scale2);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i2 = numData; i2 < numMeta; ++i2) {
          this._destroyDatasetMeta(i2);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i2, ilen;
      this._removeUnreferencedMetasets();
      for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
        const dataset = datasets[i2];
        let meta = this.getDatasetMeta(i2);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i2);
          meta = this.getDatasetMeta(i2);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i2;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i2);
        if (meta.controller) {
          meta.controller.updateIndex(i2);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i2);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
        const { controller } = this.getDatasetMeta(i2);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale2) => {
        layouts.removeBox(this, scale2);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i2 = 1; i2 < datasetCount; i2++) {
        if (!setsEqual(changeSet, makeSet(i2))) {
          return;
        }
      }
      return Array.from(changeSet).map((c2) => c2.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this.getDatasetMeta(i2).controller.configure();
      }
      for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._updateDataset(i2, isFunction(mode) ? mode({
          datasetIndex: i2
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i2;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i2 < layers.length; ++i2) {
        layers[i2].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i2, ilen;
      for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
        const meta = metasets[i2];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        this._drawDataset(metasets[i2]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta) || this.chartArea;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point8) {
      return _isPointInArea(point8, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i2, ilen;
      this.stop();
      animator.remove(this);
      for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
        this._destroyDatasetMeta(i2);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y) => {
        e.offsetX = x;
        e.offsetY = y;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i2, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        item = items[i2];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter2) {
      return this._plugins.notify(this, hook, args, filter2);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y) {
    return {
      x: x + r * Math.cos(theta),
      y: y + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i2 = 0; i2 < fullCircles; ++i2) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element2 {
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point8 = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point8, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  __publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  });
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end < start && !outside ? count + end - start : end - start
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i2, point8, prev;
    for (i2 = 0; i2 <= ilen; ++i2) {
      point8 = points[(start + (reverse ? ilen - i2 : i2)) % count];
      if (point8.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point8.x, point8.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point8, reverse, options.stepped);
      }
      prev = point8;
    }
    if (loop) {
      point8 = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point8, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i2, point8, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point8 = points[pointIndex(0)];
      ctx.moveTo(point8.x, point8.y);
    }
    for (i2 = 0; i2 <= ilen; ++i2) {
      point8 = points[pointIndex(i2)];
      if (point8.skip) {
        continue;
      }
      const x = point8.x;
      const y = point8.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start,
        end: start + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start, count);
    } else {
      strokePathDirect(ctx, line, start, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point8, property) {
      const options = this.options;
      const value = point8[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i2, ilen;
      for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
        const { start, end } = segments[i2];
        const p1 = points[start];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t, options.stepped);
        interpolated[property] = point8[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start = start || 0;
      count = count || this.points.length - start;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start,
          end: start + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    parsed;
    skip;
    stop;
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base);
      right = Math.max(x, base);
      top = y - half;
      bottom = y + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top = Math.min(y, base);
      bottom = Math.max(y, base);
    }
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds3 = getBarBounds(bar);
    const width = bounds3.right - bounds3.left;
    const height = bounds3.bottom - bounds3.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds3.left,
        y: bounds3.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds3.left + border.l,
        y: bounds3.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds3 = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds3 && (skipX || _isBetween(x, bounds3.left, bounds3.right)) && (skipY || _isBetween(y, bounds3.top, bounds3.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base) / 2 : x,
        y: horizontal ? y : (y + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i2) {
    return BORDER_COLORS[i2 % BORDER_COLORS.length];
  }
  function getBackgroundColor(i2) {
    return BACKGROUND_COLORS[i2 % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i2) {
    dataset.borderColor = getBorderColor(i2);
    dataset.backgroundColor = getBackgroundColor(i2);
    return ++i2;
  }
  function colorizeDoughnutDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i2++));
    return i2;
  }
  function colorizePolarAreaDataset(dataset, i2) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i2++));
    return i2;
  }
  function getColorizer(chart) {
    let i2 = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i2 = colorizeDoughnutDataset(dataset, i2);
      } else if (controller instanceof PolarAreaController) {
        i2 = colorizePolarAreaDataset(dataset, i2);
      } else if (controller) {
        i2 = colorizeDefaultDataset(dataset, i2);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i2, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i2 = 0; i2 < samples - 2; i2++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start;
      const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start;
      const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i2, point8, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i2 = start; i2 < start + count; ++i2) {
      point8 = data[i2];
      x = (point8.x - xMin) / dx * availableWidth;
      y = point8.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
          minIndex = i2;
        } else if (y > maxY) {
          maxY = y;
          maxIndex = i2;
        }
        avgX = (countX * avgX + point8.x) / ++countX;
      } else {
        const lastIndex = i2 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex1],
              x: avgX
            });
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex2],
              x: avgX
            });
          }
        }
        if (i2 > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point8);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
        minIndex = maxIndex = startIndex = i2;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale } = meta;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
    return {
      start,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d2) {
              this._data = d2;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start, end } = segment;
      end = _findSegmentEnd(start, end, points);
      const bounds3 = _getBounds(property, points[start], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds3,
          start: points[start],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds3);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds3, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds3, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first2, last, loop) {
    if (loop) {
      return;
    }
    let start = first2[property];
    let end = last[property];
    if (property === "angle") {
      start = _normalizeAngle(start);
      end = _normalizeAngle(end);
    }
    return {
      property,
      start,
      end
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start, end }) => {
      end = _findSegmentEnd(start, end, linePoints);
      const first2 = linePoints[start];
      const last = linePoints[end];
      if (y !== null) {
        points.push({
          x: first2.x,
          y
        });
        points.push({
          x: last.x,
          y
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first2.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start, end, points) {
    for (; end > start; end--) {
      const point8 = points[end];
      if (!isNaN(point8.x) && !isNaN(point8.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a, b, prop, fn2) {
    if (a && b) {
      return fn2(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale2) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale2.bottom;
    } else if (fill2 === "end") {
      pixel = scale2.top;
    } else if (isObject(fill2)) {
      pixel = scale2.getPixelForValue(fill2.value);
    } else if (scale2.getBasePixel) {
      pixel = scale2.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale2, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale2.options.reverse ? scale2.min : scale2.max;
    } else if (isObject(fill2)) {
      value = fill2.value;
    } else {
      value = scale2.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale: scale2, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale2, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale2.bottom
    }, line));
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale2, index2) {
    const below = [];
    const metas = scale2.getMatchingVisibleMetas("line");
    for (let i2 = 0; i2 < metas.length; i2++) {
      const meta = metas[i2];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first: first2, last, point: point8 } = findPoint(line, sourcePoint, "x");
      if (!point8 || first2 && last) {
        continue;
      }
      if (first2) {
        postponed.unshift(point8);
      } else {
        points.push(point8);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point8 = line.interpolate(sourcePoint, property);
    if (!point8) {
      return {};
    }
    const pointValue = point8[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first2 = false;
    let last = false;
    for (let i2 = 0; i2 < segments.length; i2++) {
      const segment = segments[i2];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first2 = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first: first2,
      last,
      point: point8
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds3, opts) {
      const { x, y, radius } = this;
      bounds3 = bounds3 || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y, radius, bounds3.end, bounds3.start, true);
      return !opts.bounds;
    }
    interpolate(point8) {
      const { x, y, radius } = this;
      const angle = point8.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale2 = source.scale || {};
    if (scale2.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale: scale2 = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale2);
    if (isNumberFinite(pixel)) {
      const horizontal = scale2.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale: scale2, fill: fill2 } = source;
    const options = scale2.options;
    const length = scale2.getLabels().length;
    const start = options.reverse ? scale2.max : scale2.min;
    const value = _getTargetValue(fill2, scale2, start);
    const target = [];
    if (options.grid.circular) {
      const center = scale2.getPointPositionForValue(0, start);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale2.getDistanceFromCenterForValue(value)
      });
    }
    for (let i2 = 0; i2 < length; ++i2) {
      target.push(scale2.getPointPositionForValue(i2, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale: scale2, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale: scale2,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale: scale2 } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale: scale2,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale: scale2,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first2 = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start, end } = segment;
      const firstPoint = points[start];
      const lastPoint = points[_findSegmentEnd(start, end, points)];
      if (first2) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first2 = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale: scale2 } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start, end } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale2, notShape && _getBounds(property, start, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale2, bounds3) {
    const { top, bottom } = scale2.chart.chartArea;
    const { property, start, end } = bounds3 || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start, top, end - start, bottom - top);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point8, property) {
    const interpolatedPoint = target.interpolate(point8, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i2, line, source;
      for (i2 = 0; i2 < count; ++i2) {
        meta = chart.getDatasetMeta(i2);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i2),
            index: i2,
            fill: _decodeFill(line, i2, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i2 = 0; i2 < count; ++i2) {
        source = sources[i2];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i2, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw3 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw3 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
        const source = metasets[i2].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top = -lineHeight;
      this.legendItems.forEach((legendItem, i2) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
          top += lineHeight;
          row++;
        }
        hitboxes[i2] = {
          left: 0,
          top,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i2) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i2] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y, legendItem) {
        renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i2) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i2 > 0 && x + width + padding > this.right) {
            y = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i2 > 0 && y + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
      let i2, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i2 = 0; i2 < lh.length; ++i2) {
          hitBox = lh[i2];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i2];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top, left, bottom, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom, top);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top, bottom);
          rotation = PI * 0.5;
        }
        maxWidth = bottom - top;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title2 = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title2, titleOpts);
    layouts.addBox(chart, title2);
    chart.titleBlock = title2;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title2 = chart.titleBlock;
      layouts.configure(chart, title2, options);
      title2.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map3 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title2 = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title2, options);
      layouts.addBox(chart, title2);
      map3.set(chart, title2);
    },
    stop(chart) {
      layouts.removeBox(chart, map3.get(chart));
      map3.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title2 = map3.get(chart);
      layouts.configure(chart, title2, options);
      title2.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i2, len;
      let x = 0;
      let y = 0;
      let count = 0;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          x += pos.x;
          y += pos.y;
          ++count;
        }
      }
      return {
        x: x / count,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i2, len, nearestElement;
      for (i2 = 0, len = items.length; i2 < len; ++i2) {
        const el = items[i2].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d2 = distanceBetweenPoints(eventPosition, center);
          if (d2 < minDistance) {
            minDistance = d2;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x,
        y
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str2) {
    if ((typeof str2 === "string" || str2 instanceof String) && str2.indexOf("\n") > -1) {
      return str2.split("\n");
    }
    return str2;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title: title2 } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title2.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title2 = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title2));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i2, len;
      for (i2 = 0, len = active.length; i2 < len; ++i2) {
        tooltipItems.push(createTooltipItem(this.chart, active[i2]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title2 = this.title;
      const length = title2.length;
      let titleFont, titleSpacing, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(title2[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i2 + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i2, rtlHelper, options) {
      const labelColor = this.labelColors[i2];
      const labelPointStyle = this.labelPointStyles[i2];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i2];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i2, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
        bodyItem = body[i2];
        textColor = this.labelTextColors[i2];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i2, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i2;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i2 = 0; i2 < length; ++i2) {
          ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y + topLeft);
      ctx.quadraticCurveTo(x, y, x + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point8 = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point8.x || animY._to !== point8.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point8);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", {
          ...args,
          cancelable: true
        }) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw
      });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first2 = labels.indexOf(raw);
    if (first2 === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first2 !== last ? index2 : first2;
  }
  var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds: bounds3, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds3 === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({
          value: max
        });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = max === 0 ? 1 : Math.abs(max * 0.05);
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end += offset;
      }
      this._startValue = start;
      this._endValue = end;
      this._valueRange = end - start;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
  }
  function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while (steps(min, max, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max, -1));
      }
      if (max <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start = this.min;
      super.configure();
      this._startValue = log10(start);
      this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale2) {
    const orig = {
      l: scale2.left + scale2._padding.left,
      r: scale2.right - scale2._padding.right,
      t: scale2.top + scale2._padding.top,
      b: scale2.bottom - scale2._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale2._pointLabels.length;
    const pointLabelOpts = scale2.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i2 = 0; i2 < valueCount; i2++) {
      const opts = pointLabelOpts.setContext(scale2.getPointLabelContext(i2));
      padding[i2] = opts.padding;
      const pointPosition = scale2.getPointPosition(i2, scale2.drawingArea + padding[i2], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale2.ctx, plFont, scale2._pointLabels[i2]);
      labelSizes[i2] = textSize;
      const angleRadians = _normalizeAngle(scale2.getIndexAngle(i2) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale2.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale2._pointLabelItems = buildPointLabelItems(scale2, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale2, index2, itemOpts) {
    const outerDistance = scale2.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale2.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top, right, bottom } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top
    }, area) || _isPointInArea({
      x: left,
      y: bottom
    }, area) || _isPointInArea({
      x: right,
      y: top
    }, area) || _isPointInArea({
      x: right,
      y: bottom
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale2, labelSizes, padding) {
    const items = [];
    const valueCount = scale2._pointLabels.length;
    const opts = scale2.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i2 = 0; i2 < valueCount; i2++) {
      itemOpts.padding = padding[i2];
      itemOpts.size = labelSizes[i2];
      const item = createPointLabelItem(scale2, i2, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top, right, bottom } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale2, labelCount) {
    const { ctx, options: { pointLabels } } = scale2;
    for (let i2 = labelCount - 1; i2 >= 0; i2--) {
      const item = scale2._pointLabelItems[i2];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale2.getPointLabelContext(i2));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign } = item;
      renderText(ctx, scale2._pointLabels[i2], x, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale2, radius, circular, labelCount) {
    const { ctx } = scale2;
    if (circular) {
      ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale2.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i2 = 1; i2 < labelCount; i2++) {
        pointPosition = scale2.getPointPosition(i2, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale2, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale2.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale2, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i2) => this.chart.getDataVisibility(i2));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left, top, right, bottom } = this._pointLabelItems[index2];
      return {
        left,
        top,
        right,
        bottom
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i2, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i2 = labelCount - 1; i2 >= 0; i2--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i2, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale2, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale2._adapter;
    const { parser, round: round2, isoWeekday } = scale2._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
      const interval = INTERVALS[UNITS[i2]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i2];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale2, numTicks, minUnit, min, max) {
    for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
      const unit = UNITS[i2];
      if (INTERVALS[unit].common && scale2._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
      if (INTERVALS[UNITS[i2]].common) {
        return UNITS[i2];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale2, ticks, map4, majorUnit) {
    const adapter = scale2._adapter;
    const first2 = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first2; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map4[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale2, values, majorUnit) {
    const ticks = [];
    const map4 = {};
    const ilen = values.length;
    let i2, value;
    for (i2 = 0; i2 < ilen; ++i2) {
      value = values[i2];
      map4[value] = i2;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map4, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds3) {
        if (!minDefined && !isNaN(bounds3.min)) {
          min = Math.min(min, bounds3.min);
        }
        if (!maxDefined && !isNaN(bounds3.max)) {
          max = Math.max(max, bounds3.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return {
        min,
        max
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start = 0;
      let end = 0;
      let first2, last;
      if (this.options.offset && timestamps.length) {
        first2 = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start = 1 - first2;
        } else {
          start = (this.getDecimalForValue(timestamps[1]) - first2) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start = _limitValue(start, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = {
        start,
        end,
        factor: 1 / (start + 1 + end)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first2 = min;
      let time, count;
      if (hasWeekday) {
        first2 = +adapter.startOf(first2, "isoWeek", weekday);
      }
      first2 = +adapter.startOf(first2, hasWeekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first2, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i2, ilen, tick;
      for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
        tick = ticks[i2];
        tick.label = this._tickFormatFunction(tick.value, i2, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
        timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i2, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
        timestamps.push(parse(this, labels[i2]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i2, ilen, prev, curr, next;
      for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
        curr = timestamps[i2];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max,
            pos: 1
          }
        ];
      }
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        next = items[i2 + 1];
        prev = items[i2 - 1];
        curr = items[i2];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i2 / (ilen - 1)
          });
        }
      }
      return table;
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);
  var auto_default = Chart;

  // node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js
  var import_hammerjs = __toESM(require_hammer());
  var getModifierKey = (opts) => opts && opts.enabled && opts.modifierKey;
  var keyPressed = (key, event) => key && event[key + "Key"];
  var keyNotPressed = (key, event) => key && !event[key + "Key"];
  function directionEnabled(mode, dir, chart) {
    if (mode === void 0) {
      return true;
    } else if (typeof mode === "string") {
      return mode.indexOf(dir) !== -1;
    } else if (typeof mode === "function") {
      return mode({ chart }).indexOf(dir) !== -1;
    }
    return false;
  }
  function directionsEnabled(mode, chart) {
    if (typeof mode === "function") {
      mode = mode({ chart });
    }
    if (typeof mode === "string") {
      return { x: mode.indexOf("x") !== -1, y: mode.indexOf("y") !== -1 };
    }
    return { x: false, y: false };
  }
  function debounce2(fn2, delay) {
    let timeout;
    return function() {
      clearTimeout(timeout);
      timeout = setTimeout(fn2, delay);
      return delay;
    };
  }
  function getScaleUnderPoint({ x, y }, chart) {
    const scales2 = chart.scales;
    const scaleIds = Object.keys(scales2);
    for (let i2 = 0; i2 < scaleIds.length; i2++) {
      const scale2 = scales2[scaleIds[i2]];
      if (y >= scale2.top && y <= scale2.bottom && x >= scale2.left && x <= scale2.right) {
        return scale2;
      }
    }
    return null;
  }
  function getEnabledScalesByPoint(options, point8, chart) {
    const { mode = "xy", scaleMode, overScaleMode } = options || {};
    const scale2 = getScaleUnderPoint(point8, chart);
    const enabled = directionsEnabled(mode, chart);
    const scaleEnabled = directionsEnabled(scaleMode, chart);
    if (overScaleMode) {
      const overScaleEnabled = directionsEnabled(overScaleMode, chart);
      for (const axis of ["x", "y"]) {
        if (overScaleEnabled[axis]) {
          scaleEnabled[axis] = enabled[axis];
          enabled[axis] = false;
        }
      }
    }
    if (scale2 && scaleEnabled[scale2.axis]) {
      return [scale2];
    }
    const enabledScales = [];
    each(chart.scales, function(scaleItem) {
      if (enabled[scaleItem.axis]) {
        enabledScales.push(scaleItem);
      }
    });
    return enabledScales;
  }
  var chartStates = /* @__PURE__ */ new WeakMap();
  function getState(chart) {
    let state = chartStates.get(chart);
    if (!state) {
      state = {
        originalScaleLimits: {},
        updatedScaleLimits: {},
        handlers: {},
        panDelta: {}
      };
      chartStates.set(chart, state);
    }
    return state;
  }
  function removeState(chart) {
    chartStates.delete(chart);
  }
  function zoomDelta(scale2, zoom2, center) {
    const range = scale2.max - scale2.min;
    const newRange = range * (zoom2 - 1);
    const centerPoint = scale2.isHorizontal() ? center.x : center.y;
    const minPercent = Math.max(0, Math.min(
      1,
      (scale2.getValueForPixel(centerPoint) - scale2.min) / range || 0
    ));
    const maxPercent = 1 - minPercent;
    return {
      min: newRange * minPercent,
      max: newRange * maxPercent
    };
  }
  function getLimit(state, scale2, scaleLimits, prop, fallback) {
    let limit = scaleLimits[prop];
    if (limit === "original") {
      const original = state.originalScaleLimits[scale2.id][prop];
      limit = valueOrDefault(original.options, original.scale);
    }
    return valueOrDefault(limit, fallback);
  }
  function getRange(scale2, pixel0, pixel1) {
    const v0 = scale2.getValueForPixel(pixel0);
    const v1 = scale2.getValueForPixel(pixel1);
    return {
      min: Math.min(v0, v1),
      max: Math.max(v0, v1)
    };
  }
  function updateRange(scale2, { min, max }, limits, zoom2 = false) {
    const state = getState(scale2.chart);
    const { id, axis, options: scaleOpts } = scale2;
    const scaleLimits = limits && (limits[id] || limits[axis]) || {};
    const { minRange = 0 } = scaleLimits;
    const minLimit = getLimit(state, scale2, scaleLimits, "min", -Infinity);
    const maxLimit = getLimit(state, scale2, scaleLimits, "max", Infinity);
    const range = zoom2 ? Math.max(max - min, minRange) : scale2.max - scale2.min;
    const offset = (range - max + min) / 2;
    min -= offset;
    max += offset;
    if (min < minLimit) {
      min = minLimit;
      max = Math.min(minLimit + range, maxLimit);
    } else if (max > maxLimit) {
      max = maxLimit;
      min = Math.max(maxLimit - range, minLimit);
    }
    scaleOpts.min = min;
    scaleOpts.max = max;
    state.updatedScaleLimits[scale2.id] = { min, max };
    return scale2.parse(min) !== scale2.min || scale2.parse(max) !== scale2.max;
  }
  function zoomNumericalScale(scale2, zoom2, center, limits) {
    const delta = zoomDelta(scale2, zoom2, center);
    const newRange = { min: scale2.min + delta.min, max: scale2.max - delta.max };
    return updateRange(scale2, newRange, limits, true);
  }
  function zoomRectNumericalScale(scale2, from2, to2, limits) {
    updateRange(scale2, getRange(scale2, from2, to2), limits, true);
  }
  var integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);
  function existCategoryFromMaxZoom(scale2) {
    const labels = scale2.getLabels();
    const maxIndex = labels.length - 1;
    if (scale2.min > 0) {
      scale2.min -= 1;
    }
    if (scale2.max < maxIndex) {
      scale2.max += 1;
    }
  }
  function zoomCategoryScale(scale2, zoom2, center, limits) {
    const delta = zoomDelta(scale2, zoom2, center);
    if (scale2.min === scale2.max && zoom2 < 1) {
      existCategoryFromMaxZoom(scale2);
    }
    const newRange = { min: scale2.min + integerChange(delta.min), max: scale2.max - integerChange(delta.max) };
    return updateRange(scale2, newRange, limits, true);
  }
  function scaleLength(scale2) {
    return scale2.isHorizontal() ? scale2.width : scale2.height;
  }
  function panCategoryScale(scale2, delta, limits) {
    const labels = scale2.getLabels();
    const lastLabelIndex = labels.length - 1;
    let { min, max } = scale2;
    const range = Math.max(max - min, 1);
    const stepDelta = Math.round(scaleLength(scale2) / Math.max(range, 10));
    const stepSize = Math.round(Math.abs(delta / stepDelta));
    let applied;
    if (delta < -stepDelta) {
      max = Math.min(max + stepSize, lastLabelIndex);
      min = range === 1 ? max : max - range;
      applied = max === lastLabelIndex;
    } else if (delta > stepDelta) {
      min = Math.max(0, min - stepSize);
      max = range === 1 ? min : min + range;
      applied = min === 0;
    }
    return updateRange(scale2, { min, max }, limits) || applied;
  }
  var OFFSETS = {
    second: 500,
    minute: 30 * 1e3,
    hour: 30 * 60 * 1e3,
    day: 12 * 60 * 60 * 1e3,
    week: 3.5 * 24 * 60 * 60 * 1e3,
    month: 15 * 24 * 60 * 60 * 1e3,
    quarter: 60 * 24 * 60 * 60 * 1e3,
    year: 182 * 24 * 60 * 60 * 1e3
  };
  function panNumericalScale(scale2, delta, limits, canZoom = false) {
    const { min: prevStart, max: prevEnd, options } = scale2;
    const round2 = options.time && options.time.round;
    const offset = OFFSETS[round2] || 0;
    const newMin = scale2.getValueForPixel(scale2.getPixelForValue(prevStart + offset) - delta);
    const newMax = scale2.getValueForPixel(scale2.getPixelForValue(prevEnd + offset) - delta);
    const { min: minLimit = -Infinity, max: maxLimit = Infinity } = canZoom && limits && limits[scale2.axis] || {};
    if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {
      return true;
    }
    return updateRange(scale2, { min: newMin, max: newMax }, limits, canZoom);
  }
  function panNonLinearScale(scale2, delta, limits) {
    return panNumericalScale(scale2, delta, limits, true);
  }
  var zoomFunctions = {
    category: zoomCategoryScale,
    default: zoomNumericalScale
  };
  var zoomRectFunctions = {
    default: zoomRectNumericalScale
  };
  var panFunctions = {
    category: panCategoryScale,
    default: panNumericalScale,
    logarithmic: panNonLinearScale,
    timeseries: panNonLinearScale
  };
  function shouldUpdateScaleLimits(scale2, originalScaleLimits, updatedScaleLimits) {
    const { id, options: { min, max } } = scale2;
    if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {
      return true;
    }
    const previous = updatedScaleLimits[id];
    return previous.min !== min || previous.max !== max;
  }
  function removeMissingScales(limits, scales2) {
    each(limits, (opt, key) => {
      if (!scales2[key]) {
        delete limits[key];
      }
    });
  }
  function storeOriginalScaleLimits(chart, state) {
    const { scales: scales2 } = chart;
    const { originalScaleLimits, updatedScaleLimits } = state;
    each(scales2, function(scale2) {
      if (shouldUpdateScaleLimits(scale2, originalScaleLimits, updatedScaleLimits)) {
        originalScaleLimits[scale2.id] = {
          min: { scale: scale2.min, options: scale2.options.min },
          max: { scale: scale2.max, options: scale2.options.max }
        };
      }
    });
    removeMissingScales(originalScaleLimits, scales2);
    removeMissingScales(updatedScaleLimits, scales2);
    return originalScaleLimits;
  }
  function doZoom(scale2, amount, center, limits) {
    const fn2 = zoomFunctions[scale2.type] || zoomFunctions.default;
    callback(fn2, [scale2, amount, center, limits]);
  }
  function doZoomRect(scale2, amount, from2, to2, limits) {
    const fn2 = zoomRectFunctions[scale2.type] || zoomRectFunctions.default;
    callback(fn2, [scale2, amount, from2, to2, limits]);
  }
  function getCenter(chart) {
    const ca = chart.chartArea;
    return {
      x: (ca.left + ca.right) / 2,
      y: (ca.top + ca.bottom) / 2
    };
  }
  function zoom(chart, amount, transition = "none") {
    const { x = 1, y = 1, focalPoint = getCenter(chart) } = typeof amount === "number" ? { x: amount, y: amount } : amount;
    const state = getState(chart);
    const { options: { limits, zoom: zoomOptions } } = state;
    storeOriginalScaleLimits(chart, state);
    const xEnabled = x !== 1;
    const yEnabled = y !== 1;
    const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);
    each(enabledScales || chart.scales, function(scale2) {
      if (scale2.isHorizontal() && xEnabled) {
        doZoom(scale2, x, focalPoint, limits);
      } else if (!scale2.isHorizontal() && yEnabled) {
        doZoom(scale2, y, focalPoint, limits);
      }
    });
    chart.update(transition);
    callback(zoomOptions.onZoom, [{ chart }]);
  }
  function zoomRect(chart, p0, p1, transition = "none") {
    const state = getState(chart);
    const { options: { limits, zoom: zoomOptions } } = state;
    const { mode = "xy" } = zoomOptions;
    storeOriginalScaleLimits(chart, state);
    const xEnabled = directionEnabled(mode, "x", chart);
    const yEnabled = directionEnabled(mode, "y", chart);
    each(chart.scales, function(scale2) {
      if (scale2.isHorizontal() && xEnabled) {
        doZoomRect(scale2, p0.x, p1.x, limits);
      } else if (!scale2.isHorizontal() && yEnabled) {
        doZoomRect(scale2, p0.y, p1.y, limits);
      }
    });
    chart.update(transition);
    callback(zoomOptions.onZoom, [{ chart }]);
  }
  function zoomScale(chart, scaleId, range, transition = "none") {
    storeOriginalScaleLimits(chart, getState(chart));
    const scale2 = chart.scales[scaleId];
    updateRange(scale2, range, void 0, true);
    chart.update(transition);
  }
  function resetZoom(chart, transition = "default") {
    const state = getState(chart);
    const originalScaleLimits = storeOriginalScaleLimits(chart, state);
    each(chart.scales, function(scale2) {
      const scaleOptions = scale2.options;
      if (originalScaleLimits[scale2.id]) {
        scaleOptions.min = originalScaleLimits[scale2.id].min.options;
        scaleOptions.max = originalScaleLimits[scale2.id].max.options;
      } else {
        delete scaleOptions.min;
        delete scaleOptions.max;
      }
    });
    chart.update(transition);
    callback(state.options.zoom.onZoomComplete, [{ chart }]);
  }
  function getOriginalRange(state, scaleId) {
    const original = state.originalScaleLimits[scaleId];
    if (!original) {
      return;
    }
    const { min, max } = original;
    return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);
  }
  function getZoomLevel(chart) {
    const state = getState(chart);
    let min = 1;
    let max = 1;
    each(chart.scales, function(scale2) {
      const origRange = getOriginalRange(state, scale2.id);
      if (origRange) {
        const level = Math.round(origRange / (scale2.max - scale2.min) * 100) / 100;
        min = Math.min(min, level);
        max = Math.max(max, level);
      }
    });
    return min < 1 ? min : max;
  }
  function panScale(scale2, delta, limits, state) {
    const { panDelta } = state;
    const storedDelta = panDelta[scale2.id] || 0;
    if (sign(storedDelta) === sign(delta)) {
      delta += storedDelta;
    }
    const fn2 = panFunctions[scale2.type] || panFunctions.default;
    if (callback(fn2, [scale2, delta, limits])) {
      panDelta[scale2.id] = 0;
    } else {
      panDelta[scale2.id] = delta;
    }
  }
  function pan(chart, delta, enabledScales, transition = "none") {
    const { x = 0, y = 0 } = typeof delta === "number" ? { x: delta, y: delta } : delta;
    const state = getState(chart);
    const { options: { pan: panOptions, limits } } = state;
    const { onPan } = panOptions || {};
    storeOriginalScaleLimits(chart, state);
    const xEnabled = x !== 0;
    const yEnabled = y !== 0;
    each(enabledScales || chart.scales, function(scale2) {
      if (scale2.isHorizontal() && xEnabled) {
        panScale(scale2, x, limits, state);
      } else if (!scale2.isHorizontal() && yEnabled) {
        panScale(scale2, y, limits, state);
      }
    });
    chart.update(transition);
    callback(onPan, [{ chart }]);
  }
  function getInitialScaleBounds(chart) {
    const state = getState(chart);
    storeOriginalScaleLimits(chart, state);
    const scaleBounds = {};
    for (const scaleId of Object.keys(chart.scales)) {
      const { min, max } = state.originalScaleLimits[scaleId] || { min: {}, max: {} };
      scaleBounds[scaleId] = { min: min.scale, max: max.scale };
    }
    return scaleBounds;
  }
  function isZoomedOrPanned(chart) {
    const scaleBounds = getInitialScaleBounds(chart);
    for (const scaleId of Object.keys(chart.scales)) {
      const { min: originalMin, max: originalMax } = scaleBounds[scaleId];
      if (originalMin !== void 0 && chart.scales[scaleId].min !== originalMin) {
        return true;
      }
      if (originalMax !== void 0 && chart.scales[scaleId].max !== originalMax) {
        return true;
      }
    }
    return false;
  }
  function removeHandler(chart, type) {
    const { handlers } = getState(chart);
    const handler = handlers[type];
    if (handler && handler.target) {
      handler.target.removeEventListener(type, handler);
      delete handlers[type];
    }
  }
  function addHandler(chart, target, type, handler) {
    const { handlers, options } = getState(chart);
    const oldHandler = handlers[type];
    if (oldHandler && oldHandler.target === target) {
      return;
    }
    removeHandler(chart, type);
    handlers[type] = (event) => handler(chart, event, options);
    handlers[type].target = target;
    target.addEventListener(type, handlers[type]);
  }
  function mouseMove(chart, event) {
    const state = getState(chart);
    if (state.dragStart) {
      state.dragging = true;
      state.dragEnd = event;
      chart.update("none");
    }
  }
  function keyDown(chart, event) {
    const state = getState(chart);
    if (!state.dragStart || event.key !== "Escape") {
      return;
    }
    removeHandler(chart, "keydown");
    state.dragging = false;
    state.dragStart = state.dragEnd = null;
    chart.update("none");
  }
  function zoomStart(chart, event, zoomOptions) {
    const { onZoomStart, onZoomRejected } = zoomOptions;
    if (onZoomStart) {
      const point8 = getRelativePosition(event, chart);
      if (callback(onZoomStart, [{ chart, event, point: point8 }]) === false) {
        callback(onZoomRejected, [{ chart, event }]);
        return false;
      }
    }
  }
  function mouseDown(chart, event) {
    const state = getState(chart);
    const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
    if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {
      return callback(zoomOptions.onZoomRejected, [{ chart, event }]);
    }
    if (zoomStart(chart, event, zoomOptions) === false) {
      return;
    }
    state.dragStart = event;
    addHandler(chart, chart.canvas, "mousemove", mouseMove);
    addHandler(chart, window.document, "keydown", keyDown);
  }
  function computeDragRect(chart, mode, beginPointEvent, endPointEvent) {
    const xEnabled = directionEnabled(mode, "x", chart);
    const yEnabled = directionEnabled(mode, "y", chart);
    let { top, left, right, bottom, width: chartWidth, height: chartHeight } = chart.chartArea;
    const beginPoint = getRelativePosition(beginPointEvent, chart);
    const endPoint = getRelativePosition(endPointEvent, chart);
    if (xEnabled) {
      left = Math.min(beginPoint.x, endPoint.x);
      right = Math.max(beginPoint.x, endPoint.x);
    }
    if (yEnabled) {
      top = Math.min(beginPoint.y, endPoint.y);
      bottom = Math.max(beginPoint.y, endPoint.y);
    }
    const width = right - left;
    const height = bottom - top;
    return {
      left,
      top,
      right,
      bottom,
      width,
      height,
      zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,
      zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1
    };
  }
  function mouseUp(chart, event) {
    const state = getState(chart);
    if (!state.dragStart) {
      return;
    }
    removeHandler(chart, "mousemove");
    const { mode, onZoomComplete, drag: { threshold = 0 } } = state.options.zoom;
    const rect = computeDragRect(chart, mode, state.dragStart, event);
    const distanceX = directionEnabled(mode, "x", chart) ? rect.width : 0;
    const distanceY = directionEnabled(mode, "y", chart) ? rect.height : 0;
    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
    state.dragStart = state.dragEnd = null;
    if (distance <= threshold) {
      state.dragging = false;
      chart.update("none");
      return;
    }
    zoomRect(chart, { x: rect.left, y: rect.top }, { x: rect.right, y: rect.bottom }, "zoom");
    setTimeout(() => state.dragging = false, 500);
    callback(onZoomComplete, [{ chart }]);
  }
  function wheelPreconditions(chart, event, zoomOptions) {
    if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {
      callback(zoomOptions.onZoomRejected, [{ chart, event }]);
      return;
    }
    if (zoomStart(chart, event, zoomOptions) === false) {
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    if (event.deltaY === void 0) {
      return;
    }
    return true;
  }
  function wheel(chart, event) {
    const { handlers: { onZoomComplete }, options: { zoom: zoomOptions } } = getState(chart);
    if (!wheelPreconditions(chart, event, zoomOptions)) {
      return;
    }
    const rect = event.target.getBoundingClientRect();
    const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);
    const amount = {
      x: speed,
      y: speed,
      focalPoint: {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      }
    };
    zoom(chart, amount);
    if (onZoomComplete) {
      onZoomComplete();
    }
  }
  function addDebouncedHandler(chart, name, handler, delay) {
    if (handler) {
      getState(chart).handlers[name] = debounce2(() => callback(handler, [{ chart }]), delay);
    }
  }
  function addListeners(chart, options) {
    const canvas = chart.canvas;
    const { wheel: wheelOptions, drag: dragOptions, onZoomComplete } = options.zoom;
    if (wheelOptions.enabled) {
      addHandler(chart, canvas, "wheel", wheel);
      addDebouncedHandler(chart, "onZoomComplete", onZoomComplete, 250);
    } else {
      removeHandler(chart, "wheel");
    }
    if (dragOptions.enabled) {
      addHandler(chart, canvas, "mousedown", mouseDown);
      addHandler(chart, canvas.ownerDocument, "mouseup", mouseUp);
    } else {
      removeHandler(chart, "mousedown");
      removeHandler(chart, "mousemove");
      removeHandler(chart, "mouseup");
      removeHandler(chart, "keydown");
    }
  }
  function removeListeners(chart) {
    removeHandler(chart, "mousedown");
    removeHandler(chart, "mousemove");
    removeHandler(chart, "mouseup");
    removeHandler(chart, "wheel");
    removeHandler(chart, "click");
    removeHandler(chart, "keydown");
  }
  function createEnabler(chart, state) {
    return function(recognizer, event) {
      const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
      if (!panOptions || !panOptions.enabled) {
        return false;
      }
      const srcEvent = event && event.srcEvent;
      if (!srcEvent) {
        return true;
      }
      if (!state.panning && event.pointerType === "mouse" && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {
        callback(panOptions.onPanRejected, [{ chart, event }]);
        return false;
      }
      return true;
    };
  }
  function pinchAxes(p0, p1) {
    const pinchX = Math.abs(p0.clientX - p1.clientX);
    const pinchY = Math.abs(p0.clientY - p1.clientY);
    const p = pinchX / pinchY;
    let x, y;
    if (p > 0.3 && p < 1.7) {
      x = y = true;
    } else if (pinchX > pinchY) {
      x = true;
    } else {
      y = true;
    }
    return { x, y };
  }
  function handlePinch(chart, state, e) {
    if (state.scale) {
      const { center, pointers } = e;
      const zoomPercent = 1 / state.scale * e.scale;
      const rect = e.target.getBoundingClientRect();
      const pinch = pinchAxes(pointers[0], pointers[1]);
      const mode = state.options.zoom.mode;
      const amount = {
        x: pinch.x && directionEnabled(mode, "x", chart) ? zoomPercent : 1,
        y: pinch.y && directionEnabled(mode, "y", chart) ? zoomPercent : 1,
        focalPoint: {
          x: center.x - rect.left,
          y: center.y - rect.top
        }
      };
      zoom(chart, amount);
      state.scale = e.scale;
    }
  }
  function startPinch(chart, state) {
    if (state.options.zoom.pinch.enabled) {
      state.scale = 1;
    }
  }
  function endPinch(chart, state, e) {
    if (state.scale) {
      handlePinch(chart, state, e);
      state.scale = null;
      callback(state.options.zoom.onZoomComplete, [{ chart }]);
    }
  }
  function handlePan(chart, state, e) {
    const delta = state.delta;
    if (delta) {
      state.panning = true;
      pan(chart, { x: e.deltaX - delta.x, y: e.deltaY - delta.y }, state.panScales);
      state.delta = { x: e.deltaX, y: e.deltaY };
    }
  }
  function startPan(chart, state, event) {
    const { enabled, onPanStart, onPanRejected } = state.options.pan;
    if (!enabled) {
      return;
    }
    const rect = event.target.getBoundingClientRect();
    const point8 = {
      x: event.center.x - rect.left,
      y: event.center.y - rect.top
    };
    if (callback(onPanStart, [{ chart, event, point: point8 }]) === false) {
      return callback(onPanRejected, [{ chart, event }]);
    }
    state.panScales = getEnabledScalesByPoint(state.options.pan, point8, chart);
    state.delta = { x: 0, y: 0 };
    clearTimeout(state.panEndTimeout);
    handlePan(chart, state, event);
  }
  function endPan(chart, state) {
    state.delta = null;
    if (state.panning) {
      state.panEndTimeout = setTimeout(() => state.panning = false, 500);
      callback(state.options.pan.onPanComplete, [{ chart }]);
    }
  }
  var hammers = /* @__PURE__ */ new WeakMap();
  function startHammer(chart, options) {
    const state = getState(chart);
    const canvas = chart.canvas;
    const { pan: panOptions, zoom: zoomOptions } = options;
    const mc = new import_hammerjs.default.Manager(canvas);
    if (zoomOptions && zoomOptions.pinch.enabled) {
      mc.add(new import_hammerjs.default.Pinch());
      mc.on("pinchstart", () => startPinch(chart, state));
      mc.on("pinch", (e) => handlePinch(chart, state, e));
      mc.on("pinchend", (e) => endPinch(chart, state, e));
    }
    if (panOptions && panOptions.enabled) {
      mc.add(new import_hammerjs.default.Pan({
        threshold: panOptions.threshold,
        enable: createEnabler(chart, state)
      }));
      mc.on("panstart", (e) => startPan(chart, state, e));
      mc.on("panmove", (e) => handlePan(chart, state, e));
      mc.on("panend", () => endPan(chart, state));
    }
    hammers.set(chart, mc);
  }
  function stopHammer(chart) {
    const mc = hammers.get(chart);
    if (mc) {
      mc.remove("pinchstart");
      mc.remove("pinch");
      mc.remove("pinchend");
      mc.remove("panstart");
      mc.remove("pan");
      mc.remove("panend");
      mc.destroy();
      hammers.delete(chart);
    }
  }
  var version2 = "2.0.1";
  function draw2(chart, caller, options) {
    const dragOptions = options.zoom.drag;
    const { dragStart, dragEnd } = getState(chart);
    if (dragOptions.drawTime !== caller || !dragEnd) {
      return;
    }
    const { left, top, width, height } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);
    const ctx = chart.ctx;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = dragOptions.backgroundColor || "rgba(225,225,225,0.3)";
    ctx.fillRect(left, top, width, height);
    if (dragOptions.borderWidth > 0) {
      ctx.lineWidth = dragOptions.borderWidth;
      ctx.strokeStyle = dragOptions.borderColor || "rgba(225,225,225)";
      ctx.strokeRect(left, top, width, height);
    }
    ctx.restore();
  }
  var plugin = {
    id: "zoom",
    version: version2,
    defaults: {
      pan: {
        enabled: false,
        mode: "xy",
        threshold: 10,
        modifierKey: null
      },
      zoom: {
        wheel: {
          enabled: false,
          speed: 0.1,
          modifierKey: null
        },
        drag: {
          enabled: false,
          drawTime: "beforeDatasetsDraw",
          modifierKey: null
        },
        pinch: {
          enabled: false
        },
        mode: "xy"
      }
    },
    start: function(chart, _args, options) {
      const state = getState(chart);
      state.options = options;
      if (Object.prototype.hasOwnProperty.call(options.zoom, "enabled")) {
        console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.");
      }
      if (Object.prototype.hasOwnProperty.call(options.zoom, "overScaleMode") || Object.prototype.hasOwnProperty.call(options.pan, "overScaleMode")) {
        console.warn("The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).");
      }
      if (import_hammerjs.default) {
        startHammer(chart, options);
      }
      chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);
      chart.zoom = (args, transition) => zoom(chart, args, transition);
      chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);
      chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);
      chart.resetZoom = (transition) => resetZoom(chart, transition);
      chart.getZoomLevel = () => getZoomLevel(chart);
      chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);
      chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);
    },
    beforeEvent(chart) {
      const state = getState(chart);
      if (state.panning || state.dragging) {
        return false;
      }
    },
    beforeUpdate: function(chart, args, options) {
      const state = getState(chart);
      state.options = options;
      addListeners(chart, options);
    },
    beforeDatasetsDraw(chart, _args, options) {
      draw2(chart, "beforeDatasetsDraw", options);
    },
    afterDatasetsDraw(chart, _args, options) {
      draw2(chart, "afterDatasetsDraw", options);
    },
    beforeDraw(chart, _args, options) {
      draw2(chart, "beforeDraw", options);
    },
    afterDraw(chart, _args, options) {
      draw2(chart, "afterDraw", options);
    },
    stop: function(chart) {
      removeListeners(chart);
      if (import_hammerjs.default) {
        stopHammer(chart);
      }
      removeState(chart);
    },
    panFunctions,
    zoomFunctions,
    zoomRectFunctions
  };

  // js/control/ProfileUI.js
  var import_leaflet19 = __toESM(require_leaflet_src());
  auto_default.register(plugin);
  var ProfileUI = UI.extend({
    options: {
      title: "Profile overlays",
      profile: true,
      profileColor: "#FF00FF",
      spectrum: true,
      spectrumColor: "#A000FF",
      collapsed: true,
      position: "topleft",
      chartZoomOptions: {
        zoom: {
          wheel: {
            enabled: true
          },
          pinch: {
            enabled: true
          },
          drag: {
            enabled: true,
            modifierKey: "shift"
          },
          scaleMode: "xy",
          mode: "xy"
        },
        pan: {
          enabled: true,
          scaleMode: "xy"
        },
        limits: {
          x: { min: "original", max: "original" },
          y: { min: "original", max: "original" }
        }
      }
    },
    initialize: function(options) {
      import_leaflet19.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-profile";
      this._layers = {};
      this._sideClass = "profile";
      this._handlingClick = false;
    },
    _initDialog: function() {
      const _this = this, options = this.options, className = this._className, box = this._addDialogBox();
      this._wcs = this._map.options.crs;
      if (options.profile) {
        const line = this._addDialogLine("Profile:", box), elem = this._addDialogElement(line), linecolpick = this._addColorPicker(
          className + "-color",
          elem,
          "profile",
          options.profileColor,
          "visiomaticProfile",
          title = "Click to set line color"
        );
        this._addButton(
          className + "-button",
          elem,
          "start",
          "Start drawing a profile line",
          () => {
            if (this._currProfileLine) {
              this._updateLine();
            } else {
              const map4 = _this._map, point8 = map4.getCenter(), line2 = this._currProfileLine = (0, import_leaflet19.polyline)(
                [point8, point8],
                {
                  color: linecolpick.value,
                  weight: 7,
                  opacity: 0.5
                }
              ), licon = this._currProfileLength = (0, import_leaflet19.divIcon)(
                {
                  className: className + "-length",
                  html: '<p style="font-size: 15pt; color: ' + linecolpick.value + ';">0&#34;</p>'
                }
              ), lmarker = this._currProfileLengthMarker = (0, import_leaflet19.marker)(
                point8,
                { icon: licon }
              );
              line2.nameColor = linecolpick.value;
              line2.addTo(map4);
              lmarker.addTo(map4);
              map4.on("drag", this._updateLine, this);
            }
          }
        );
        this._addButton(
          className + "-button",
          elem,
          "end",
          "End line and plot",
          this._profileEnd
        );
      }
      if (options.spectrum) {
        const line = this._addDialogLine("Spectrum:", box), elem = this._addDialogElement(line);
        const speccolpick = this._addColorPicker(
          className + "-color",
          elem,
          "spectrum",
          options.spectrumColor,
          "visiomaticSpectra",
          title = "Click to set marker color"
        );
        this._addButton(
          className + "-button",
          elem,
          "spectrum",
          "Plot a spectrum at the current map position",
          () => {
            const map4 = _this._map, latLng11 = map4.getCenter(), zoom2 = _this._wcs.options.nzoom - 1, point8 = map4.project(latLng11, zoom2).floor().add([0.5, 0.5]), rLatLng = map4.unproject(point8, zoom2), marker3 = this._spectrumMarker = (0, import_leaflet19.circleMarker)(rLatLng, {
              color: speccolpick.value,
              radius: 6,
              title: "Spectrum"
            }).addTo(map4), popdiv = import_leaflet19.DomUtil.create(
              "div",
              this._className + "-popup"
            ), activity = import_leaflet19.DomUtil.create(
              "div",
              this._className + "-activity",
              popdiv
            );
            popdiv.id = "leaflet-spectrum-plot";
            marker3.bindPopup(
              popdiv,
              {
                minWidth: 16,
                maxWidth: 1024,
                closeOnClick: false
              }
            ).openPopup();
            VUtil.requestURL(
              this._layer._url.replace(/\&.*$/g, "") + "&PFL=" + zoom2.toString() + ":" + (point8.x - 0.5).toFixed(0) + "," + (point8.y - 0.5).toFixed(0) + "-" + (point8.x - 0.5).toFixed(0) + "," + (point8.y - 0.5).toFixed(0),
              "getting layer spectrum",
              this._plotSpectrum,
              this
            );
          }
        );
      }
    },
    _updateLine: function(e) {
      const map4 = this._map, maxzoom = this._wcs.options.nzoom - 1, path = this._currProfileLine.getLatLngs(), point1 = map4.project(path[0], maxzoom), point22 = map4.project(map4.getCenter(), maxzoom);
      path[1] = map4.unproject(point22, maxzoom);
      this._currProfileLength.options.html = this._currProfileLength.options.html.replace(
        />[\d.&#;]+</,
        ">" + this._getDistanceString(path[0], path[1]) + "<"
      );
      this._currProfileLengthMarker.setLatLng(
        this._currProfileLine.getCenter()
      );
      this._currProfileLengthMarker.setIcon(this._currProfileLength);
      this._currProfileLine.redraw();
    },
    _profileEnd: async function() {
      const map4 = this._map, wcs2 = this._wcs, point8 = map4.getCenter(), line = this._profileLine = this._currProfileLine;
      map4.off("drag", this._updateLine, this);
      this._currProfileLengthMarker.remove();
      this._currProfileLengthMarker = void 0;
      this._currProfileLine = void 0;
      const popdiv = this._popDiv = import_leaflet19.DomUtil.create(
        "div",
        "visiomatic-profile-plot"
      ), activity = import_leaflet19.DomUtil.create(
        "div",
        this._className + "-activity",
        popdiv
      );
      line.bindPopup(
        popdiv,
        { minWidth: 16, maxWidth: 1024, closeOnClick: false }
      ).openPopup();
      const zoom2 = wcs2.options.nzoom - 1, path = line.getLatLngs(), point1 = wcs2.project(path[0]), point22 = wcs2.project(path[1]);
      if (point22.x < point1.x) {
        const x = point22.x, y = point22.y;
        point22.x = point1.x;
        point1.x = x;
        point22.y = point1.y;
        point1.y = y;
        line.lr = false;
      } else {
        line.lr = true;
      }
      const layer = this._layer, visio = layer.visio;
      response = await fetch(
        layer._url.replace(/\&.*$/g, "") + (visio.mode === "mono" ? `&CHAN=${visio.channel + 1}` : visio.rgb.map((rgb2, c2) => `&CHAN=${c2 + 1}`).join("")) + "&PFL=" + point1.x.toFixed(0) + "," + point1.y.toFixed(0) + ":" + point22.x.toFixed(0) + "," + point22.y.toFixed(0)
      );
      if (response.status == 200) {
        this._plotProfile(await response);
      } else {
        alert("Error " + response.status + " while getting profile.");
      }
    },
    _getDistanceString: function(latlng1, latlng2) {
      let distance = this._wcs.distance(latlng1, latlng2);
      var unit;
      if (distance >= 1) {
        unit = "&#176;";
      } else {
        distance *= 60;
        if (distance >= 1) {
          unit = "&#39;";
        } else {
          distance *= 60;
          unit = "&#34;";
        }
      }
      const distanceStr = distance.toFixed(2) + unit;
      return distanceStr;
    },
    _plotProfile: async function(response2) {
      const json = await response2.json(), rawprof = json.profile, layer = this._layer, visio = layer.visio, line = this._profileLine, popdiv = this._popDiv, prof = [], series = [];
      this.addLayer(line, "Image profile");
      const monoflag = visio.mode === "mono", chart = new auto_default(
        import_leaflet19.DomUtil.create(
          "canvas",
          this._className + "-canvas",
          popdiv
        ),
        {
          type: "line",
          data: {
            labels: rawprof.map((point8) => [point8[0], point8[1]]),
            datasets: monoflag ? [{
              label: "profile",
              data: rawprof.map((point8) => point8[2][0])
            }] : visio.rgb.map(
              (rgb2, c2) => ({
                label: visio.channelLabels[c2],
                borderColor: rgb2.toStr()
              })
            ).filter(Boolean).map(
              (dataset, i2) => ({
                ...dataset,
                ...{ data: rawprof.map((point8) => point8[2][i2]) }
              })
            )
          },
          options: {
            pointRadius: 0,
            stepped: "middle",
            scales: {
              x: {
                title: {
                  display: true,
                  text: "position along line",
                  color: getComputedStyle(this._map._container).getPropertyValue("--dialog-color")
                }
              },
              y: {
                title: {
                  display: true,
                  text: "Pixel value",
                  color: getComputedStyle(this._map._container).getPropertyValue("--dialog-color")
                }
              }
            },
            maintainAspectRatio: false,
            interaction: {
              mode: "nearest",
              intersect: true
            },
            plugins: {
              title: {
                display: true,
                text: monoflag ? "Image profile for " + visio.channelLabels[visio.channel] : "Image profiles",
                color: getComputedStyle(this._map._container).getPropertyValue("--dialog-color")
              },
              legend: {
                display: !monoflag
              },
              zoom: this.options.chartZoomOptions
            }
          }
        }
      );
      this._map.on(
        "themeChange",
        () => {
          chart.options.scales.x.title.color = chart.options.scales.y.title.color = getComputedStyle(
            this._map._container
          ).getPropertyValue("--dialog-color");
          chart.options.plugins.title.color = getComputedStyle(
            this._map._container
          ).getPropertyValue("--dialog-color");
          chart.update();
        }
      );
      popdiv.removeChild(
        popdiv.childNodes[0]
      );
      line._popup.update();
    },
    _extractProfile: function(layer, rawprof, channel) {
      const nchan = layer.visio.nChannel, npix = rawprof.length, prof = [];
      for (let i2 = 0; i2 < npix; i2++) {
        prof.push(rawprof[i2][2][channel]);
      }
      return prof;
    },
    _plotSpectrum: function(self2, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const json = JSON.parse(httpRequest.responseText), rawprof = json.profile, layer = self2._layer, visio = layer.visio, marker3 = self2._spectrumMarker, popdiv = document.getElementById("leaflet-spectrum-plot"), spec = [], series = [], title2 = "Image Spectrum", ylabel = "Average pixel value";
          self2.addLayer(marker3, "Image spectrum");
          for (let c2 = 0; c2 < visio.nChannel; c2++) {
            spec.push([
              visio.channelLabels[c2],
              self2._extractAverage(layer, rawprof, c2)
            ]);
          }
          popdiv.removeChild(
            popdiv.childNodes[0]
          );
          marker3._popup.update();
        }
      }
    },
    _extractAverage: function(layer, rawprof, channel) {
      const nchan = layer.visio.nChannel, npix = rawprof.length / nchan;
      let val = 0;
      if (npix === 0) {
        return 0;
      }
      for (let i2 = 0; i2 < npix; i2++) {
        val += rawprof[i2 * nchan + channel];
      }
      return val / npix;
    }
  });
  var profileUI = function(options) {
    return new ProfileUI(options);
  };

  // js/control/RegionUI.js
  var import_leaflet20 = __toESM(require_leaflet_src());
  var RegionUI = UI.extend({
    options: {
      title: "Region overlays",
      nativeCelSys: true,
      color: "#00FFFF",
      timeOut: 30,
      collapsed: true,
      position: "topleft"
    },
    initialize: function(regions, options) {
      import_leaflet20.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-region";
      this._layers = {};
      this._handlingClick = false;
      this._sideClass = "region";
      this._regions = regions && regions[0] ? regions : [];
    },
    _initDialog: function() {
      const className = this._className, regions = this._regions, box = this._addDialogBox(), line = this._addDialogLine("Regions:", box), elem = this._addDialogElement(line), colpick = this._addColorPicker(
        className + "-color",
        elem,
        "region",
        this.options.color,
        "visiomaticRegion",
        title = "Click to set region color"
      );
      const select = this._regionSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        regions.map(function(o) {
          return o.name;
        }),
        regions.map(function(o) {
          return o.load ? true : false;
        }),
        -1,
        "Select region"
      );
      this._addButton(
        className + "-button",
        this._addDialogElement(line),
        "region",
        "Display region",
        function() {
          const index3 = select.selectedIndex - 1;
          if (index3 >= 0) {
            const region2 = this._regions[index3];
            region2.color = colpick.value;
            select.selectedIndex = 0;
            select.opt[index3].disabled = true;
            this._getRegion(region2, this.options.timeOut);
          }
        }
      );
      for (var index2 = 0; index2 < regions.length; index2++) {
        var region = regions[index2];
        region.index = index2;
        if (region.load === true) {
          if (!region.color) {
            region.color = this.options.color;
          }
          this._getRegion(regions[index2], this.options.timeOut);
        }
      }
    },
    _resetDialog: function() {
    },
    _getRegion: function(region, timeout) {
      const _this = this, map4 = this._map, wcs2 = map4.options.crs, sysflag = !wcs2.equatorialFlag && !this.options.nativeCelSys, templayer = new import_leaflet20.LayerGroup(null);
      templayer.notReady = true;
      this.addLayer(templayer, region.name);
      VUtil.requestURL(
        region.url,
        "loading " + region.name + " data",
        function(context, httpRequest) {
          _this._loadRegion(region, templayer, context, httpRequest);
        },
        this,
        this.options.timeOut
      );
    },
    _loadRegion: function(region, templayer, _this, httpRequest) {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          const wcs2 = _this._map.options.crs, response2 = httpRequest.responseText, geoRegion = (0, import_leaflet20.geoJson)(
            JSON.parse(response2),
            {
              onEachFeature: function(feature, layer) {
                if (feature.properties && feature.properties.description) {
                  layer.bindPopup(feature.properties.description);
                } else if (region.description) {
                  layer.bindPopup(region.description);
                }
              },
              coordsToLatLng: function(coords2) {
                if (wcs2.equatorialFlag) {
                  return new import_leaflet20.LatLng(coords2[1], coords2[0], coords2[2]);
                } else {
                  const latLng11 = wcs2.eqToCelSys(
                    latLng11(coords2[1], coords2[0])
                  );
                  return new import_leaflet20.LatLng(
                    latLng11.lat,
                    latLng11.lng,
                    coords2[2]
                  );
                }
              },
              style: function(feature) {
                return { color: region.color, weight: 2 };
              },
              pointToLayer: function(feature, latlng) {
                return region.drawPoint ? region.drawPoint(feature, latlng) : (0, import_leaflet20.marker)(latlng);
              }
            }
          );
          geoRegion.nameColor = region.color;
          geoRegion.addTo(_this._map);
          _this.removeLayer(templayer);
          _this.addLayer(geoRegion, region.name, region.index);
          import_leaflet20.DomEvent.on(geoRegion, "trash", function(e) {
            if (e.index || e.index === 0) {
              _this._regionSelect.opt[e.index].disabled = false;
            }
          }, _this);
        } else {
          if (httpRequest.status !== 0) {
            alert("Error " + httpRequest.status + " while downloading " + region.url + ".");
          }
          _this.removeLayer(templayer);
          _this._regionSelect.opt[region.index].disabled = false;
        }
      }
    }
  });
  var regionUI = function(regions, options) {
    return new RegionUI(regions, options);
  };

  // js/control/Reticle.js
  var import_leaflet21 = __toESM(require_leaflet_src());
  var Reticle = import_leaflet21.Control.extend({
    initialize: function(options) {
      import_leaflet21.Util.setOptions(this, options);
    },
    onAdd: function(map4) {
      const reticle2 = this._reticle = import_leaflet21.DomUtil.create(
        "div",
        "leaflet-reticle",
        this._map._controlContainer
      ), style = reticle2.style;
      style.position = "absolute";
      style.left = "50%";
      style.bottom = "50%";
      style.textAlign = "center";
      style.verticalAlign = "middle";
      style.pointerEvents = "none";
      reticle2.innerHTML = "";
      const container = this._container = import_leaflet21.DomUtil.create("div", "leaflet-dummy");
      return container;
    },
    onRemove: function(map4) {
      this._reticle.parentNode.removeChild(this._reticle);
    }
  });
  var reticle = function(options) {
    return new Reticle(options);
  };

  // js/control/Scale.js
  var import_leaflet22 = __toESM(require_leaflet_src());
  var Scale2 = import_leaflet22.Control.Scale.extend({
    options: {
      title: "Scale",
      position: "bottomleft",
      maxWidth: 128,
      metric: false,
      imperial: false,
      degrees: true,
      pixels: false,
      custom: false,
      customScale: 1,
      customUnits: "",
      planetRadius: 6378137,
      updateWhenIdle: false
    },
    initialize: function(options) {
      import_leaflet22.Util.setOptions(this, options);
    },
    _addScales: function(options, className, container) {
      if (options.metric) {
        this._mScale = import_leaflet22.DomUtil.create("div", className, container);
        this._mScale.title = options.metricTitle ? options.metricTitle : options.title;
      }
      if (options.imperial) {
        this._iScale = import_leaflet22.DomUtil.create("div", className, container);
        this._iScale.title = options.imperialTitle ? options.imperialTitle : options.title;
      }
      if (options.degrees) {
        this._dScale = import_leaflet22.DomUtil.create("div", className, container);
        this._dScale.title = options.degreesTitle ? options.degreesTitle : options.title;
      }
      if (options.pixels) {
        this._pScale = import_leaflet22.DomUtil.create("div", className, container);
        this._pScale.title = options.pixelsTitle ? options.pixelsTitle : options.title;
      }
      if (options.custom) {
        this._cScale = import_leaflet22.DomUtil.create("div", className, container);
        this._cScale.title = options.customTitle ? options.customTitle : options.title;
      }
      this.angular = options.metric || options.imperial || options.degrees;
    },
    _update: function() {
      const options = this.options, map4 = this._map, crs = map4.options.crs;
      if (options.pixels && crs.options && crs.options.nzoom) {
        const pixelScale = Math.pow(
          2,
          crs.options.nzoom - 1 - map4.getZoom()
        );
        this._updatePixels(pixelScale * options.maxWidth);
      }
      if (options.custom && crs.options && crs.options.nzoom) {
        const customScale = Math.pow(
          2,
          crs.options.nzoom - 1 - map4.getZoom()
        ) * options.customScale;
        this._updateCustom(
          customScale * options.maxWidth,
          options.customUnits
        );
      }
      if (this.angular) {
        const center = map4.getCenter(), cosLat = Math.cos(center.lat * Math.PI / 180), dist = Math.sqrt(this._jacobian(center)) * cosLat, maxDegrees = dist * options.maxWidth;
        if (options.metric) {
          this._updateMetric(
            maxDegrees * Math.PI / 180 * options.planetRadius
          );
        }
        if (options.imperial) {
          this._updateImperial(
            maxDegrees * Math.PI / 180 * options.planetRadius
          );
        }
        if (options.degrees) {
          this._updateDegrees(maxDegrees);
        }
      }
    },
    _jacobian: function(latlng) {
      const map4 = this._map, p0 = map4.project(latlng), latlngdx = map4.unproject(p0.add([10, 0])), latlngdy = map4.unproject(p0.add([0, 10]));
      return 0.01 * Math.abs((latlngdx.lng - latlng.lng) * (latlngdy.lat - latlng.lat) - (latlngdy.lng - latlng.lng) * (latlngdx.lat - latlng.lat));
    },
    _updateCustom: function(maxCust, units) {
      const scale2 = this._cScale;
      if (maxCust > 1e9) {
        var maxGCust = maxCust * 1e-9, gCust = this._getRoundNum(maxGCust);
        this._updateScale(scale2, gCust + " G" + units, gCust / maxGCust);
      } else if (maxCust > 1e6) {
        var maxMCust = maxCust * 1e-6, mCust = this._getRoundNum(maxMCust);
        this._updateScale(scale2, mCust + " M" + units, mCust / maxMCust);
      } else if (maxCust > 1e3) {
        var maxKCust = maxCust * 1e-3, kCust = this._getRoundNum(maxKCust);
        this._updateScale(scale2, kCust + " k" + units, kCust / maxKCust);
      } else {
        var cust = this._getRoundNum(maxCust);
        this._updateScale(scale2, cust + " " + units, cust / maxCust);
      }
    },
    _updatePixels: function(maxPix) {
      const scale2 = this._pScale;
      if (maxPix > 1e6) {
        var maxMPix = maxPix * 1e-6, mPix = this._getRoundNum(maxMPix);
        this._updateScale(scale2, mPix + " Mpx", mPix / maxMPix);
      } else if (maxPix > 1e3) {
        var maxKPix = maxPix * 1e-3, kPix = this._getRoundNum(maxKPix);
        this._updateScale(scale2, kPix + " kpx", kPix / maxKPix);
      } else {
        var pix = this._getRoundNum(maxPix);
        this._updateScale(scale2, pix + " px", pix / maxPix);
      }
    },
    _updateDegrees: function(maxDegrees) {
      const maxSeconds = maxDegrees * 3600, scale2 = this._dScale;
      if (maxSeconds < 1) {
        var maxMas = maxSeconds * 1e3, mas = this._getRoundNum(maxMas);
        this._updateScale(scale2, mas + " mas", mas / maxMas);
      } else if (maxSeconds < 60) {
        var seconds = this._getRoundNum(maxSeconds);
        this._updateScale(scale2, seconds + " &#34;", seconds / maxSeconds);
      } else if (maxSeconds < 3600) {
        var maxMinutes = maxDegrees * 60, minutes = this._getRoundNum(maxMinutes);
        this._updateScale(scale2, minutes + " &#39;", minutes / maxMinutes);
      } else {
        var degrees = this._getRoundNum(maxDegrees);
        this._updateScale(scale2, degrees + " &#176;", degrees / maxDegrees);
      }
    }
  });
  var scale = function(options) {
    return new Scale2(options);
  };

  // js/control/Sidebar.js
  var import_leaflet23 = __toESM(require_leaflet_src());
  var Sidebar = import_leaflet23.Control.extend({
    includes: import_leaflet23.Evented && import_leaflet23.Evented.prototype,
    options: {
      title: "Toggle advanced menu",
      position: "left",
      collapsed: true,
      forceSeparateButton: false
    },
    initialize: function(options) {
      import_leaflet23.Util.setOptions(this, options);
      this._sidebar = import_leaflet23.DomUtil.create("div", "leaflet-container sidebar");
      if (this.options.collapsed) {
        import_leaflet23.DomUtil.addClass(this._sidebar, "collapsed");
      } else {
        import_leaflet23.DomUtil.addClass(this._sidebar, "closed");
      }
      import_leaflet23.DomUtil.addClass(this._sidebar, "sidebar-" + this.options.position);
      if (import_leaflet23.Browser.touch) {
        import_leaflet23.DomUtil.addClass(this._sidebar, "leaflet-touch");
      }
      this._tabs = import_leaflet23.DomUtil.create("div", "sidebar-tabs", this._sidebar);
      this._tabitems = [];
      this._container = import_leaflet23.DomUtil.create("div", "sidebar-content", this._sidebar);
      this._panes = [];
      this._closeButtons = [];
    },
    addTo: function(map4) {
      const className = "leaflet-control-zoom-sidebar", parent = map4._controlContainer;
      var buttonContainer;
      import_leaflet23.DomUtil.addClass(map4._container, "sidebar-map");
      parent.insertBefore(this._sidebar, parent.firstChild);
      import_leaflet23.DomEvent.disableClickPropagation(this._sidebar).disableScrollPropagation(this._sidebar);
      this._map = map4;
      if (map4.zoomControl && !this.options.forceSeparateButton) {
        buttonContainer = map4.zoomControl._container;
      } else {
        buttonContainer = import_leaflet23.DomUtil.create("div", "leaflet-bar");
      }
      this._toggleButton = this._addButton(
        this.options.title,
        className + (this.options.collapsed ? " collapsed" : ""),
        buttonContainer
      );
      return this;
    },
    addTabList: function() {
      this._tablist = import_leaflet23.DomUtil.create("ul", "", this._tabs);
      this._tablist.setAttribute("role", "tablist");
      return this._tablist;
    },
    addTab: function(id, className, title2, content, sideClass) {
      const tablist = this._tablist ? this._tablist : this.addTabList(), item = import_leaflet23.DomUtil.create("li", "", tablist), button = import_leaflet23.DomUtil.create("a", className, item);
      item.setAttribute("role", "tab");
      item._sidebar = this;
      button.href = "#" + id;
      button.id = id + "-toggle";
      button.title = title2;
      import_leaflet23.DomEvent.on(button, "click", L.DomEvent.preventDefault);
      import_leaflet23.DomEvent.on(button, "click", this._onClick, item);
      item.sideClass = sideClass;
      this._tabitems.push(item);
      const pane = import_leaflet23.DomUtil.create("div", "sidebar-pane", this._container), header = import_leaflet23.DomUtil.create("h1", "sidebar-header", pane);
      header.innerHTML = title2;
      const closeButton = import_leaflet23.DomUtil.create("div", "sidebar-close", header), closeIcon = import_leaflet23.DomUtil.create("div", "sidebar-close-icon", closeButton);
      this._closeButtons.push(closeButton);
      import_leaflet23.DomEvent.on(closeButton, "click", this._onCloseClick, this);
      pane.id = id;
      pane.sideClass = sideClass;
      pane.appendChild(content);
      this._panes.push(pane);
      return pane;
    },
    removeFrom: function(map4) {
      this._map = null;
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        import_leaflet23.DomEvent.off(child.querySelector("a"), "click", this._onClick);
      }
      for (var i2 = this._closeButtons.length - 1; i2 >= 0; i2--) {
        var child = this._closeButtons[i2];
        import_leaflet23.DomEvent.off(child, "click", this._onCloseClick, this);
      }
      return this;
    },
    open: function(id) {
      for (var i2 = this._panes.length - 1; i2 >= 0; i2--) {
        var child = this._panes[i2];
        if (child.id === id) {
          import_leaflet23.DomUtil.addClass(child, "active");
          if (child.sideClass) {
            import_leaflet23.DomUtil.addClass(this._sidebar, child.sideClass);
          }
        } else if (import_leaflet23.DomUtil.hasClass(child, "active")) {
          import_leaflet23.DomUtil.removeClass(child, "active");
          if (child.sideClass) {
            import_leaflet23.DomUtil.removeClass(this._sidebar, child.sideClass);
          }
        }
      }
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        if (child.querySelector("a").hash === "#" + id) {
          import_leaflet23.DomUtil.addClass(child, "active");
        } else if (import_leaflet23.DomUtil.hasClass(child, "active")) {
          import_leaflet23.DomUtil.removeClass(child, "active");
        }
      }
      this.fire("content", { id });
      if (import_leaflet23.DomUtil.hasClass(this._sidebar, "closed")) {
        this.fire("opening");
        import_leaflet23.DomUtil.removeClass(this._sidebar, "closed");
      }
      return this;
    },
    close: function() {
      for (var i2 = this._tabitems.length - 1; i2 >= 0; i2--) {
        var child = this._tabitems[i2];
        if (import_leaflet23.DomUtil.hasClass(child, "active")) {
          import_leaflet23.DomUtil.removeClass(child, "active");
          if (child.sideClass) {
            import_leaflet23.DomUtil.removeClass(this._sidebar, child.sideClass);
          }
        }
      }
      if (!import_leaflet23.DomUtil.hasClass(this._sidebar, "closed")) {
        this.fire("closing");
        import_leaflet23.DomUtil.addClass(this._sidebar, "closed");
      }
      return this;
    },
    toggle: function() {
      this.close();
      if (import_leaflet23.DomUtil.hasClass(this._sidebar, "collapsed")) {
        import_leaflet23.DomUtil.addClass(this._sidebar, "closed");
        this.fire("expanding");
        import_leaflet23.DomUtil.removeClass(this._sidebar, "collapsed");
        import_leaflet23.DomUtil.removeClass(this._toggleButton, "collapsed");
      } else {
        import_leaflet23.DomUtil.removeClass(this._sidebar, "closed");
        this.fire("collapsing");
        import_leaflet23.DomUtil.addClass(this._sidebar, "collapsed");
        import_leaflet23.DomUtil.addClass(this._toggleButton, "collapsed");
      }
    },
    _onClick: function() {
      if (import_leaflet23.DomUtil.hasClass(this, "active")) {
        this._sidebar.close();
      } else if (!import_leaflet23.DomUtil.hasClass(this, "disabled")) {
        this._sidebar.open(this.querySelector("a").hash.slice(1));
      }
    },
    _onCloseClick: function() {
      this.close();
    },
    _addButton: function(title2, className, container) {
      const link = import_leaflet23.DomUtil.create("a", className, container);
      link.href = "#";
      link.title = title2;
      import_leaflet23.DomEvent.addListener(link, "click", import_leaflet23.DomEvent.stopPropagation).addListener(link, "click", import_leaflet23.DomEvent.preventDefault).addListener(link, "click", this.toggle, this);
      return link;
    }
  });
  var sidebar = function(map4, options) {
    return new Sidebar(map4, options);
  };

  // js/control/SnapshotUI.js
  var import_leaflet24 = __toESM(require_leaflet_src());
  var SnapshotUI = UI.extend({
    options: {
      title: "Snapshots",
      collapsed: true,
      position: "topleft"
    },
    initialize: function(options) {
      import_leaflet24.Util.setOptions(this, options);
      this._className = "visiomatic-control";
      this._id = "visiomatic-snapshot";
      this._sideClass = "snapshot";
    },
    _initDialog: function() {
      const _this = this, className = this._className, layer = this._layer, visio = layer.visio, map4 = this._map;
      const line = this._addDialogLine("Snap:", this._dialog), elem = this._addDialogElement(line), items = ["Screen pixels", "Native pixels"];
      this._snapType = 0;
      this._snapSelect = this._addSelectMenu(
        this._className + "-select",
        elem,
        items,
        void 0,
        this._snapType,
        "Select snapshot resolution",
        function() {
          this._snapType = parseInt(this._snapSelect.selectedIndex - 1, 10);
        }
      );
      const hiddenlink = document.createElement("a");
      const button = this._addButton(
        className + "-button",
        elem,
        "snapshot",
        "Take a snapshot of the displayed image",
        function(event) {
          const latlng = map4.getCenter(), bounds3 = map4.getPixelBounds(), wcs2 = map4.options.crs;
          let z = map4.getZoom();
          var zfac;
          if (z > visio.maxZoom) {
            zfac = Math.pow(2, z - visio.maxZoom);
            z = visio.maxZoom;
          } else {
            zfac = 1;
          }
          const sizex = visio.imageSize[z].x * zfac, sizey = visio.imageSize[z].y * zfac, dx = bounds3.max.x - bounds3.min.x, dy = bounds3.max.y - bounds3.min.y;
          hiddenlink.href = layer.getTileUrl(
            { x: 1, y: 1 }
          ).replace(
            /JTL\=\d+\,\d+/g,
            "RGN=" + bounds3.min.x / sizex + "," + bounds3.min.y / sizey + "," + dx / sizex + "," + dy / sizey + "&WID=" + (this._snapType === 0 ? Math.floor(dx / zfac) : Math.floor(dx / zfac / layer.wcs.scale(z))) + "&CVT=jpeg"
          );
          hiddenlink.download = layer._title + "_" + wcs2.latLngToHMSDMS(latlng).replace(/[\s\:\.]/g, "") + ".jpg";
          hiddenlink.click();
        }
      );
      document.body.appendChild(hiddenlink);
      const line2 = this._addDialogLine("Print:", this._dialog);
      this._addButton(
        className + "-button",
        this._addDialogElement(line2),
        "print",
        "Print current map",
        function(event) {
          var control = document.querySelector(
            "#map > .leaflet-control-container"
          );
          control.style.display = "none";
          window.print();
          control.style.display = "unset";
        }
      );
    }
  });
  var snapshotUI = function(options) {
    return new SnapshotUI(options);
  };

  // js/crs/index.js
  var crs_exports = {};
  __export(crs_exports, {
    CAR: () => CAR,
    CEA: () => CEA,
    COE: () => COE,
    Pixel: () => Pixel,
    TAN: () => TAN,
    TPV: () => TPV,
    WCS: () => WCS,
    ZEA: () => ZEA,
    wcs: () => wcs
  });

  // js/crs/WCS.js
  var import_leaflet30 = __toESM(require_leaflet_src());

  // js/crs/Conical.js
  var import_leaflet26 = __toESM(require_leaflet_src());

  // js/crs/Projection.js
  var import_leaflet25 = __toESM(require_leaflet_src());
  var Projection = import_leaflet25.Class.extend({
    bounds: (0, import_leaflet25.bounds)([-0.5, -0.5], [0.5, 0.5]),
    defaultProjParam: {
      name: "",
      ctype: { x: "PIXEL", y: "PIXEL" },
      naxis: [256, 256],
      crpix: [129, 129],
      crval: [0, 0],
      cd: [[1, 0], [0, 1]],
      natpole: [90, 999],
      pv: [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      npv: 0,
      jd: [0, 0],
      obslatlng: [0, 0]
    },
    initialize: function(header, options) {
      this._paramUpdate(this.defaultProjParam);
      this.options = options;
      this._readWCS(header);
      if (options) {
        this._paramUpdate(options);
      }
      this._projInit();
      projparam = this.projparam;
      if (!projparam._pixelFlag) {
        switch (projparam.ctype.x.substr(0, 1)) {
          case "G":
            projparam._celsyscode = "galactic";
            break;
          case "E":
            projparam._celsyscode = "ecliptic";
            break;
          case "S":
            projparam._celsyscode = "supergalactic";
            break;
          default:
            projparam._celsyscode = "equatorial";
            break;
        }
        this.equatorialFlag = !projparam.nativeCelSys || projparam._celsyscode == "equatorial";
        this.celSysConvFlag = !projparam.nativeCelSys && projparam._celsyscode !== "equatorial";
        if (this.celSysConvFlag) {
          projparam._celsysmat = this._celsysmatInit(this.celsyscode);
        }
      }
    },
    _paramUpdate: function(paramsrc) {
      if (!this.projparam) {
        this.projparam = {};
      }
      projparam = this.projparam;
      if (paramsrc.ctype) {
        projparam.ctype = { x: paramsrc.ctype.x, y: paramsrc.ctype.y };
      }
      if (paramsrc.naxis) {
        projparam.naxis = (0, import_leaflet25.point)(paramsrc.naxis);
      }
      if (paramsrc.crval) {
        projparam.crval = projparam.cpole = (0, import_leaflet25.latLng)(paramsrc.crval);
      }
      if (paramsrc.crpix) {
        projparam.crpix = (0, import_leaflet25.point)(paramsrc.crpix);
      }
      if (paramsrc.cd) {
        projparam.cd = [
          [paramsrc.cd[0][0], paramsrc.cd[0][1]],
          [paramsrc.cd[1][0], paramsrc.cd[1][1]]
        ];
      }
      if (paramsrc.natpole) {
        projparam.natpole = (0, import_leaflet25.latLng)(paramsrc.natpole);
      }
      if (paramsrc.pv) {
        projparam.pv = [];
        projparam.pv[0] = paramsrc.pv[0].slice();
        projparam.pv[1] = paramsrc.pv[1].slice();
      }
      if (paramsrc.npv) {
        projparam.npv = (0, import_leaflet25.point)(paramsrc.npv);
      }
      if (paramsrc.jd) {
        projparam.jd = [paramsrc.jd[0], paramsrc.jd[1]];
      }
      if (paramsrc.obslatlng) {
        projparam.obslatlng = [
          paramsrc.obslatlng[0],
          paramsrc.obslatlng[1]
        ];
      }
      projparam.dataslice = paramsrc.dataslice ? paramsrc.dataslice : [[1, projparam.naxis[0], 1], [1, projparam.naxis[1], 1]];
      if (paramsrc.detslice) {
        projparam.detslice = paramsrc.detslice;
      }
    },
    _readWCS: function(header) {
      const projparam2 = this.projparam;
      let npv = -1;
      var v;
      this.name = projparam2.name;
      if (v = header["EXTNAME"]) {
        this.name = v;
      }
      if (v = header["CTYPE1"]) {
        projparam2.ctype.x = v;
      }
      if (v = header["CTYPE2"]) {
        projparam2.ctype.y = v;
      }
      if (v = header["NAXIS1"]) {
        projparam2.naxis.x = v;
      }
      if (v = header["NAXIS2"]) {
        projparam2.naxis.y = v;
      }
      if (v = header["CRPIX1"]) {
        projparam2.crpix.x = v;
      }
      if (v = header["CRPIX2"]) {
        projparam2.crpix.y = v;
      }
      if (v = header["CRVAL1"]) {
        projparam2.crval.lng = v;
      }
      if (v = header["CRVAL2"]) {
        projparam2.crval.lat = v;
      }
      if (v = header["LONPOLE"]) {
        projparam2.natpole.lng = v;
      }
      if (v = header["LATPOLE"]) {
        projparam2.natpole.lat = v;
      }
      if (v = header["CD1_1"]) {
        projparam2.cd[0][0] = v;
      }
      if (v = header["CD1_2"]) {
        projparam2.cd[0][1] = v;
      }
      if (v = header["CD2_1"]) {
        projparam2.cd[1][0] = v;
      }
      if (v = header["CD2_2"]) {
        projparam2.cd[1][1] = v;
      }
      for (var d2 = 0; d2 < 2; d2++) {
        var pv = projparam2.pv[d2];
        for (var j = 0; j < 40; j++) {
          if (v = header["PV" + (d2 + 1) + "_" + j]) {
            pv[j] = v;
            npv = j > npv ? j : npv;
          }
        }
      }
      projparam2.npv = npv + 1;
      if ((v = header["MJD-OBS"]) || (v = header["MJDSTART"])) {
        projparam2.jd[0] = v + 24000005e-1;
      } else if (v = header["DATE-OBS"]) {
        projparam2.jd[0] = new Date(v).getTime() / 864e5 + 24405875e-1;
      }
      if (v = header["MJDEND"]) {
        projparam2.jd[1] = v + 24000005e-1;
      } else if (v = header["EXPTIME"]) {
        projparam2.jd[1] = projparam2.jd[0] + v / 86400;
      }
      if (v = header["LONGITUD"]) {
        projparam2.obslatlng[1] = v;
      }
      if (v = header["LATITUDE"]) {
        projparam2.obslatlng[0] = v;
      }
    },
    _shiftWCS: function(projparam2) {
      const crpix = projparam2.crpix, cd = projparam2.cd, dataslice = projparam2.dataslice, detslice = projparam2.detslice;
      crpix.x = detslice[0][0] + detslice[0][2] * (crpix.x - dataslice[0][0]);
      crpix.y = detslice[1][0] + detslice[1][2] * (crpix.y - dataslice[1][0]);
      cd[0][0] *= detslice[0][2];
      cd[0][1] *= detslice[1][2];
      cd[1][0] *= detslice[0][2];
      cd[1][1] *= detslice[1][2];
    },
    _celsysmatInit: function(celsyscode) {
      const deg = Math.PI / 180, cmat = [];
      var corig, cpole;
      switch (celsyscode) {
        case "galactic":
          corig = (0, import_leaflet25.latLng)(-28.93617242, 266.40499625);
          cpole = (0, import_leaflet25.latLng)(27.1282512, 192.85948123);
          break;
        case "ecliptic":
          corig = (0, import_leaflet25.latLng)(0, 0);
          cpole = (0, import_leaflet25.latLng)(66.99111111, 273.85261111);
          break;
        case "supergalactic":
          corig = (0, import_leaflet25.latLng)(59.52315, 42.29235);
          cpole = (0, import_leaflet25.latLng)(15.7048, 283.7514);
          break;
        default:
          corig = (0, import_leaflet25.latLng)(0, 0);
          cpole = (0, import_leaflet25.latLng)(0, 0);
          break;
      }
      cmat[0] = cpole.lng * deg;
      cmat[1] = Math.asin(Math.cos(corig.lat * deg) * Math.sin((cpole.lng - corig.lng) * deg));
      cmat[2] = Math.cos(cpole.lat * deg);
      cmat[3] = Math.sin(cpole.lat * deg);
      return cmat;
    },
    project: function(latlng) {
      const phiTheta = this._raDecToPhiTheta(
        this.celSysConvFlag ? this.eqToCelSys(latlng) : latlng
      );
      phiTheta.lat = this._thetaToR(phiTheta.lat);
      return this._redToPix(this._phiRToRed(phiTheta));
    },
    unproject: function(pnt) {
      const phiTheta = this._redToPhiR(this._pixToRed(pnt));
      phiTheta.lat = this._rToTheta(phiTheta.lat);
      const latlng = this._phiThetaToRADec(phiTheta);
      if (latlng.lng < -180) {
        latlng.lng += 360;
      }
      return this.celSysConvFlag ? this.celSysToEq(latlng) : latlng;
    },
    celSysToEq: function(latlng) {
      const cmat = this.projparam._celsysmat, deg = Math.PI / 180, invdeg = 180 / Math.PI, a2 = latlng.lng * deg - cmat[1], d2 = latlng.lat * deg, sd2 = Math.sin(d2), cd2cp = Math.cos(d2) * cmat[2], sd = sd2 * cmat[3] - cd2cp * Math.cos(a2);
      return L.latLng(
        Math.asin(sd) * invdeg,
        ((Math.atan2(cd2cp * Math.sin(a2), sd2 - sd * cmat[3]) + cmat[0]) * invdeg + 360) % 360
      );
    },
    eqToCelSys: function(latlng) {
      const cmat = this.projparam._celsysmat, deg = Math.PI / 180, invdeg = 180 / Math.PI, a = latlng.lng * deg - cmat[0], sd = Math.sin(latlng.lat * deg), cdcp = Math.cos(latlng.lat * deg) * cmat[2], sd2 = sd * cmat[3] + cdcp * Math.cos(a);
      return L.latLng(
        Math.asin(sd2) * invdeg,
        ((Math.atan2(cdcp * Math.sin(a), sd2 * cmat[3] - sd) + cmat[1]) * invdeg + 360) % 360
      );
    },
    _getCenter(proj2) {
      const projparam2 = this.projparam, detslice = projparam2.detslice;
      return detslice ? (0, import_leaflet25.point)(detslice[0][0], detslice[1][0])._add(
        (0, import_leaflet25.point)(detslice[0][1], detslice[1][1])
      )._divideBy(2) : (0, import_leaflet25.point)(
        (projparam2.naxis.x + 1) / 2,
        (projparam2.naxis.y + 1) / 2
      );
    },
    _natpole: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam, natpole = (0, import_leaflet25.latLng)(90, 180);
      if (projparam2._natrval.lat === 90) {
        if (projparam2.natpole.lng === 999) {
          natpole.lng = 180;
        }
        natpole.lat = projparam2.crval.lat;
      } else if (projparam2.natpole.lng === 999) {
        natpole.lng = projparam2.crval.lat < projparam2._natrval.lat ? 180 : 0;
      }
      return natpole;
    },
    _cpole: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam, dphip = projparam2._natpole.lng - projparam2._natrval.lng, cdphip = Math.cos(dphip * deg), sdphip = Math.sin(dphip * deg), ct0 = Math.cos(projparam2._natrval.lat * deg), st0 = Math.sin(projparam2._natrval.lat * deg), cd0 = Math.cos(projparam2.crval.lat * deg), sd0 = Math.sin(projparam2.crval.lat * deg), ddeltap = Math.acos(sd0 / Math.sqrt(1 - ct0 * ct0 * sdphip * sdphip)) / deg;
      let deltap = Math.atan2(st0, ct0 * cdphip) / deg, deltap1 = deltap + ddeltap, deltap2 = deltap - ddeltap;
      if (deltap1 < -180) {
        deltap1 += 360;
      } else if (deltap1 > 180) {
        deltap1 -= 360;
      }
      if (deltap2 < -180) {
        deltap2 += 360;
      } else if (deltap2 > 180) {
        deltap2 -= 360;
      }
      if (deltap1 > 90) {
        deltap = deltap2;
      } else if (deltap2 < -90) {
        deltap = deltap1;
      } else {
        deltap = Math.abs(deltap1 - projparam2._natpole.lat) < Math.abs(deltap2 - projparam2._natpole.lat) ? deltap1 : deltap2;
      }
      const alphap = Math.abs(projparam2.crval.lat) === 90 ? projparam2.crval.lng : deltap === 90 ? projparam2.crval.lng + projparam2._natpole.lng - projparam2._natrval.lng - 180 : deltap === -90 ? projparam2.crval.lng - projparam2._natpole.lng + projparam2._natrval.lng : projparam2.crval.lng - Math.atan2(
        sdphip * ct0 / cd0,
        (st0 - Math.sin(deltap * deg) * sd0) / (Math.cos(deltap * deg) * cd0)
      ) / deg;
      return (0, import_leaflet25.latLng)(deltap, alphap);
    },
    _phiThetaToRADec: function(phiTheta) {
      const projparam2 = this.projparam, deg = Math.PI / 180, rad = 180 / Math.PI, t = phiTheta.lat * deg, ct = Math.cos(t), st = Math.sin(t), dp = projparam2._cpole.lat * deg, cdp = Math.cos(dp), sdp = Math.sin(dp), dphi = (phiTheta.lng - projparam2._natpole.lng) * deg, cdphi = Math.cos(dphi);
      let asinarg = st * sdp + ct * cdp * cdphi;
      if (asinarg > 1) {
        asinarg = 1;
      } else if (asinarg < -1) {
        asinarg = -1;
      }
      return (0, import_leaflet25.latLng)(
        Math.asin(asinarg) * rad,
        projparam2._cpole.lng + Math.atan2(
          -ct * Math.sin(dphi),
          st * cdp - ct * sdp * cdphi
        ) * rad
      );
    },
    _raDecToPhiTheta: function(raDec) {
      const projparam2 = this.projparam, deg = Math.PI / 180, rad = 180 / Math.PI, da = (raDec.lng - projparam2._cpole.lng) * deg, cda = Math.cos(da), sda = Math.sin(da), d2 = raDec.lat * deg, cd = Math.cos(d2), sd = Math.sin(d2), dp = projparam2._cpole.lat * deg, cdp = Math.cos(dp), sdp = Math.sin(dp), asinarg = sd * sdp + cd * cdp * cda, phitheta = (0, import_leaflet25.latLng)(
        Math.asin(asinarg > 1 ? 1 : asinarg < -1 ? -1 : asinarg) * rad,
        projparam2._natpole.lng + Math.atan2(
          -cd * sda,
          sd * cdp - cd * sdp * cda
        ) * rad
      );
      if (phitheta.lng > 180) {
        phitheta.lng -= 360;
      } else if (phitheta.lng < -180) {
        phitheta.lng += 360;
      }
      return phitheta;
    },
    _pixToRed: function(pix) {
      const projparam2 = this.projparam, cd = projparam2.cd, red = pix.subtract(projparam2.crpix);
      return (0, import_leaflet25.point)(
        red.x * cd[0][0] + red.y * cd[0][1],
        red.x * cd[1][0] + red.y * cd[1][1]
      );
    },
    _redToPix: function(red) {
      const projparam2 = this.projparam, cdinv = projparam2._cdinv;
      return (0, import_leaflet25.point)(
        red.x * cdinv[0][0] + red.y * cdinv[0][1],
        red.x * cdinv[1][0] + red.y * cdinv[1][1]
      ).add(projparam2.crpix);
    },
    _pixToMulti: function(pnt) {
      const dataslice = this.projparam.dataslice, detslice = this.projparam.detslice;
      return (0, import_leaflet25.point)([
        (pnt.x - dataslice[0][0]) * detslice[0][2] + detslice[0][0],
        (pnt.y - dataslice[1][0]) * detslice[1][2] + detslice[1][0]
      ]);
    },
    _multiToPix: function(pnt) {
      const dataslice = this.projparam.dataslice, detslice = this.projparam.detslice;
      return (0, import_leaflet25.point)([
        (pnt.x - detslice[0][0]) * detslice[0][2] + dataslice[0][0],
        (pnt.y - detslice[1][0]) * detslice[1][2] + dataslice[1][0]
      ]);
    },
    _invertCD: function(cd) {
      const detinv = 1 / (cd[0][0] * cd[1][1] - cd[0][1] * cd[1][0]);
      return [
        [cd[1][1] * detinv, -cd[0][1] * detinv],
        [-cd[1][0] * detinv, cd[0][0] * detinv]
      ];
    }
  });

  // js/crs/Conical.js
  Conical = Projection.extend({
    _redToPhiR: function(red) {
      const deg = Math.PI / 180, projparam2 = this.projparam, dy = projparam2._y0 - red.y, rTheta = projparam2._sthetaA * Math.sqrt(red.x * red.x + dy * dy);
      return (0, import_leaflet26.latLng)(
        rTheta,
        Math.atan2(red.x / rTheta, dy / rTheta) / projparam2._c / deg
      );
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180, p = this.projparam._c * phiR.lng * deg;
      return (0, import_leaflet26.point)(
        phiR.lat * Math.sin(p),
        this.projparam._y0 - phiR.lat * Math.cos(p)
      );
    }
  });
  var COE = Conical.extend({
    _projInit: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._thetaA = projparam2.pv[1][1];
      projparam2._eta = projparam2.pv[1][2];
      projparam2._sthetaA = projparam2._thetaA >= 0 ? 1 : -1;
      const theta1 = projparam2._thetaA - projparam2._eta, theta2 = projparam2._thetaA + projparam2._eta, s1 = Math.sin(theta1 * deg), s2 = Math.sin(theta2 * deg);
      projparam2._gamma = s1 + s2;
      projparam2._s1s2p1 = s1 * s2 + 1;
      projparam2._c = projparam2._gamma / 2;
      projparam2._y0 = 2 / projparam2._gamma * Math.sqrt(projparam2._s1s2p1 - projparam2._gamma * Math.sin(projparam2._thetaA * deg)) / deg;
      projparam2._natrval = (0, import_leaflet26.latLng)(projparam2._thetaA, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _rToTheta: function(r) {
      const deg = Math.PI / 180, gamma = this.projparam._gamma;
      let sinarg = this.projparam._s1s2p1 / gamma - gamma * r * r * deg * deg / 4;
      if (sinarg < -1) {
        sinarg = -1;
      } else if (sinarg > 1) {
        sinarg = 1;
      }
      return Math.asin(sinarg) / deg;
    },
    _thetaToR: function(theta) {
      const deg = Math.PI / 180, gamma = this.projparam._gamma;
      return 2 / gamma * Math.sqrt(this.projparam._s1s2p1 - gamma * Math.sin(theta * deg)) / deg;
    }
  });

  // js/crs/Cylindrical.js
  var import_leaflet27 = __toESM(require_leaflet_src());
  Cylindrical = Projection.extend({
    _projInit: function() {
      const deg = Math.PI / 180, projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._lambda = projparam2.pv[1][1];
      if (projparam2._lambda === 0) {
        projparam2._lambda = 1;
      }
      projparam2._natrval = (0, import_leaflet27.latLng)(0, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _rToTheta: function(r) {
      return r;
    },
    _thetaToR: function(theta) {
      return theta;
    }
  });
  var CAR = Cylindrical.extend({
    _redToPhiR: function(red) {
      return (0, import_leaflet27.latLng)(red.y, red.x);
    },
    _phiRToRed: function(phiR) {
      return (0, import_leaflet27.point)(phiR.lng, phiR.lat);
    }
  });
  var CEA = Cylindrical.extend({
    _redToPhiR: function(red) {
      const deg = Math.PI / 180, slat = red.y * this.projparam._lambda * deg;
      return (0, import_leaflet27.latLng)(slat > -1 ? slat < 1 ? Math.asin(slat) / deg : 90 : -90, red.x);
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180;
      return (0, import_leaflet27.point)(
        phiR.lng,
        Math.sin(phiR.lat * deg) / (this.projparam._lambda * deg)
      );
    }
  });

  // js/crs/Zenithal.js
  var import_leaflet28 = __toESM(require_leaflet_src());
  Zenithal = Projection.extend({
    _projInit: function() {
      const projparam2 = this.projparam;
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._natrval = (0, import_leaflet28.latLng)(90, 0);
      projparam2._natpole = this._natpole();
      projparam2._cpole = this._cpole();
      projparam2._infinite = true;
      projparam2._pixelFlag = false;
    },
    _redToPhiR: function(red) {
      return (0, import_leaflet28.latLng)(
        Math.sqrt(red.x * red.x + red.y * red.y),
        Math.atan2(red.x, -red.y) * 180 / Math.PI
      );
    },
    _phiRToRed: function(phiR) {
      const deg = Math.PI / 180, p = phiR.lng * deg;
      return (0, import_leaflet28.point)(phiR.lat * Math.sin(p), -phiR.lat * Math.cos(p));
    }
  });
  var TAN = Zenithal.extend({
    code: "TAN",
    _rToTheta: function(r) {
      return Math.atan2(180, Math.PI * r) * 180 / Math.PI;
    },
    _thetaToR: function(theta) {
      return Math.tan((90 - theta) * Math.PI / 180) * 180 / Math.PI;
    }
  });
  var TPV = TAN.extend({
    code: "TPV",
    _pixToRed: function(pix) {
      const projparam2 = this.projparam, cd = projparam2.cd, dred2 = pix.subtract(projparam2.crpix);
      return this._dRedToRed((0, import_leaflet28.point)(
        dred2.x * cd[0][0] + dred2.y * cd[0][1],
        dred2.x * cd[1][0] + dred2.y * cd[1][1]
      ));
    },
    _redToPix: function(red) {
      const projparam2 = this.projparam, cdinv = projparam2._cdinv;
      dred = this._redToDRed(red);
      return (0, import_leaflet28.point)(
        dred.x * cdinv[0][0] + dred.y * cdinv[0][1],
        dred.x * cdinv[1][0] + dred.y * cdinv[1][1]
      ).add(projparam2.crpix);
    },
    _dRedToRed: function(dred2) {
      const projparam2 = this.projparam, pvx = projparam2.pv[0], pvy = projparam2.pv[1], dx = dred2.x, dy = dred2.y;
      let x = pvx[0], y = pvy[0], npv = projparam2.npv;
      do {
        if (!--npv) {
          break;
        }
        ;
        x += pvx[1] * dx;
        y += pvy[1] * dy;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[2] * dy;
        y += pvy[2] * dx;
        if (!--npv) {
          break;
        }
        ;
        const dr = Math.sqrt(dx * dx + dy * dy);
        x += pvx[3] * dr;
        y += pvy[3] * dr;
        if (!--npv) {
          break;
        }
        ;
        const dx2 = dx * dx, dy2 = dy * dy;
        x += pvx[4] * dx2;
        y += pvy[4] * dy2;
        if (!--npv) {
          break;
        }
        ;
        const dxy = dx * dy;
        x += pvx[5] * dxy;
        y += pvy[5] * dxy;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[6] * dy2;
        y += pvy[6] * dx2;
        if (!--npv) {
          break;
        }
        ;
        const dx3 = dx2 * dx, dy3 = dy2 * dy;
        x += pvx[7] * dx3;
        y += pvy[7] * dy3;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[8] * dx2 * dy;
        y += pvy[8] * dy2 * dx;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[9] * dx * dy2;
        y += pvy[9] * dy * dx2;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[10] * dy3;
        y += pvy[10] * dx3;
        if (!--npv) {
          break;
        }
        ;
        const dr3 = dr * dr * dr;
        x += pvx[11] * dr3;
        y += pvy[11] * dr3;
        if (!--npv) {
          break;
        }
        ;
        const dx4 = dx2 * dx2, dy4 = dy2 * dy2;
        x += pvx[12] * dx4;
        y += pvy[12] * dy4;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[13] * dx3 * dy;
        y += pvy[13] * dy3 * dx;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[14] * dx2 * dy2;
        y += pvy[14] * dy2 * dx2;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[15] * dx * dy3;
        y += pvy[15] * dy * dx3;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[16] * dy4;
        y += pvy[16] * dx4;
        if (!--npv) {
          break;
        }
        ;
        const dx5 = dx4 * dx, dy5 = dy4 * dy;
        x += pvx[17] * dx5;
        y += pvy[17] * dy5;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[18] * dx4 * dy;
        y += pvy[18] * dy4 * dx;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[19] * dx3 * dy2;
        y += pvy[19] * dy3 * dx2;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[20] * dx2 * dy3;
        y += pvy[20] * dy2 * dx3;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[21] * dx * dy4;
        y += pvy[21] * dy * dx4;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[22] * dy5;
        y += pvy[22] * dx5;
        if (!--npv) {
          break;
        }
        ;
        const dr5 = dr3 * dr * dr;
        x += pvx[23] * dr5;
        y += pvy[23] * dr5;
        if (!--npv) {
          break;
        }
        ;
        const dx6 = dx5 * dx, dy6 = dy5 * dy;
        x += pvx[24] * dx6;
        y += pvy[24] * dy6;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[25] * dx5 * dy;
        y += pvy[25] * dy5 * dx;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[26] * dx4 * dy2;
        y += pvy[26] * dy4 * dx2;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[27] * dx3 * dy3;
        y += pvy[27] * dy3 * dx3;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[28] * dx2 * dy4;
        y += pvy[28] * dy2 * dx4;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[29] * dx * dy5;
        y += pvy[29] * dy * dx5;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[30] * dy6;
        y += pvy[30] * dx6;
        if (!--npv) {
          break;
        }
        ;
        const dx7 = dx6 * dx, dy7 = dy6 * dy;
        x += pvx[31] * dx7;
        y += pvy[31] * dy7;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[32] * dx6 * dy;
        y += pvy[32] * dy6 * dx;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[33] * dx5 * dy2;
        y += pvy[33] * dy5 * dx2;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[34] * dx4 * dy3;
        y += pvy[34] * dy4 * dx3;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[35] * dx3 * dy4;
        y += pvy[35] * dy3 * dx4;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[36] * dx2 * dy5;
        y += pvy[36] * dy2 * dx5;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[37] * dx * dy6;
        y += pvy[37] * dy * dx6;
        if (!--npv) {
          break;
        }
        ;
        x += pvx[38] * dy7;
        y += pvy[38] * dx7;
        if (!--npv) {
          break;
        }
        ;
        const dr7 = dr5 * dr * dr;
        x += pvx[39] * dr7;
        y += pvy[39] * dr7;
      } while (false);
      return (0, import_leaflet28.point)(x, y);
    },
    _redToDRed: function(red) {
      const projparam2 = this.projparam, dx = red.x, dy = red.y, red1 = red.multiplyBy(2).subtract(this._dRedToRed(red));
      return red1.add(red.subtract(this._dRedToRed(red1)));
    }
  });
  var ZEA = Zenithal.extend({
    code: "ZEA",
    _rToTheta: function(r) {
      const rr = r * Math.PI / 360;
      if (Math.abs(rr) < 1) {
        return 90 - 2 * Math.asin(rr) * 180 / Math.PI;
      } else {
        return 90;
      }
    },
    _thetaToR: function(theta) {
      return Math.sin((90 - theta) * Math.PI / 360) * 360 / Math.PI;
    }
  });

  // js/crs/Pixel.js
  var import_leaflet29 = __toESM(require_leaflet_src());
  var Pixel = Projection.extend({
    code: "PIX",
    _projInit: function() {
      const projparam2 = this.projparam;
      if (!this.options.crval) {
        projparam2.crval = (0, import_leaflet29.latLng)(
          (projparam2.naxis.y + 1) / 2,
          (projparam2.naxis.x + 1) / 2
        );
      }
      projparam2._cdinv = this._invertCD(projparam2.cd);
      projparam2._cpole = projparam2.crval;
      this.bounds = (0, import_leaflet29.bounds)(
        [0.5, this.projparam.naxis.y - 0.5],
        [this.projparam.naxis.x - 0.5, 0.5]
      );
      projparam2._pixelFlag = true;
      projparam2._infinite = false;
    },
    project: function(latlng) {
      return (0, import_leaflet29.point)(latlng.lng, latlng.lat);
    },
    unproject: function(point8) {
      return (0, import_leaflet29.latLng)(point8.y, point8.x);
    }
  });

  // js/crs/WCS.js
  CRSclass = import_leaflet30.Class.extend(import_leaflet30.CRS);
  var WCS = CRSclass.extend({
    code: "WCS",
    options: {
      nzoom: 9,
      nativeCelSys: false
    },
    initialize: function(header, images2, options) {
      const nimages = images2.length;
      options = import_leaflet30.Util.setOptions(this, options);
      this.nzoom = options.nzoom;
      this.projection = this.getProjection(header, options);
      const merged_proj = this.projection;
      if (nimages > 1) {
        this.projections = new Array(nimages);
        for (const [i2, image] of images2.entries()) {
          var proj2 = this.getProjection(
            image.header,
            {
              nativeCelSys: options.nativeCelSys,
              dataslice: image.dataslice,
              detslice: image.detslice
            }
          );
          if (proj2.name === "") {
            proj2.name = "#" + str(i2 + 1);
          }
          proj2.centerPnt = proj2._getCenter(merged_proj);
          this.projections[i2] = proj2;
        }
        this.latLngToPoint = this.multiLatLngToPoint;
        this.pointToLatLng = this.multiPointToLatLng;
        this.project = this.multiProject;
        this.unproject = this.multiUnproject;
      }
      this.naxis = merged_proj.projparam.naxis;
      this.centerLatLng = merged_proj.unproject(
        merged_proj._getCenter(merged_proj)
      );
      this.wrapLng = [0.5, this.naxis.x - 0.5];
      this.wrapLat = [this.naxis.y - 0.5, 0.5];
      this.transformation = new import_leaflet30.Transformation(
        1,
        -0.5,
        -1,
        this.naxis.y + 0.5
      );
      this.code += ":" + merged_proj.code;
      this.equatorialFlag = merged_proj.equatorialFlag;
      this.celSysCode = merged_proj.projparam._celsyscode;
      this.pixelFlag = merged_proj.projparam._pixelFlag;
      this.infinite = merged_proj.projparam._infinite;
      this.jd = merged_proj.projparam.jd;
      this.obslatlng = merged_proj.projparam.obslatlng;
    },
    transform(pnt, zoom2) {
      return this.transformation._transform(pnt, this.scale(zoom2));
    },
    untransform(layerpnt, zoom2) {
      return this.transformation.untransform(layerpnt, this.scale(zoom2));
    },
    multiLatLngToPoint(latlng, zoom2) {
      return this.transform(this.multiProject(latlng), zoom2);
    },
    multiPointToLatLng(pnt, zoom2) {
      return this.multiUnproject(this.untransform(pnt, zoom2));
    },
    multiProject(latlng) {
      const proj1 = this.projections[this.multiLatLngToIndex(latlng)], pnt = proj1._pixToMulti(proj1.project(latlng)), proj2 = this.projections[this.multiPntToIndex(pnt)];
      return proj2._pixToMulti(proj2.project(latlng));
    },
    multiUnproject(pnt) {
      const proj2 = this.projections[this.multiPntToIndex(pnt)];
      return proj2.unproject(proj2._multiToPix(pnt));
    },
    multiLatLngToIndex(latlng) {
      return this.multiPntToIndex(this.projection.project(latlng));
    },
    multiPntToIndex(pnt) {
      let dc = 1e30, pc = -1;
      for (var p in this.projections) {
        var pntc = this.projections[p].centerPnt;
        if ((d = pnt.distanceTo(pntc)) < dc) {
          pc = p;
          dc = d;
        }
      }
      return pc;
    },
    getProjection: function(header, options) {
      const ctype1 = header["CTYPE1"] || "PIXEL";
      switch (ctype1.substr(5, 3)) {
        case "ZEA":
          proj = new ZEA(header, options);
          break;
        case "TAN":
          proj = new TAN(header, options);
          break;
        case "TPV":
          proj = new TPV(header, options);
          break;
        case "CAR":
          proj = new CAR(header, options);
          break;
        case "CEA":
          proj = new CEA(header, options);
          break;
        case "COE":
          proj = new COE(header, options);
          break;
        default:
          proj = new Pixel(header, options);
          break;
      }
      return proj;
    },
    scale: function(zoom2) {
      return Math.pow(2, zoom2 - this.nzoom + 1);
    },
    zoom: function(scale2) {
      return Math.log(scale2) / Math.LN2 + this.nzoom - 1;
    },
    rawPixelScale: function(latlng) {
      const p0 = this.projection.project(latlng), latlngdx = this.projection.unproject(p0.add([10, 0])), latlngdy = this.projection.unproject(p0.add([0, 10]));
      let dlngdx = latlngdx.lng - latlng.lng, dlngdy = latlngdy.lng - latlng.lng;
      if (dlngdx > 180) {
        dlngdx -= 360;
      } else if (dlngdx < -180) {
        dlngdx += 360;
      }
      if (dlngdy > 180) {
        dlngdy -= 360;
      } else if (dlngdy < -180) {
        dlngdy += 360;
      }
      return 0.1 * Math.sqrt(Math.abs(dlngdx * (latlngdy.lat - latlng.lat) - dlngdy * (latlngdx.lat - latlng.lat)) * Math.cos(latlng.lat * Math.PI / 180));
    },
    pixelScale: function(zoom2, latlng) {
      return this.rawPixelScale(latlng) / this.scale(zoom2);
    },
    fovToZoom: function(map4, fov, latlng) {
      const size = map4.getSize();
      let scale2 = this.rawPixelScale(latlng);
      if (fov < scale2) {
        fov = scale2;
      }
      scale2 *= Math.sqrt(size.x * size.x + size.y * size.y);
      return fov > 0 ? this.zoom(scale2 / fov) : this.nzoom - 1;
    },
    zoomToFov: function(map4, zoom2, latlng) {
      const size = map4.getSize(), scale2 = this.rawPixelScale(latlng) * Math.sqrt(size.x * size.x + size.y * size.y), zscale = this.scale(zoom2);
      return zscale > 0 ? scale2 / zscale : scale2;
    },
    distance: function(latlng1, latlng2) {
      const rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(
        (latlng2.lng - latlng1.lng) * rad
      );
      return 180 / Math.PI * Math.acos(Math.min(a, 1));
    },
    parseCoords: function(str2) {
      let latlng = this.hmsDMSToLatLng(str2);
      if (typeof latlng === "undefined") {
        let result = /(?:%J\s|^)([-+]?\d+\.?\d*)\s*[,\s]+\s*([-+]?\d+\.?\d*)/g.exec(str2);
        if (result && result.length >= 3) {
          latlng = (0, import_leaflet30.latLng)(Number(result[2]), Number(result[1]));
        }
      }
      if (latlng) {
        if (this.projection.celSysConvFlag) {
          latlng = this.projection.eqToCelSys(latlng);
        }
        return latlng;
      } else {
        return void 0;
      }
    },
    latLngToHMSDMS: function(latlng) {
      let lng = (latlng.lng + 360) / 360;
      lng = (lng - Math.floor(lng)) * 24;
      let h = Math.floor(lng), mf = (lng - h) * 60, m = Math.floor(mf), sf = (mf - m) * 60;
      if (sf >= 60) {
        m++;
        sf = 0;
      }
      if (m === 60) {
        h++;
        m = 0;
      }
      const str2 = (h < 10 ? "0" : "") + h.toString() + ":" + (m < 10 ? "0" : "") + m.toString() + ":" + (sf < 10 ? "0" : "") + sf.toFixed(3), lat = Math.abs(latlng.lat), sgn = latlng.lat < 0 ? "-" : "+", d2 = Math.floor(lat);
      mf = (lat - d2) * 60;
      m = Math.floor(mf);
      sf = (mf - m) * 60;
      if (sf >= 60) {
        m++;
        sf = 0;
      }
      if (m === 60) {
        h++;
        m = 0;
      }
      return str2 + " " + sgn + (d2 < 10 ? "0" : "") + d2.toString() + ":" + (m < 10 ? "0" : "") + m.toString() + ":" + (sf < 10 ? "0" : "") + sf.toFixed(2);
    },
    hmsDMSToLatLng: function(str2) {
      var result;
      result = /^\s*(\d+)[h:](\d+)[m':](\d+\.?\d*)[s"]?\s*,?\s*([-+]?)(\d+)[d°:](\d+)[m':](\d+\.?\d*)[s"]?/g.exec(str2);
      if (result && result.length >= 8) {
        const sgn = Number(result[4] + "1");
        return (0, import_leaflet30.latLng)(
          sgn * (Number(result[5]) + Number(result[6]) / 60 + Number(result[7]) / 3600),
          Number(result[1]) * 15 + Number(result[2]) / 4 + Number(result[3]) / 240
        );
      } else {
        return void 0;
      }
    },
    _deltaLng: function(latLng11, latLng0) {
      const dlng = latLng11.lng - latLng0.lng;
      return dlng > 180 ? dlng - 360 : dlng < -180 ? dlng + 360 : dlng;
    }
  });
  var wcs = function(header, images2, options) {
    return new WCS(header, images2, options);
  };

  // js/layer/index.js
  var layer_exports = {};
  __export(layer_exports, {
    VTileLayer: () => VTileLayer,
    vTileLayer: () => vTileLayer
  });

  // js/layer/VTileLayer.js
  var import_leaflet31 = __toESM(require_leaflet_src());
  var VTileLayer = import_leaflet31.TileLayer.extend({
    options: {
      title: null,
      crs: null,
      nativeCelSys: false,
      center: null,
      fov: null,
      minZoom: 0,
      maxZoom: null,
      maxNativeZoom: 18,
      noWrap: true,
      contrast: null,
      colorSat: null,
      gamma: null,
      cMap: "grey",
      invertCMap: false,
      quality: null,
      mixingMode: "color",
      channelColors: [],
      channelLabels: [],
      channelLabelMatch: ".*",
      channelUnits: [],
      minMaxValues: [],
      defaultChannel: 0,
      sesameURL: "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame",
      credentials: null
    },
    visioDefault: {
      contrast: 1,
      gamma: 2.2,
      cMap: "grey",
      invertCMap: false,
      minValue: [],
      maxValue: [],
      channelColors: [
        [""],
        ["#FFFFFF"],
        ["#00BAFF", "#FFBA00"],
        ["#0000FF", "#00BA00", "#FF0000"],
        ["#0000E0", "#00BA88", "#88BA00", "#E00000"],
        ["#0000CA", "#007BA8", "#00CA00", "#A87B00", "#CA0000"],
        ["#0000BA", "#00719B", "#009B71", "#719B00", "#9B7100", "#BA0000"]
      ],
      quality: 90
    },
    initialize: function(url, options) {
      this.type = "tilelayer";
      this._url = url.replace(/\&.*$/g, "");
      options = import_leaflet31.Util.setOptions(this, options);
      if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);
        options.zoomOffset++;
        options.minZoom = Math.max(0, options.minZoom);
        options.maxZoom--;
      }
      if (typeof options.subdomains === "string") {
        options.subdomains = options.subdomains.split("");
      }
      this.tileSize = { x: 256, y: 256 };
      this.visio = {
        imageSize: [[this.tileSize]],
        gridSize: [{ x: 1, y: 1 }],
        bpp: 8,
        mixingMode: options.mixingMode,
        channel: 0,
        nChannel: 1,
        minZoom: options.minZoom,
        maxZoom: options.maxZoom,
        contrast: options.contrast,
        colorSat: options.colorSat,
        gamma: options.gamma,
        cMap: options.cMap,
        invertCMap: options.invertCMap,
        minValue: [0],
        maxValue: [255],
        mix: [[]],
        rgb: [],
        channelLabels: [],
        channelFlags: [],
        channelUnits: [],
        quality: options.quality
      };
      this._title = options.title ? options.title : this._url.match(/^.*\/(.*)\..*$/)[1];
      this.getMetaData(this._url);
      if (!import_leaflet31.Browser.android) {
        this.on("tileunload", this._onTileRemove);
      }
      return this;
    },
    getMetaData: async function(url) {
      const res = await fetch(url + "&INFO", { method: "GET" });
      const meta = await res.json();
      if (res.status == 200 && meta["type"] == "visiomatic") {
        const options = this.options, visio = this.visio, visioDefault = this.visioDefault, maxsize = { x: meta.full_size[0], y: meta.full_size[1] };
        this.tileSize = { x: meta.tile_size[0], y: meta.tile_size[1] };
        options.tileSize = this.tileSize.x;
        visio.maxZoom = meta.tile_levels - 1;
        if (visio.minZoom > options.minZoom) {
          options.minZoom = visio.minZoom;
        }
        if (!options.maxZoom) {
          options.maxZoom = visio.maxZoom + 6;
        }
        if (options.maxNativeZoom > visio.maxZoom) {
          options.maxNativeZoom = visio.maxZoom;
        }
        for (let z = 0; z <= visio.maxZoom; z++) {
          visio.imageSize[z] = {
            x: Math.floor(maxsize.x / Math.pow(2, visio.maxZoom - z)),
            y: Math.floor(maxsize.y / Math.pow(2, visio.maxZoom - z))
          };
          visio.gridSize[z] = {
            x: Math.ceil(visio.imageSize[z].x / this.tileSize.x),
            y: Math.ceil(visio.imageSize[z].y / this.tileSize.y)
          };
        }
        for (let z = visio.maxZoom; z <= options.maxZoom; z++) {
          visio.gridSize[z] = visio.gridSize[visio.maxZoom];
        }
        visio.bpp = meta.bits_per_channel;
        nchannel = visio.nChannel = meta.channels;
        if (meta.contrast) {
          visioDefault.contrast = meta.contrast;
        }
        if (!visio.contrast) {
          visio.contrast = visioDefault.contrast;
        }
        if (meta.colorSat) {
          visioDefault.colorSat = meta.colorSat;
        }
        if (!visio.colorSat) {
          visio.colorSat = visioDefault.colorSat;
        }
        if (meta.gamma) {
          visioDefault.gamma = meta.gamma;
        }
        if (!visio.gamma) {
          visio.gamma = visioDefault.gamma;
        }
        if (meta.quality) {
          visioDefault.quality = meta.quality;
        }
        if (!visio.quality) {
          visio.quality = visioDefault.quality;
        }
        images = meta.images;
        for (let c3 = 0; c3 < nchannel; c3++) {
          visioDefault.minValue[c3] = images[0].min_max[c3][0];
          visioDefault.maxValue[c3] = images[0].min_max[c3][1];
        }
        const minmax = options.minMaxValues;
        if (minmax.length) {
          for (let c3 = 0; c3 < nchannel; c3++) {
            if (minmax[c3] !== void 0 && minmax[c3].length) {
              visio.minValue[c3] = minmax[c3][0];
              visio.maxValue[c3] = minmax[c3][1];
            } else {
              visio.minValue[c3] = visioDefault.minValue[c3];
              visio.maxValue[c3] = visioDefault.maxValue[c3];
            }
          }
        } else {
          for (let c3 = 0; c3 < nchannel; c3++) {
            visio.minValue[c3] = visioDefault.minValue[c3];
            visio.maxValue[c3] = visioDefault.maxValue[c3];
          }
        }
        visio.channel = options.defaultChannel;
        const inlabels = options.channelLabels, ninlabel = inlabels.length, labels = visio.channelLabels, inunits = options.channelUnits, ninunits = inunits.length, units = visio.channelUnits, key = VUtil.readFITSKey;
        let label = "Channel";
        if (nchannel === 1 && (filter = images[0].header["FILTER"])) {
          label = filter;
        }
        for (let c3 = 0; c3 < nchannel; c3++) {
          if (c3 < ninlabel) {
            labels[c3] = inlabels[c3];
          } else {
            labels[c3] = nchannel > 1 ? "Channel #" + (c3 + 1).toString() : filter;
          }
        }
        for (const c3 in inunits) {
          units[c3] = inunits[c3];
        }
        for (let c3 = ninunits; c3 < nchannel; c3++) {
          units[c3] = "ADUs";
        }
        const mix = visio.mix, colors2 = options.channelColors, rgb2 = visio.rgb, re = new RegExp(options.channelLabelMatch), channelflags = visio.channelFlags;
        let cc = 0, nchanon = 0;
        for (var c2 = 0; c2 < nchannel; c2++) {
          channelflags[c2] = re.test(labels[c2]);
          if (channelflags[c2]) {
            nchanon++;
          }
        }
        if (nchanon >= visioDefault.channelColors.length) {
          nchanon = visioDefault.channelColors.length - 1;
        }
        if (colors2.length) {
          for (const c3 in colors2) {
            rgb2[c3] = rgb(colors2[c3][0], colors2[c3][1], colors2[c3][2]);
            mix[c3] = [];
            this.rgbToMix(c3);
          }
        } else {
          rgb2[0] = rgb(visioDefault.channelColors[3][0]);
          rgb2[Math.floor(nchannel / 2)] = rgb(visioDefault.channelColors[3][1]);
          rgb2[nchannel - 1] = rgb(visioDefault.channelColors[3][2]);
        }
        if (options.bounds) {
          options.bounds = (0, import_leaflet31.latLngBounds)(options.bounds);
        }
        this.wcs = options.crs ? options.crs : new WCS(
          meta.header,
          meta.images,
          {
            nativeCelSys: this.options.nativeCelSys,
            nzoom: visio.maxZoom + 1
          }
        );
        visio.metaReady = true;
        this.fire("metaload");
      } else {
        alert(
          "VisiOmatic metadata query error: " + meta.detail[0].msg + "."
        );
      }
    },
    getChannelColor: function(channel) {
      const rgb2 = this.visio.rgb;
      return channel in rgb2 ? this.visio.rgb[channel].toStr() : "";
    },
    rgbToMix: function(channel, rgb2) {
      const visio = this.visio;
      if (rgb2) {
        visio.rgb[channel] = rgb2.clone();
      } else if (rgb2 == false) {
        delete visio.rgb[channel];
        delete visio.mix[channel];
        return;
      } else {
        rgb2 = visio.rgb[channel];
      }
      const cr = this._gammaCorr(rgb2.r), cg = this._gammaCorr(rgb2.g), cb = this._gammaCorr(rgb2.b), lum = (cr + cg + cb) / 3, alpha2 = visio.colorSat / 3;
      visio.mix[channel] = [];
      visio.mix[channel][0] = lum + alpha2 * (2 * cr - cg - cb);
      visio.mix[channel][1] = lum + alpha2 * (2 * cg - cr - cb);
      visio.mix[channel][2] = lum + alpha2 * (2 * cb - cr - cg);
      return;
    },
    updateMono: function() {
      this.visio.mode = "mono";
    },
    updateMix: function() {
      const visio = this.visio;
      visio.mode = "color";
      for (const c2 in visio.rgb) {
        this.rgbToMix(c2);
      }
    },
    _gammaCorr: function(val) {
      return val > 0 ? Math.pow(val, this.visio.gamma) : 0;
    },
    _readVisioKey: function(str2, keyword, regexp) {
      const reg = new RegExp(keyword + ":" + regexp);
      return reg.exec(str2);
    },
    _setAttr: function(attr, value, fn2 = void 0) {
      const attrarr = attr.split(/\[|\]/);
      if (attrarr[1]) {
        this.visio[attrarr[0]][parseInt(attrarr[1], 10)] = value;
      } else {
        this.visio[attrarr[0]] = value;
      }
      if (fn2) {
        fn2(this);
      }
      this.redraw();
    },
    addTo: function(map4) {
      if (this.visio.metaReady) {
        this._addToMap(map4);
      } else {
        this._loadActivity = import_leaflet31.DomUtil.create(
          "div",
          "visiomatic-layer-activity",
          map4._controlContainer
        );
        this.once("metaload", function() {
          this._addToMap(map4);
          map4._controlContainer.removeChild(this._loadActivity);
        }, this);
      }
      return this;
    },
    _addToMap: function(map4) {
      const newcrs = this.wcs, curcrs = map4.options.crs, prevcrs = map4._prevcrs, maploadedflag = map4._loaded;
      var zoom2, center;
      if (maploadedflag) {
        curcrs._prevLatLng = map4.getCenter();
        curcrs._prevZoom = map4.getZoom();
      }
      map4._prevcrs = map4.options.crs = newcrs;
      import_leaflet31.TileLayer.prototype.addTo.call(this, map4);
      if (prevcrs && newcrs !== curcrs && maploadedflag && newcrs.pixelFlag === curcrs.pixelFlag) {
        center = curcrs._prevLatLng;
        zoom2 = curcrs._prevZoom;
        const prevpixscale = prevcrs.pixelScale(zoom2, center), newpixscale = newcrs.pixelScale(zoom2, center);
        if (prevpixscale > 1e-20 && newpixscale > 1e-20) {
          zoom2 += Math.round(Math.LOG2E * Math.log(newpixscale / prevpixscale));
        }
      } else if (newcrs._prevLatLng) {
        center = newcrs._prevLatLng;
        zoom2 = newcrs._prevZoom;
      } else if (this.options.center) {
        const latlng = typeof this.options.center === "string" ? newcrs.parseCoords(decodeURI(this.options.center)) : this.options.center;
        if (latlng) {
          if (this.options.fov) {
            zoom2 = newcrs.fovToZoom(map4, this.options.fov, latlng);
          }
          map4.setView(latlng, zoom2, { reset: true, animate: false });
        } else {
          VUtil.requestURL(
            this.options.sesameURL + "/-oI/A?" + this.options.center,
            "getting coordinates for " + this.options.center,
            function(_this, httpRequest) {
              if (httpRequest.readyState === 4) {
                if (httpRequest.status === 200) {
                  const str2 = httpRequest.responseText, newLatlng = newcrs.parseCoords(str2);
                  if (newLatlng) {
                    if (_this.options.fov) {
                      zoom2 = newcrs.fovToZoom(
                        map4,
                        _this.options.fov,
                        newLatlng
                      );
                    }
                    map4.setView(
                      newLatlng,
                      zoom2,
                      { reset: true, animate: false }
                    );
                  } else {
                    map4.setView(
                      newcrs.crval,
                      zoom2,
                      { reset: true, animate: false }
                    );
                    alert(str2 + ": Unknown location");
                  }
                } else {
                  map4.setView(
                    newcrs.crval,
                    zoom2,
                    { reset: true, animate: false }
                  );
                  alert("Error with Sesame query at CDS");
                }
              }
            },
            this,
            10
          );
        }
      } else {
        map4.setView(
          newcrs.centerLatLng,
          zoom2,
          { reset: true, animate: false }
        );
      }
    },
    _isValidTile: function(coords2) {
      const crs = this._map.options.crs;
      if (!crs.infinite) {
        const bounds3 = this._globalTileRange;
        if (!crs.wrapLng && (coords2.x < bounds3.min.x || coords2.x > bounds3.max.x) || !crs.wrapLat && (coords2.y < bounds3.min.y || coords2.y > bounds3.max.y)) {
          return false;
        }
      }
      const z = this._getZoomForUrl(), wcoords = coords2.clone();
      this._wrapCoords(wcoords);
      if (wcoords.x < 0 || wcoords.x >= this.visio.gridSize[z].x || wcoords.y < 0 || wcoords.y >= this.visio.gridSize[z].y) {
        return false;
      }
      if (!this.options.bounds) {
        return true;
      }
      return (0, import_leaflet31.latLngBounds)(this.options.bounds).intersects(
        this._tileCoordsToBounds(coords2)
      );
    },
    createTile: function(coords2, done) {
      const tile2 = import_leaflet31.TileLayer.prototype.createTile.call(this, coords2, done);
      tile2.coords = coords2;
      return tile2;
    },
    getTileUrl: function(coords2) {
      const visio = this.visio, visioDefault = this.visioDefault, z = this._getZoomForUrl();
      let str2 = this._url;
      if (visio.cMap !== visioDefault.cMap) {
        str2 += "&CMP=" + visio.cMap;
      }
      if (visio.invertCMap !== visioDefault.invertCMap) {
        str2 += "&INV";
      }
      if (visio.contrast !== visioDefault.contrast) {
        str2 += "&CNT=" + visio.contrast.toString();
      }
      if (visio.gamma !== visioDefault.gamma) {
        str2 += "&GAM=" + (1 / visio.gamma).toFixed(4);
      }
      const nchannel2 = visio.nChannel, mix = visio.mix;
      if (visio.mode === "color") {
        for (let c2 = 0; c2 < visio.nChannel; c2++) {
          if (visio.minValue[c2] !== visioDefault.minValue[c2] || visio.maxValue[c2] !== visioDefault.maxValue[c2]) {
            str2 += "&MINMAX=" + (c2 + 1).toString() + ":" + visio.minValue[c2].toString() + "," + visio.maxValue[c2].toString();
          }
        }
        for (const m in mix) {
          str2 += "&MIX=" + (parseInt(m, 10) + 1).toString() + ":";
          for (let n = 0; n < 3; n++) {
            if (n) {
              str2 += ",";
            }
            str2 += mix[m][n].toFixed(3);
          }
        }
      } else {
        const chan = visio.channel;
        let chanp1 = chan + 1;
        if (chanp1 > nchannel2) {
          chanp1 = 1;
        }
        str2 += "&CHAN=" + chanp1.toString();
        if (visio.minValue[chan] !== visioDefault.minValue[chan] || visio.maxValue[chan] !== visioDefault.maxValue[chan]) {
          str2 += "&MINMAX=" + chanp1.toString() + ":" + visio.minValue[chan].toString() + "," + visio.maxValue[chan].toString();
        }
      }
      if (visio.quality !== visioDefault.quality) {
        str2 += "&QLT=" + visio.quality.toString();
      }
      return str2 + "&JTL=" + z.toString() + "," + (coords2.x + visio.gridSize[z].x * coords2.y).toString();
    },
    _initTile: function(tile2) {
      import_leaflet31.DomUtil.addClass(tile2, "leaflet-tile");
      if (this._tileZoom >= this.options.maxNativeZoom) {
        tile2.style.imageRendering = "pixelated";
      }
      tile2.onselectstart = import_leaflet31.Util.falseFn;
      tile2.onmousemove = import_leaflet31.Util.falseFn;
      if (import_leaflet31.Browser.ielt9 && this.options.opacity < 1) {
        import_leaflet31.DomUtil.setOpacity(tile2, this.options.opacity);
      }
      if (import_leaflet31.Browser.android && !import_leaflet31.Browser.android23) {
        tile2.style.WebkitBackfaceVisibility = "hidden";
      }
    },
    _refreshTileUrl: function(tile2, url) {
      const img = new Image();
      img.onload = function() {
        L.Util.requestAnimFrame(function() {
          tile2.el.src = url;
        });
      };
      img.src = url;
    },
    redraw: function() {
      const wasAnimated = this._map._fadeAnimated;
      this._map._fadeAnimated = false;
      for (var key in this._tiles) {
        tile = this._tiles[key];
        if (tile.current && tile.active) {
          const oldsrc = tile.el.src, newsrc = this.getTileUrl(tile.coords);
          if (oldsrc != newsrc) {
            this._refreshTileUrl(tile, newsrc);
          }
        }
      }
      if (wasAnimated) {
        setTimeout(function() {
          map._fadeAnimated = wasAnimated;
        }, 5e3);
      }
    }
  });
  var vTileLayer = function(url, options) {
    return new VTileLayer(url, options);
  };

  // js/VisiomaticGlobal.js
  function getGlobalObject() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("Unable to locate global object.");
  }
  var globalObject = getGlobalObject();
  globalObject.V = Visiomatic_exports;
})();
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v4.3.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
/*!
* chartjs-plugin-zoom v2.0.1
* undefined
 * (c) 2016-2023 chartjs-plugin-zoom Contributors
 * Released under the MIT License
 */
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
/**
 * spectrum-vanilla.js
 *
 * @copyright  Copyright (C) 2023.
 * @license    MIT
 */
